use crate::{Tool, ToolInput, ToolOutput, ToolSpec};
use anyhow::{anyhow, Result};
use console::style;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use syntect::easy::HighlightLines;
use syntect::highlighting::ThemeSet;
use syntect::parsing::SyntaxSet;
use syntect::util::{as_24_bit_terminal_escaped, LinesWithEndings};
use walkdir::WalkDir;

// FileReader - —á—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
pub struct FileReader {
    syntax_set: SyntaxSet,
    theme_set: ThemeSet,
}

impl FileReader {
    pub fn new() -> Self {
        Self {
            syntax_set: SyntaxSet::load_defaults_newlines(),
            theme_set: ThemeSet::load_defaults(),
        }
    }
    
    fn format_file_content(&self, path: &Path, content: &str) -> String {
        let syntax = self.syntax_set
            .find_syntax_for_file(path)
            .unwrap_or_else(|_| Some(self.syntax_set.find_syntax_plain_text()))
            .unwrap();
            
        let theme = self.theme_set.themes.get("base16-ocean.dark")
            .or_else(|| self.theme_set.themes.values().next())
            .unwrap();
        let mut highlighter = HighlightLines::new(syntax, theme);
        
        let mut formatted = String::new();
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∫—Ä–∞—Å–∏–≤—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
        formatted.push_str(&format!("{}‚îå‚îÄ {} {}\n", 
            style("").dim(),
            style("üìÑ").cyan(),
            style(path.display()).bright().bold()
        ));
        
        let lines: Vec<&str> = content.lines().collect();
        let line_count = lines.len();
        let line_width = line_count.to_string().len().max(3);
        
        for (i, line) in LinesWithEndings::from(content).enumerate() {
            let line_num = format!("{:width$}", i + 1, width = line_width);
            
            if let Ok(ranges) = highlighter.highlight_line(line, &self.syntax_set) {
                let escaped = as_24_bit_terminal_escaped(&ranges[..], false);
                formatted.push_str(&format!("{}‚îÇ {} ‚îÇ {}", 
                    style("").dim(),
                    style(line_num).dim(),
                    escaped
                ));
            } else {
                formatted.push_str(&format!("{}‚îÇ {} ‚îÇ {}", 
                    style("").dim(),
                    style(line_num).dim(),
                    line
                ));
            }
        }
        
        formatted.push_str(&format!("{}‚îî{}\n",
            style("").dim(),
            style("‚îÄ".repeat(60)).dim()
        ));
        
        formatted
    }
}

#[async_trait::async_trait]
impl Tool for FileReader {
    fn spec(&self) -> ToolSpec {
        ToolSpec {
            name: "file_read".to_string(),
            description: "–ß–∏—Ç–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–æ–≤ —Å –∫—Ä–∞—Å–∏–≤–æ–π –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞".to_string(),
            usage: "file_read <–ø—É—Ç—å>".to_string(),
            examples: vec![
                "file_read src/main.rs".to_string(),
                "file_read README.md".to_string(),
                "–ø–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ config.toml".to_string(),
            ],
            input_schema: r#"{"path": "string"}"#.to_string(),
        }
    }
    
    async fn execute(&self, input: ToolInput) -> Result<ToolOutput> {
        let path_str = input.args.get("path")
            .ok_or_else(|| anyhow!("–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä 'path'"))?;
        let path = PathBuf::from(path_str);
        
        if !path.exists() {
            return Ok(ToolOutput {
                success: false,
                result: format!("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {}", path.display()),
                formatted_output: None,
                metadata: HashMap::new(),
            });
        }
        
        if path.is_dir() {
            return Ok(ToolOutput {
                success: false,
                result: format!("–≠—Ç–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è, –Ω–µ —Ñ–∞–π–ª: {}", path.display()),
                formatted_output: None,
                metadata: HashMap::new(),
            });
        }
        
        let content = fs::read_to_string(&path)
            .map_err(|e| anyhow!("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {}", e))?;
            
        let formatted = self.format_file_content(&path, &content);
        
        let mut metadata = HashMap::new();
        metadata.insert("file_size".to_string(), content.len().to_string());
        metadata.insert("line_count".to_string(), content.lines().count().to_string());
        
        Ok(ToolOutput {
            success: true,
            result: content,
            formatted_output: Some(formatted),
            metadata,
        })
    }
    
    async fn parse_natural_language(&self, query: &str) -> Result<ToolInput> {
        // –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —è–∑—ã–∫–∞
        let mut args = HashMap::new();
        
        // –ò—â–µ–º –ø—É—Ç—å –≤ –∑–∞–ø—Ä–æ—Å–µ
        let words: Vec<&str> = query.split_whitespace().collect();
        
        // –ò—â–µ–º —Ñ–∞–π–ª —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ–º –∏–ª–∏ –ø—É—Ç–µ–º
        for word in &words {
            if word.contains('.') || word.starts_with('/') || word.starts_with("./") || word.starts_with("src/") {
                args.insert("path".to_string(), word.to_string());
                break;
            }
        }
        
        // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ —è–≤–Ω—ã–π –ø—É—Ç—å, –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–ª–æ–≤–æ
        if args.is_empty() && !words.is_empty() {
            args.insert("path".to_string(), words[words.len() - 1].to_string());
        }
        
        Ok(ToolInput {
            command: "file_read".to_string(),
            args,
            context: Some(query.to_string()),
        })
    }
}

// FileWriter - –∑–∞–ø–∏—Å—å —Ñ–∞–π–ª–æ–≤
pub struct FileWriter;

impl FileWriter {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait::async_trait]
impl Tool for FileWriter {
    fn spec(&self) -> ToolSpec {
        ToolSpec {
            name: "file_write".to_string(),
            description: "–ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ —Ñ–∞–π–ª".to_string(),
            usage: "file_write <–ø—É—Ç—å> <—Å–æ–¥–µ—Ä–∂–∏–º–æ–µ>".to_string(),
            examples: vec![
                "file_write README.md '# My Project'".to_string(),
                "—Å–æ–∑–¥–∞—Ç—å —Ñ–∞–π–ª config.toml —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏".to_string(),
            ],
            input_schema: r#"{"path": "string", "content": "string"}"#.to_string(),
        }
    }
    
    async fn execute(&self, input: ToolInput) -> Result<ToolOutput> {
        let path_str = input.args.get("path")
            .ok_or_else(|| anyhow!("–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä 'path'"))?;
        let content = input.args.get("content")
            .ok_or_else(|| anyhow!("–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä 'content'"))?;
            
        let path = PathBuf::from(path_str);
        
        // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| anyhow!("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {}", e))?;
        }
        
        fs::write(&path, content)
            .map_err(|e| anyhow!("–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ —Ñ–∞–π–ª–∞: {}", e))?;
            
        let formatted = format!("{}‚úì –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω: {}\n{}üìÑ –†–∞–∑–º–µ—Ä: {} –±–∞–π—Ç",
            style("").green(),
            style(path.display()).bright(),
            style("").dim(),
            content.len()
        );
        
        Ok(ToolOutput {
            success: true,
            result: format!("–§–∞–π–ª –∑–∞–ø–∏—Å–∞–Ω: {}", path.display()),
            formatted_output: Some(formatted),
            metadata: HashMap::new(),
        })
    }
    
    async fn parse_natural_language(&self, query: &str) -> Result<ToolInput> {
        let mut args = HashMap::new();
        
        // –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
        if query.contains("—Å–æ–∑–¥–∞–π") || query.contains("create") {
            let words: Vec<&str> = query.split_whitespace().collect();
            
            // –ò—â–µ–º –ø—É—Ç—å
            for word in &words {
                if word.contains('.') {
                    args.insert("path".to_string(), word.to_string());
                    break;
                }
            }
            
            // –ë–∞–∑–æ–≤–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
            let file_name = args.get("path").unwrap_or(&"new_file.txt".to_string()).clone();
            let content = if file_name.ends_with(".md") {
                format!("# {}\n\n–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞...\n", file_name.replace(".md", ""))
            } else if file_name.ends_with(".toml") {
                "[settings]\nkey = \"value\"\n".to_string()
            } else {
                "# –ù–æ–≤—ã–π —Ñ–∞–π–ª\n".to_string()
            };
            
            args.insert("content".to_string(), content);
        }
        
        Ok(ToolInput {
            command: "file_write".to_string(),
            args,
            context: Some(query.to_string()),
        })
    }
}

// DirLister - –ø—Ä–æ—Å–º–æ—Ç—Ä –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
pub struct DirLister;

impl DirLister {
    pub fn new() -> Self {
        Self
    }
    
    fn format_directory_tree(&self, path: &Path) -> Result<String> {
        let mut output = String::new();
        
        output.push_str(&format!("{}üìÅ {}\n", 
            style("").cyan(), 
            style(path.display()).bright().bold()
        ));
        
        let walker = WalkDir::new(path)
            .max_depth(3)
            .follow_links(false);
            
        for entry in walker {
            let entry = entry.map_err(|e| anyhow!("–û—à–∏–±–∫–∞ –æ–±—Ö–æ–¥–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {}", e))?;
            let entry_path = entry.path();
            let depth = entry.depth();
            
            if depth == 0 { continue; }
            
            let indent = "  ".repeat(depth);
            let name = entry_path.file_name()
                .unwrap_or_default()
                .to_string_lossy();
                
            if entry_path.is_dir() {
                output.push_str(&format!("{}{}üìÅ {}\n", 
                    style("").dim(), 
                    indent, 
                    style(name).blue()
                ));
            } else {
                let icon = match entry_path.extension().and_then(|s| s.to_str()) {
                    Some("rs") => "ü¶Ä",
                    Some("toml") => "‚öôÔ∏è",
                    Some("md") => "üìù",
                    Some("json") => "üìã",
                    Some("txt") => "üìÑ",
                    _ => "üìÑ",
                };
                
                output.push_str(&format!("{}{}{} {}\n", 
                    style("").dim(), 
                    indent, 
                    icon,
                    style(name).white()
                ));
            }
        }
        
        Ok(output)
    }
}

#[async_trait::async_trait]
impl Tool for DirLister {
    fn spec(&self) -> ToolSpec {
        ToolSpec {
            name: "dir_list".to_string(),
            description: "–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –≤ –≤–∏–¥–µ –∫—Ä–∞—Å–∏–≤–æ–≥–æ –¥–µ—Ä–µ–≤–∞".to_string(),
            usage: "dir_list <–ø—É—Ç—å>".to_string(),
            examples: vec![
                "dir_list .".to_string(),
                "dir_list src/".to_string(),
                "–ø–æ–∫–∞–∑–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏".to_string(),
            ],
            input_schema: r#"{"path": "string"}"#.to_string(),
        }
    }
    
    async fn execute(&self, input: ToolInput) -> Result<ToolOutput> {
        let default_path = ".".to_string();
        let path_str = input.args.get("path").unwrap_or(&default_path);
        let path = PathBuf::from(path_str);
        
        if !path.exists() {
            return Ok(ToolOutput {
                success: false,
                result: format!("–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {}", path.display()),
                formatted_output: None,
                metadata: HashMap::new(),
            });
        }
        
        if !path.is_dir() {
            return Ok(ToolOutput {
                success: false,
                result: format!("–≠—Ç–æ —Ñ–∞–π–ª, –Ω–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {}", path.display()),
                formatted_output: None,
                metadata: HashMap::new(),
            });
        }
        
        let formatted = self.format_directory_tree(&path)?;
        
        Ok(ToolOutput {
            success: true,
            result: format!("–°–æ–¥–µ—Ä–∂–∏–º–æ–µ: {}", path.display()),
            formatted_output: Some(formatted),
            metadata: HashMap::new(),
        })
    }
    
    async fn parse_natural_language(&self, query: &str) -> Result<ToolInput> {
        let mut args = HashMap::new();
        
        // –ò—â–µ–º –ø—É—Ç—å –≤ –∑–∞–ø—Ä–æ—Å–µ
        let words: Vec<&str> = query.split_whitespace().collect();
        
        for word in &words {
            if word.ends_with('/') || *word == "." || *word == ".." || word.starts_with("./") {
                args.insert("path".to_string(), word.to_string());
                break;
            }
        }
        
        // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ç–µ–∫—É—â–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
        if args.is_empty() {
            args.insert("path".to_string(), ".".to_string());
        }
        
        Ok(ToolInput {
            command: "dir_list".to_string(),
            args,
            context: Some(query.to_string()),
        })
    }
}