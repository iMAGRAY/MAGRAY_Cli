---
description: "ToolService: КРИТИЧЕСКИЙ БЛОКЕР - реализация базовых тулов"
globs: ["**/toolsvc/**/*.rs", "**/tools/**/*.rs"]
alwaysApply: true
---

## БЛОКЕР: НЕТ ни одного рабочего тула!

### Приоритет 1: Базовые тулы (proof of concept)
```rust
// Заменить заглушки в executor/src/lib.rs
pub struct FileReadTool;
impl Tool for FileReadTool {
    fn execute(&self, input: Value) -> Result<Value> {
        let path = input["path"].as_str()?;
        let content = std::fs::read_to_string(path)?;
        Ok(json!({ "content": content, "size": content.len() }))
    }
}

pub struct ShellExecTool;
impl Tool for ShellExecTool {
    fn execute(&self, input: Value) -> Result<Value> {
        let cmd = input["command"].as_str()?;
        let output = std::process::Command::new("sh")
            .arg("-c").arg(cmd).output()?;
        Ok(json!({
            "stdout": String::from_utf8_lossy(&output.stdout),
            "stderr": String::from_utf8_lossy(&output.stderr),
            "exit_code": output.status.code()
        }))
    }
}
```

### Приоритет 2: Tool Registry
```rust
pub struct ToolRegistry {
    tools: HashMap<String, Box<dyn Tool>>,
    specs: HashMap<String, ToolSpec>,
}

impl ToolRegistry {
    pub fn register<T: Tool + 'static>(&mut self, id: &str, tool: T, spec: ToolSpec) {
        self.tools.insert(id.to_string(), Box::new(tool));
        self.specs.insert(id.to_string(), spec);
    }
    
    pub fn invoke(&self, tool_id: &str, input: Value) -> Result<ToolResult> {
        let tool = self.tools.get(tool_id)?;
        let start = Instant::now();
        let result = tool.execute(input)?;
        Ok(ToolResult {
            data: result,
            latency: start.elapsed(),
            cost: self.calculate_cost(tool_id),
        })
    }
}
```

### Приоритет 3: Интеграция с Executor
```rust
// В executor/src/lib.rs - УБРАТЬ ЗАГЛУШКИ!
match node.tool.as_deref() {
    Some("file_read") => {
        let result = self.tool_registry.invoke("file_read", node.input.clone())?;
        // Сохранить в память M1/M2
        self.memory.store_result(&node.id, &result)?;
    },
    Some("think") => {
        // Интеграция с LLM сервисом
        let result = self.llm_service.think(&node.input)?;
        self.memory.store_result(&node.id, &result)?;
    }
}
```

## Тестирование (обязательно!)
```rust
#[test]
fn test_file_read_tool() {
    let tool = FileReadTool;
    let input = json!({"path": "test.txt"});
    let result = tool.execute(input).unwrap();
    assert!(result["content"].is_string());
}

#[test]
fn test_tool_registry_integration() {
    // Полный цикл: регистрация → вызов → результат
}
```

## Критерии готовности
- ✅ file_read, shell_exec, think тулы работают
- ✅ ToolRegistry регистрирует и вызывает тулы  
- ✅ Executor использует реальные тулы вместо заглушек
- ✅ Результаты сохраняются в память
- ✅ Покрытие тестами ≥80%

## Следующие тулы (после разблокировки)
- web_search (HTTP клиент)
- code_analyze (AST парсинг)
- db_query (SQL выполнение)
- vector_search (семантический поиск)
