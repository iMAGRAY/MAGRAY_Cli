warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:25:5
   |
25 |     async fn shutdown(&self) -> Result<(), crate::MagrayCoreError> {
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
   = note: `#[warn(async_fn_in_trait)]` on by default
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
25 ~     fn shutdown(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
26 |         Ok(())
27 ~     } }
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:36:5
   |
36 |     async fn update_config(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
36 -     async fn update_config(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
36 +     fn update_config(&mut self, config: T) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:64:5
   |
64 |     async fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> Result<R, E>
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
64 -     async fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> Result<R, E>
64 +     fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> impl std::future::Future<Output = Result<R, E>> + Send
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:83:5
   |
83 |     async fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> Result<R, E>
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
83 -     async fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> Result<R, E>
83 +     fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> impl std::future::Future<Output = Result<R, E>> + Send
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:117:5
    |
117 |     async fn initialize(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
117 -     async fn initialize(&mut self) -> Result<(), crate::MagrayCoreError>;
117 +     fn initialize(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:120:5
    |
120 |     async fn start(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
120 -     async fn start(&mut self) -> Result<(), crate::MagrayCoreError>;
120 +     fn start(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:123:5
    |
123 |     async fn pause(&mut self) -> Result<(), crate::MagrayCoreError> {
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
123 ~     fn pause(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
124 |         Ok(())
125 ~     } }
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:128:5
    |
128 |     async fn resume(&mut self) -> Result<(), crate::MagrayCoreError> {
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
128 ~     fn resume(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
129 |         Ok(())
130 ~     } }
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:133:5
    |
133 |     async fn stop(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
133 -     async fn stop(&mut self) -> Result<(), crate::MagrayCoreError>;
133 +     fn stop(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:156:5
    |
156 |     async fn register_service(&mut self, service: Arc<Self::Service>) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
156 -     async fn register_service(&mut self, service: Arc<Self::Service>) -> Result<(), crate::MagrayCoreError>;
156 +     fn register_service(&mut self, service: Arc<Self::Service>) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:159:5
    |
159 |     async fn unregister_service(&mut self, service_name: &str) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
159 -     async fn unregister_service(&mut self, service_name: &str) -> Result<(), crate::MagrayCoreError>;
159 +     fn unregister_service(&mut self, service_name: &str) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:191:5
    |
191 |     async fn get_connection(&self) -> Result<Self::Connection, Self::Error>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
191 -     async fn get_connection(&self) -> Result<Self::Connection, Self::Error>;
191 +     fn get_connection(&self) -> impl std::future::Future<Output = Result<Self::Connection, Self::Error>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:194:5
    |
194 |     async fn return_connection(&self, connection: Self::Connection) -> Result<(), Self::Error>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
194 -     async fn return_connection(&self, connection: Self::Connection) -> Result<(), Self::Error>;
194 +     fn return_connection(&self, connection: Self::Connection) -> impl std::future::Future<Output = Result<(), Self::Error>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:211:5
    |
211 |     async fn get(&self, key: &K) -> Option<V>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
211 -     async fn get(&self, key: &K) -> Option<V>;
211 +     fn get(&self, key: &K) -> impl std::future::Future<Output = Option<V>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:214:5
    |
214 |     async fn set(&self, key: K, value: V) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
214 -     async fn set(&self, key: K, value: V) -> Result<(), crate::MagrayCoreError>;
214 +     fn set(&self, key: K, value: V) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:217:5
    |
217 |     async fn remove(&self, key: &K) -> Result<bool, crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
217 -     async fn remove(&self, key: &K) -> Result<bool, crate::MagrayCoreError>;
217 +     fn remove(&self, key: &K) -> impl std::future::Future<Output = Result<bool, crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:220:5
    |
220 |     async fn clear(&self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
220 -     async fn clear(&self) -> Result<(), crate::MagrayCoreError>;
220 +     fn clear(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: `common` (lib) generated 17 warnings
    Checking memory v0.1.0 (C:\Users\1\Documents\GitHub\MAGRAY_Cli\crates\memory)
error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:375:9
    |
375 |         await manager.initialize_standard_coordinators().unwrap();
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
375 -         await manager.initialize_standard_coordinators().unwrap();
375 +         manager.initialize_standard_coordinators().unwrap().await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:378:9
    |
378 |         await manager.record_failure("search");
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
378 -         await manager.record_failure("search");
378 +         manager.record_failure("search").await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:379:9
    |
379 |         await manager.record_failure("embedding");
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
379 -         await manager.record_failure("embedding");
379 +         manager.record_failure("embedding").await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:382:9
    |
382 |         await manager.reset_all().unwrap();
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
382 -         await manager.reset_all().unwrap();
382 +         manager.reset_all().unwrap().await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:393:9
    |
393 |         await manager.add_component("fast", Some(CircuitBreakerConfig::fast())).unwrap();
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
393 -         await manager.add_component("fast", Some(CircuitBreakerConfig::fast())).unwrap();
393 +         manager.add_component("fast", Some(CircuitBreakerConfig::fast())).unwrap().await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:394:9
    |
394 |         await manager.add_component("critical", Some(CircuitBreakerConfig::critical())).unwrap();
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
394 -         await manager.add_component("critical", Some(CircuitBreakerConfig::critical())).unwrap();
394 +         manager.add_component("critical", Some(CircuitBreakerConfig::critical())).unwrap().await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:398:13
    |
398 |             await manager.record_failure("fast");
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
398 -             await manager.record_failure("fast");
398 +             manager.record_failure("fast").await;
    |

error: incorrect use of `await`
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:404:13
    |
404 |             await manager.record_failure("critical");
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
help: `await` is a postfix operation
    |
404 -             await manager.record_failure("critical");
404 +             manager.record_failure("critical").await;
    |

error[E0412]: cannot find type `CacheConfigBase` in this scope
  --> crates\memory\src\cache_lru.rs:26:15
   |
26 |     pub base: CacheConfigBase,
   |               ^^^^^^^^^^^^^^^ not found in this scope
   |
help: consider importing this struct
   |
1  + use common::CacheConfigBase;
   |

error[E0433]: failed to resolve: use of undeclared type `CacheConfigBase`
  --> crates\memory\src\cache_lru.rs:32:19
   |
32 |             base: CacheConfigBase::default(),
   |                   ^^^^^^^^^^^^^^^ use of undeclared type `CacheConfigBase`
   |
help: a struct with a similar name exists
   |
32 -             base: CacheConfigBase::default(),
32 +             base: CacheConfig::default(),
   |
help: consider importing this struct
   |
1  + use common::CacheConfigBase;
   |

error[E0405]: cannot find trait `ConfigTrait` in this scope
  --> crates\memory\src\cache_lru.rs:37:6
   |
37 | impl ConfigTrait for CacheConfig {
   |      ^^^^^^^^^^^ not found in this scope
   |
help: consider importing this trait
   |
1  + use common::ConfigTrait;
   |

error[E0422]: cannot find struct, variant or union type `CacheConfigBase` in this scope
  --> crates\memory\src\cache_lru.rs:40:19
   |
23 | pub struct CacheConfig {
   | ---------------------- similarly named struct `CacheConfig` defined here
...
40 |             base: CacheConfigBase {
   |                   ^^^^^^^^^^^^^^^
   |
help: a struct with a similar name exists
   |
40 -             base: CacheConfigBase {
40 +             base: CacheConfig {
   |
help: consider importing this struct
   |
1  + use common::CacheConfigBase;
   |

error[E0422]: cannot find struct, variant or union type `CacheConfigBase` in this scope
  --> crates\memory\src\cache_lru.rs:51:19
   |
23 | pub struct CacheConfig {
   | ---------------------- similarly named struct `CacheConfig` defined here
...
51 |             base: CacheConfigBase {
   |                   ^^^^^^^^^^^^^^^
   |
help: a struct with a similar name exists
   |
51 -             base: CacheConfigBase {
51 +             base: CacheConfig {
   |
help: consider importing this struct
   |
1  + use common::CacheConfigBase;
   |

error[E0603]: struct import `AlgorithmConfig` is private
   --> crates\memory\src\ml_promotion\coordinator.rs:11:43
    |
11  | use super::algorithms::{AlgorithmFactory, AlgorithmConfig};
    |                                           ^^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `AlgorithmConfig` is defined here...
   --> crates\memory\src\ml_promotion\algorithms.rs:8:58
    |
8   | use super::traits::{PromotionAlgorithm, TrainingExample, AlgorithmConfig};
    |                                                          ^^^^^^^^^^^^^^^
note: ...and refers to the struct `AlgorithmConfig` which is defined here
   --> crates\memory\src\ml_promotion\traits.rs:130:1
    |
130 | pub struct AlgorithmConfig {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: import `AlgorithmConfig` through the re-export
    |
11  | use super::algorithms::{AlgorithmFactory, traits::AlgorithmConfig};
    |                                           ++++++++

error[E0603]: struct import `AlgorithmConfig` is private
   --> crates\memory\src\ml_promotion\mod.rs:88:21
    |
88  |     use algorithms::AlgorithmConfig;
    |                     ^^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `AlgorithmConfig` is defined here...
   --> crates\memory\src\ml_promotion\algorithms.rs:8:58
    |
8   | use super::traits::{PromotionAlgorithm, TrainingExample, AlgorithmConfig};
    |                                                          ^^^^^^^^^^^^^^^
note: ...and refers to the struct `AlgorithmConfig` which is defined here
   --> crates\memory\src\ml_promotion\traits.rs:130:1
    |
130 | pub struct AlgorithmConfig {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: import `AlgorithmConfig` through the re-export
    |
88  -     use algorithms::AlgorithmConfig;
88  +     use traits::AlgorithmConfig;
    |

error[E0603]: struct import `AlgorithmConfig` is private
   --> crates\memory\src\ml_promotion\mod.rs:129:39
    |
129 |         let algo_config = algorithms::AlgorithmConfig {
    |                                       ^^^^^^^^^^^^^^^ private struct import
    |
note: the struct import `AlgorithmConfig` is defined here...
   --> crates\memory\src\ml_promotion\algorithms.rs:8:58
    |
8   | use super::traits::{PromotionAlgorithm, TrainingExample, AlgorithmConfig};
    |                                                          ^^^^^^^^^^^^^^^
note: ...and refers to the struct `AlgorithmConfig` which is defined here
   --> crates\memory\src\ml_promotion\traits.rs:130:1
    |
130 | pub struct AlgorithmConfig {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ you could import this directly
help: consider importing this struct instead
    |
129 -         let algo_config = algorithms::AlgorithmConfig {
129 +         let algo_config = crate::ml_promotion::traits::AlgorithmConfig {
    |
help: import `AlgorithmConfig` through the re-export
    |
129 -         let algo_config = algorithms::AlgorithmConfig {
129 +         let algo_config = traits::AlgorithmConfig {
    |

warning: unused imports: `Deserialize` and `Serialize`
 --> crates\memory\src\ml_promotion\algorithms.rs:4:13
  |
4 | use serde::{Deserialize, Serialize};
  |             ^^^^^^^^^^^  ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `MLPromotionConfig` and `SemanticContext`
  --> crates\memory\src\ml_promotion\data_processor.rs:13:54
   |
13 | use super::types::{PromotionFeatures, AccessPattern, SemanticContext, MLPromotionConfig};
   |                                                      ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^

warning: unused import: `TrainingExample`
 --> crates\memory\src\ml_promotion\coordinator.rs:8:80
  |
8 |     PromotionAlgorithm, PromotionMetrics, PromotionRulesEngine, DataProcessor, TrainingExample
  |                                                                                ^^^^^^^^^^^^^^^

warning: unused import: `DateTime`
 --> crates\memory\src\ml_promotion\legacy_facade.rs:5:14
  |
5 | use chrono::{DateTime, Utc};
  |              ^^^^^^^^

warning: unused import: `warn`
 --> crates\memory\src\ml_promotion\legacy_facade.rs:7:28
  |
7 | use tracing::{debug, info, warn};
  |                            ^^^^

warning: unused import: `RwLock`
  --> crates\memory\src\service_di\facade.rs:12:19
   |
12 | use tokio::sync::{RwLock, Semaphore};
   |                   ^^^^^^

warning: unused imports: `debug`, `error`, and `warn`
  --> crates\memory\src\service_di\facade.rs:13:15
   |
13 | use tracing::{debug, info, warn, error};
   |               ^^^^^        ^^^^  ^^^^^

warning: unused imports: `CircuitBreakerState`, `CoordinatorFactory`, `LifecycleState`, `MemoryServiceConfig`, and `ProductionMetrics`
  --> crates\memory\src\service_di\facade.rs:26:5
   |
26 |     MemoryServiceConfig, MemoryConfig,
   |     ^^^^^^^^^^^^^^^^^^^
27 |     MemorySystemStats,
28 |     CoordinatorFactory, OrchestrationCoordinators, ProductionCoordinatorFactory,
   |     ^^^^^^^^^^^^^^^^^^
29 |     ProductionMetrics, MetricsCollector as DIMetricsCollector,
   |     ^^^^^^^^^^^^^^^^^
30 |     CircuitBreaker, CircuitBreakerState,
   |                     ^^^^^^^^^^^^^^^^^^^
31 |     LifecycleManager as DILifecycleManager, LifecycleState,
   |                                             ^^^^^^^^^^^^^^

warning: unused import: `Duration`
 --> crates\memory\src\di\lifetime_manager.rs:6:12
  |
6 |     time::{Duration, Instant},
  |            ^^^^^^^^

warning: unused imports: `MetricsReporter` and `TypeMetrics`
  --> crates\memory\src\di\lifetime_manager.rs:11:48
   |
11 | use super::traits::{Lifetime, LifetimeManager, MetricsReporter, TypeMetrics};
   |                                                ^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused imports: `DIRegistrar`, `DIResolver`, `DependencyValidator`, `LifetimeManager`, `MetricsReporter`, `TypeMetrics`, `create_custom_container`, `create_default_container`, and `create_minimal_container`
  --> crates\memory\src\di_container.rs:19:55
   |
19 |     Lifetime, DIContainerStats, DIPerformanceMetrics, TypeMetrics,
   |                                                       ^^^^^^^^^^^
20 |     DIResolver, DIRegistrar, LifetimeManager, DependencyValidator, MetricsReporter,
   |     ^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
21 |     create_default_container, create_minimal_container, create_custom_container,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::di::container_builder::DIContainer as LegacyDIContainer`
  --> crates\memory\src\di_container.rs:25:9
   |
25 | pub use crate::di::container_builder::DIContainer as LegacyDIContainer;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::di::dependency_validator::DependencyGraph`
  --> crates\memory\src\di_container.rs:26:9
   |
26 | pub use crate::di::dependency_validator::DependencyGraph;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Duration`
 --> crates\memory\src\orchestration\metrics_collector.rs:4:12
  |
4 |     time::{Duration, Instant},
  |            ^^^^^^^^

error[E0782]: expected a type, found a trait
  --> crates\memory\src\service_di\facade.rs:49:18
   |
49 |     metrics: Arc<DIMetricsCollector>,
   |                  ^^^^^^^^^^^^^^^^^^
   |
help: you can add the `dyn` keyword if you want a trait object
   |
49 |     metrics: Arc<dyn DIMetricsCollector>,
   |                  +++

error[E0599]: no method named `async_flush` found for struct `BatchConfig` in the current scope
   --> crates\memory\src\batch_manager.rs:108:24
    |
15  | pub struct BatchConfig {
    | ---------------------- method `async_flush` not found for this struct
...
108 |         if self.config.async_flush() {
    |                        ^^^^^^^^^^^-- help: remove the arguments
    |                        |
    |                        field, not a method

error[E0599]: no method named `max_queue_size` found for struct `BatchConfig` in the current scope
   --> crates\memory\src\batch_manager.rs:109:69
    |
15  | pub struct BatchConfig {
    | ---------------------- method `max_queue_size` not found for this struct
...
109 |             let (tx, rx) = mpsc::channel::<RecordBatch>(self.config.max_queue_size());
    |                                                                     ^^^^^^^^^^^^^^-- help: remove the arguments
    |                                                                     |
    |                                                                     field, not a method

error[E0599]: no method named `async_flush` found for struct `BatchConfig` in the current scope
   --> crates\memory\src\batch_manager.rs:249:28
    |
15  | pub struct BatchConfig {
    | ---------------------- method `async_flush` not found for this struct
...
249 |             if self.config.async_flush() {
    |                            ^^^^^^^^^^^-- help: remove the arguments
    |                            |
    |                            field, not a method

error[E0599]: no method named `worker_threads` found for struct `BatchConfig` in the current scope
   --> crates\memory\src\batch_manager.rs:312:69
    |
15  | pub struct BatchConfig {
    | ---------------------- method `worker_threads` not found for this struct
...
312 |         let semaphore = Arc::new(tokio::sync::Semaphore::new(config.worker_threads()));
    |                                                                     ^^^^^^^^^^^^^^-- help: remove the arguments
    |                                                                     |
    |                                                                     field, not a method

error[E0308]: mismatched types
   --> crates\memory\src\ml_promotion\rules_engine.rs:491:21
    |
488 | /             match rule {
489 | |                 BusinessRule::MaxPromotionsPerHour(_max_per_hour) => {
490 | |                     // Заглушка для проверки rate limiting
491 | |                     true
    | |                     ^^^^ expected `()`, found `bool`
...   |
504 | |                 },
505 | |             }
    | |_____________- expected this to be `()`
    |
help: you might have meant to return this value
    |
491 |                     return true
    |                     ++++++

error[E0308]: mismatched types
   --> crates\memory\src\ml_promotion\rules_engine.rs:495:21
    |
488 | /             match rule {
489 | |                 BusinessRule::MaxPromotionsPerHour(_max_per_hour) => {
490 | |                     // Заглушка для проверки rate limiting
491 | |                     true
...   |
495 | |                     true
    | |                     ^^^^ expected `()`, found `bool`
...   |
504 | |                 },
505 | |             }
    | |_____________- expected this to be `()`
    |
help: you might have meant to return this value
    |
495 |                     return true
    |                     ++++++

error[E0308]: mismatched types
   --> crates\memory\src\ml_promotion\rules_engine.rs:499:21
    |
488 | /             match rule {
489 | |                 BusinessRule::MaxPromotionsPerHour(_max_per_hour) => {
490 | |                     // Заглушка для проверки rate limiting
491 | |                     true
...   |
499 | |                     !self.is_duplicate_content(&record.text)
    | |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found `bool`
...   |
504 | |                 },
505 | |             }
    | |_____________- expected this to be `()`
    |
help: consider using a semicolon here
    |
505 |             };
    |              +
help: you might have meant to return this value
    |
499 |                     return !self.is_duplicate_content(&record.text)
    |                     ++++++

error[E0308]: mismatched types
   --> crates\memory\src\ml_promotion\rules_engine.rs:503:21
    |
488 | /             match rule {
489 | |                 BusinessRule::MaxPromotionsPerHour(_max_per_hour) => {
490 | |                     // Заглушка для проверки rate limiting
491 | |                     true
...   |
503 | |                     true
    | |                     ^^^^ expected `()`, found `bool`
504 | |                 },
505 | |             }
    | |_____________- expected this to be `()`
    |
help: you might have meant to return this value
    |
503 |                     return true
    |                     ++++++

error[E0308]: mismatched types
   --> crates\memory\src\ml_promotion\coordinator.rs:256:44
    |
256 |         let stats = self.build_final_stats(promotion_results, processing_time);
    |                          ----------------- ^^^^^^^^^^^^^^^^^ expected `&PromotionResults`, found `PromotionResults`
    |                          |
    |                          arguments to this method are incorrect
    |
note: method defined here
   --> crates\memory\src\ml_promotion\coordinator.rs:441:8
    |
441 |     fn build_final_stats(&self, results: &PromotionResults, processing_time_ms: u64) -> MLPromotionStats {
    |        ^^^^^^^^^^^^^^^^^        --------------------------
help: consider borrowing here
    |
256 |         let stats = self.build_final_stats(&promotion_results, processing_time);
    |                                            +

error[E0382]: borrow of moved value: `decisions`
    --> crates\memory\src\ml_promotion\coordinator.rs:343:59
     |
322  |     async fn execute_promotions(&mut self, decisions: Vec<PromotionDecision>) -> Result<PromotionResults> {
     |                                            --------- move occurs because `decisions` has type `Vec<PromotionDecision>`, which does not implement the `Copy` trait
...
342  |             decisions,
     |             --------- value moved here
343  |             avg_confidence: self.calculate_avg_confidence(&decisions),
     |                                                           ^^^^^^^^^^ value borrowed here after move
     |
     = note: borrow occurs due to deref coercion to `[PromotionDecision]`
note: deref defined here
    --> C:\Users\1\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\alloc\src\vec\mod.rs:3396:5
     |
3396 |     type Target = [T];
     |     ^^^^^^^^^^^
help: consider cloning the value if the performance cost is acceptable
     |
342  |             decisions: decisions.clone(),
     |                      +++++++++++++++++++

error[E0599]: no method named `check_health` found for reference `&Arc<HealthManager>` in the current scope
   --> crates\memory\src\service_di\coordinator_factory.rs:230:28
    |
230 |             health_manager.check_health().await
    |                            ^^^^^^^^^^^^ method not found in `&Arc<HealthManager>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `MonitoringServiceTrait` defines an item `check_health`, perhaps you need to implement it
   --> crates\memory\src\services\traits.rs:110:1
    |
110 | pub trait MonitoringServiceTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_cache_stats` found for reference `&Arc<embedding_coordinator::EmbeddingCoordinator>` in the current scope
   --> crates\memory\src\service_di\coordinator_factory.rs:245:48
    |
245 |             if let Ok(stats) = embedding_coord.get_cache_stats().await {
    |                                                ^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `CacheServiceTrait` defines an item `get_cache_stats`, perhaps you need to implement it
   --> crates\memory\src\services\traits.rs:139:1
    |
139 | pub trait CacheServiceTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `cache_stats` with a similar name
    |
245 -             if let Ok(stats) = embedding_coord.get_cache_stats().await {
245 +             if let Ok(stats) = embedding_coord.cache_stats().await {
    |

error[E0599]: no method named `get_stats` found for reference `&Arc<search_coordinator::SearchCoordinator>` in the current scope
   --> crates\memory\src\service_di\coordinator_factory.rs:254:45
    |
254 |             if let Ok(stats) = search_coord.get_stats().await {
    |                                             ^^^^^^^^^ method not found in `&Arc<search_coordinator::SearchCoordinator>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_stats`, perhaps you need to implement one of them:
            candidate #1: `MetricsReporter`
            candidate #2: `PromotionMetrics`

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> crates\memory\src\service_di\coordinator_factory.rs:350:25
    |
350 |         let container = crate::di_container::DIContainer::new();
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `ContainerCore` is missing
    |
note: associated function defined here
   --> crates\memory\src\di\container_builder.rs:134:19
    |
134 |     pub(crate) fn new(core: ContainerCore) -> Self {
    |                   ^^^ -------------------
help: provide the argument
    |
350 |         let container = crate::di_container::DIContainer::new(/* ContainerCore */);
    |                                                               +++++++++++++++++++

error[E0599]: no method named `clone` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:68:79
    |
68  |         let coordinator_factory = ProductionCoordinatorFactory::new(container.clone());
    |                                                                               ^^^^^ method not found in `DIContainer`
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `clone` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> crates\memory\src\service_di\facade.rs:68:35
    |
68  |         let coordinator_factory = ProductionCoordinatorFactory::new(container.clone());
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ----------------- unexpected argument
    |
note: associated function defined here
   --> crates\memory\src\service_di\coordinator_factory.rs:284:12
    |
284 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
68  -         let coordinator_factory = ProductionCoordinatorFactory::new(container.clone());
68  +         let coordinator_factory = ProductionCoordinatorFactory::new();
    |

error[E0782]: expected a type, found a trait
  --> crates\memory\src\service_di\facade.rs:71:32
   |
71 |         let metrics = Arc::new(DIMetricsCollector::new_production());
   |                                ^^^^^^^^^^^^^^^^^^
   |
help: you can add the `dyn` keyword if you want a trait object
   |
71 |         let metrics = Arc::new(<dyn DIMetricsCollector>::new_production());
   |                                ++++                   +

error[E0599]: no function or associated item named `new_production` found for struct `circuit_breaker::CircuitBreaker` in the current scope
   --> crates\memory\src\service_di\facade.rs:72:56
    |
72  |         let circuit_breaker = Arc::new(CircuitBreaker::new_production());
    |                                                        ^^^^^^^^^^^^^^ function or associated item not found in `circuit_breaker::CircuitBreaker`
    |
   ::: crates\memory\src\service_di\circuit_breaker.rs:118:1
    |
118 | pub struct CircuitBreaker {
    | ------------------------- function or associated item `new_production` not found for this struct
    |
note: if you're trying to build a new `circuit_breaker::CircuitBreaker` consider using one of the following associated functions:
      circuit_breaker::CircuitBreaker::new
      circuit_breaker::CircuitBreaker::with_production_config
      circuit_breaker::CircuitBreaker::with_minimal_config
   --> crates\memory\src\service_di\circuit_breaker.rs:126:5
    |
126 |     pub fn new(config: CircuitBreakerConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
144 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
148 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `new_production` found for struct `lifecycle_manager::LifecycleManager` in the current scope
   --> crates\memory\src\service_di\facade.rs:73:62
    |
73  |         let lifecycle_manager = Arc::new(DILifecycleManager::new_production());
    |                                                              ^^^^^^^^^^^^^^ function or associated item not found in `lifecycle_manager::LifecycleManager`
    |
   ::: crates\memory\src\service_di\lifecycle_manager.rs:105:1
    |
105 | pub struct LifecycleManager {
    | --------------------------- function or associated item `new_production` not found for this struct
    |
note: if you're trying to build a new `lifecycle_manager::LifecycleManager` consider using one of the following associated functions:
      lifecycle_manager::LifecycleManager::new
      lifecycle_manager::LifecycleManager::with_production_config
      lifecycle_manager::LifecycleManager::with_minimal_config
   --> crates\memory\src\service_di\lifecycle_manager.rs:123:5
    |
123 |     pub fn new(config: LifecycleConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
135 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
139 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `clone` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:78:27
    |
78  |                 container.clone(),
    |                           ^^^^^ method not found in `DIContainer`
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `clone` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0782]: expected a type, found a trait
   --> crates\memory\src\service_di\facade.rs:107:32
    |
107 |         let metrics = Arc::new(DIMetricsCollector::new_minimal());
    |                                ^^^^^^^^^^^^^^^^^^
    |
help: you can add the `dyn` keyword if you want a trait object
    |
107 |         let metrics = Arc::new(<dyn DIMetricsCollector>::new_minimal());
    |                                ++++                   +

error[E0599]: no function or associated item named `new_minimal` found for struct `circuit_breaker::CircuitBreaker` in the current scope
   --> crates\memory\src\service_di\facade.rs:108:56
    |
108 |         let circuit_breaker = Arc::new(CircuitBreaker::new_minimal());
    |                                                        ^^^^^^^^^^^ function or associated item not found in `circuit_breaker::CircuitBreaker`
    |
   ::: crates\memory\src\service_di\circuit_breaker.rs:118:1
    |
118 | pub struct CircuitBreaker {
    | ------------------------- function or associated item `new_minimal` not found for this struct
    |
note: if you're trying to build a new `circuit_breaker::CircuitBreaker` consider using one of the following associated functions:
      circuit_breaker::CircuitBreaker::new
      circuit_breaker::CircuitBreaker::with_production_config
      circuit_breaker::CircuitBreaker::with_minimal_config
   --> crates\memory\src\service_di\circuit_breaker.rs:126:5
    |
126 |     pub fn new(config: CircuitBreakerConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
144 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
148 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `new_minimal` found for struct `lifecycle_manager::LifecycleManager` in the current scope
   --> crates\memory\src\service_di\facade.rs:109:62
    |
109 |         let lifecycle_manager = Arc::new(DILifecycleManager::new_minimal());
    |                                                              ^^^^^^^^^^^ function or associated item not found in `lifecycle_manager::LifecycleManager`
    |
   ::: crates\memory\src\service_di\lifecycle_manager.rs:105:1
    |
105 | pub struct LifecycleManager {
    | --------------------------- function or associated item `new_minimal` not found for this struct
    |
note: if you're trying to build a new `lifecycle_manager::LifecycleManager` consider using one of the following associated functions:
      lifecycle_manager::LifecycleManager::new
      lifecycle_manager::LifecycleManager::with_production_config
      lifecycle_manager::LifecycleManager::with_minimal_config
   --> crates\memory\src\service_di\lifecycle_manager.rs:123:5
    |
123 |     pub fn new(config: LifecycleConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
135 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
139 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `clone` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:114:27
    |
114 |                 container.clone(),
    |                           ^^^^^ method not found in `DIContainer`
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `clone` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> crates\memory\src\service_di\facade.rs:135:32
    |
135 |         self.lifecycle_manager.initialize().await?;
    |                                ^^^^^^^^^^-- argument #1 is missing
    |
note: method defined here
   --> crates\memory\src\service_di\lifecycle_manager.rs:144:18
    |
144 |     pub async fn initialize<F, Fut>(&self, init_fn: F) -> Result<()>
    |                  ^^^^^^^^^^                ----------
help: provide the argument
    |
135 |         self.lifecycle_manager.initialize(/* init_fn */).await?;
    |                                           +++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> crates\memory\src\service_di\facade.rs:320:32
    |
320 |         self.lifecycle_manager.shutdown().await?;
    |                                ^^^^^^^^-- argument #1 is missing
    |
note: method defined here
   --> crates\memory\src\service_di\lifecycle_manager.rs:241:18
    |
241 |     pub async fn shutdown<F, Fut>(&self, shutdown_fn: F) -> Result<()>
    |                  ^^^^^^^^                --------------
help: provide the argument
    |
320 |         self.lifecycle_manager.shutdown(/* shutdown_fn */).await?;
    |                                         +++++++++++++++++

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> crates\memory\src\di_memory_config.rs:208:35
    |
208 |         let memory_orchestrator = MemoryOrchestrator::from_container(container.core())?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
    |
    = help: the trait `Try` is not implemented for `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
help: consider `await`ing on the `Future`
    |
208 |         let memory_orchestrator = MemoryOrchestrator::from_container(container.core()).await?;
    |                                                                                       ++++++

error[E0615]: attempted to take value of method `max_entries` on type `CacheConfig`
   --> crates\memory\src\di_memory_config.rs:314:38
    |
314 |                   cache_config_clone.max_entries, 
    |                                      ^^^^^^^^^^^ method, not a field
    |
help: use parentheses to call the method
    |
314 |                   cache_config_clone.max_entries(), 
    |                                                 ++

error[E0615]: attempted to take value of method `ttl_seconds` on type `CacheConfig`
   --> crates\memory\src\di_memory_config.rs:315:38
    |
315 |                   cache_config_clone.ttl_seconds.unwrap_or(3600));
    |                                      ^^^^^^^^^^^ method, not a field
    |
help: use parentheses to call the method
    |
315 |                   cache_config_clone.ttl_seconds().unwrap_or(3600));
    |                                                 ++

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> crates\memory\src\di_memory_config.rs:493:29
    |
493 |                 Ok(Arc::new(MemoryOrchestrator::from_container(container)?))
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
    |
    = help: the trait `Try` is not implemented for `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
note: this implements `Future` and its output type supports `?`, but the future cannot be awaited in a synchronous function
   --> crates\memory\src\di_memory_config.rs:493:74
    |
491 |             .register_singleton(|container| {
    |                                 ----------- this is not `async`
492 |                 info!("Создание MemoryOrchestrator");
493 |                 Ok(Arc::new(MemoryOrchestrator::from_container(container)?))
    |                                                                          ^

error[E0521]: borrowed data escapes outside of method
   --> crates\memory\src\orchestration\orchestration_lifecycle_manager.rs:174:24
    |
162 |           coordinators: Vec<(&'static str, &dyn Coordinator)>,
    |           ------------                     - let's call the lifetime of this reference `'1`
    |           |
    |           `coordinators` declared here, outside of the method body
    |           `coordinators` is a reference that is only valid in the method body
...
174 |               let task = tokio::spawn(async move {
    |  ________________________^
175 | |                 let result = timeout(timeout_duration, coordinator.initialize()).await;
176 | |                 let duration = init_start.elapsed();
...   |
207 | |             });
    | |              ^
    | |              |
    | |______________`coordinators` escapes the method body here
    |                argument requires that `'1` must outlive `'static`

error[E0599]: no method named `run_health_check` found for struct `Arc<HealthManager>` in the current scope
   --> crates\memory\src\orchestration\orchestration_lifecycle_manager.rs:264:44
    |
264 |                     if let Err(e) = health.run_health_check().await {
    |                                            ^^^^^^^^^^^^^^^^ method not found in `Arc<HealthManager>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `HealthCoordinator` which provides `run_health_check` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::HealthCoordinator;
    |

error[E0599]: no method named `check_resources` found for struct `Arc<ResourceController>` in the current scope
   --> crates\memory\src\orchestration\operation_executor.rs:169:41
    |
169 |         if !self.coordinators.resources.check_resources(resource_type).await? {
    |                                         ^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `free_resources` with a similar name, but with different arguments
   --> crates\memory\src\orchestration\traits.rs:134:5
    |
134 |     async fn free_resources(&self) -> Result<()>;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `ResourceCoordinator` which provides `check_resources` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::ResourceCoordinator;
    |

error[E0599]: no method named `adapt_limits` found for struct `Arc<ResourceController>` in the current scope
   --> crates\memory\src\orchestration\operation_executor.rs:171:57
    |
171 |             if let Err(e) = self.coordinators.resources.adapt_limits().await {
    |                                                         ^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ResourceCoordinator` which provides `adapt_limits` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::ResourceCoordinator;
    |
help: there is a method `get_limits` with a similar name
    |
171 -             if let Err(e) = self.coordinators.resources.adapt_limits().await {
171 +             if let Err(e) = self.coordinators.resources.get_limits().await {
    |

error[E0599]: no method named `metrics` found for struct `Arc<embedding_coordinator::EmbeddingCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:190:41
    |
190 |             self.coordinators.embedding.metrics(),
    |                                         ^^^^^^^ method not found in `Arc<embedding_coordinator::EmbeddingCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `metrics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `metrics` found for struct `Arc<search_coordinator::SearchCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:191:38
    |
191 |             self.coordinators.search.metrics(),
    |                                      ^^^^^^^ method not found in `Arc<search_coordinator::SearchCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `metrics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `metrics` found for struct `Arc<HealthManager>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:192:38
    |
192 |             self.coordinators.health.metrics(),
    |                                      ^^^^^^^ method not found in `Arc<HealthManager>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `metrics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `metrics` found for struct `Arc<promotion_coordinator::PromotionCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:193:41
    |
193 |             self.coordinators.promotion.metrics(),
    |                                         ^^^^^^^ method not found in `Arc<promotion_coordinator::PromotionCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `metrics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `metrics` found for struct `Arc<ResourceController>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:194:41
    |
194 |             self.coordinators.resources.metrics(),
    |                                         ^^^^^^^ method not found in `Arc<ResourceController>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `metrics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `metrics` found for struct `Arc<backup_coordinator::BackupCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:195:38
    |
195 |             self.coordinators.backup.metrics()
    |                                      ^^^^^^^ method not found in `Arc<backup_coordinator::BackupCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `metrics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0282]: type annotations needed
   --> crates\memory\src\orchestration\metrics_collector.rs:189:23
    |
189 |           let results = tokio::join!(
    |  _______________________^
190 | |             self.coordinators.embedding.metrics(),
191 | |             self.coordinators.search.metrics(),
192 | |             self.coordinators.health.metrics(),
...   |
195 | |             self.coordinators.backup.metrics()
196 | |         );
    | |_________^ cannot infer type
    |
    = note: this error originates in the macro `$crate::join` which comes from the expansion of the macro `tokio::join` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `is_ready` found for struct `Arc<embedding_coordinator::EmbeddingCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:212:41
    |
212 |             self.coordinators.embedding.is_ready(),
    |                                         ^^^^^^^^ method not found in `Arc<embedding_coordinator::EmbeddingCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `is_ready` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `is_ready` found for struct `Arc<search_coordinator::SearchCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:213:38
    |
213 |             self.coordinators.search.is_ready(),
    |                                      ^^^^^^^^ method not found in `Arc<search_coordinator::SearchCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `is_ready` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `is_ready` found for struct `Arc<HealthManager>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:214:38
    |
214 |             self.coordinators.health.is_ready(),
    |                                      ^^^^^^^^ method not found in `Arc<HealthManager>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `is_ready` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `is_ready` found for struct `Arc<promotion_coordinator::PromotionCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:215:41
    |
215 |             self.coordinators.promotion.is_ready(),
    |                                         ^^^^^^^^ method not found in `Arc<promotion_coordinator::PromotionCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `is_ready` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `is_ready` found for struct `Arc<ResourceController>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:216:41
    |
216 |             self.coordinators.resources.is_ready(),
    |                                         ^^^^^^^^ method not found in `Arc<ResourceController>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `is_ready` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `is_ready` found for struct `Arc<backup_coordinator::BackupCoordinator>` in the current scope
   --> crates\memory\src\orchestration\metrics_collector.rs:217:38
    |
217 |             self.coordinators.backup.is_ready()
    |                                      ^^^^^^^^ method not found in `Arc<backup_coordinator::BackupCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `is_ready` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::Coordinator;
    |

error[E0282]: type annotations needed
   --> crates\memory\src\orchestration\metrics_collector.rs:211:23
    |
211 |           let results = tokio::join!(
    |  _______________________^
212 | |             self.coordinators.embedding.is_ready(),
213 | |             self.coordinators.search.is_ready(),
214 | |             self.coordinators.health.is_ready(),
...   |
217 | |             self.coordinators.backup.is_ready()
218 | |         );
    | |_________^ cannot infer type
    |
    = note: this error originates in the macro `$crate::join` which comes from the expansion of the macro `tokio::join` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0599]: no method named `reset_all` found for struct `Arc<CircuitBreakerManager>` in the current scope
   --> crates\memory\src\orchestration\orchestration_facade.rs:173:38
    |
173 |         self.circuit_breaker_manager.reset_all().await
    |                                      ^^^^^^^^^ method not found in `Arc<CircuitBreakerManager>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `CircuitBreakerManagerTrait` which provides `reset_all` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::circuit_breaker_manager::CircuitBreakerManagerTrait;
    |

error[E0599]: no method named `get_statistics` found for struct `Arc<CircuitBreakerManager>` in the current scope
   --> crates\memory\src\orchestration\orchestration_facade.rs:178:50
    |
178 |         let stats = self.circuit_breaker_manager.get_statistics().await;
    |                                                  ^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `get_status` with a similar name, but with different arguments
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:71:5
    |
71  |     async fn get_status(&self, component: &str) -> Option<CircuitBreakerStatus>;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `CircuitBreakerManagerTrait` which provides `get_statistics` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::circuit_breaker_manager::CircuitBreakerManagerTrait;
    |

error[E0046]: not all trait items implemented, missing: `initialize`, `shutdown`, `flush_all`, `run_promotion`, `create_backup`
   --> crates\memory\src\service_di\operation_executor.rs:698:1
    |
95  |     async fn initialize(&self) -> Result<()>;
    |     ----------------------------------------- `initialize` from trait
...
98  |     async fn shutdown(&self) -> Result<()>;
    |     --------------------------------------- `shutdown` from trait
...
109 |     async fn flush_all(&self) -> Result<()>;
    |     ---------------------------------------- `flush_all` from trait
110 |     async fn run_promotion(&self) -> Result<crate::promotion::PromotionStats>;
    |     -------------------------------------------------------------------------- `run_promotion` from trait
111 |     async fn create_backup(&self, path: &str) -> Result<crate::backup::BackupMetadata>;
    |     ----------------------------------------------------------------------------------- `create_backup` from trait
...
698 | impl OperationExecutor for ExtendedOperationExecutor {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `initialize`, `shutdown`, `flush_all`, `run_promotion`, `create_backup` in implementation

error[E0195]: lifetime parameters or bounds on method `can_execute` do not match the trait declaration
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:249:14
    |
62  |     async fn can_execute(&self, component: &str) -> bool;
    |                         - lifetimes in impl do not match this method in trait
...
247 | #[async_trait::async_trait]
    | --------------------------- this `where` clause might not match the one in the trait
248 | impl CircuitBreakerManagerTrait for CircuitBreakerManager {
249 |     async fn can_execute(&self, component: &str) -> bool {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait

error[E0195]: lifetime parameters or bounds on method `record_success` do not match the trait declaration
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:262:14
    |
65  |     async fn record_success(&self, component: &str);
    |                            - lifetimes in impl do not match this method in trait
...
247 | #[async_trait::async_trait]
    | --------------------------- this `where` clause might not match the one in the trait
...
262 |     async fn record_success(&self, component: &str) {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait

error[E0195]: lifetime parameters or bounds on method `record_failure` do not match the trait declaration
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:272:14
    |
68  |     async fn record_failure(&self, component: &str);
    |                            - lifetimes in impl do not match this method in trait
...
247 | #[async_trait::async_trait]
    | --------------------------- this `where` clause might not match the one in the trait
...
272 |     async fn record_failure(&self, component: &str) {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait

error[E0195]: lifetime parameters or bounds on method `get_status` do not match the trait declaration
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:282:14
    |
71  |     async fn get_status(&self, component: &str) -> Option<CircuitBreakerStatus>;
    |                        - lifetimes in impl do not match this method in trait
...
247 | #[async_trait::async_trait]
    | --------------------------- this `where` clause might not match the one in the trait
...
282 |     async fn get_status(&self, component: &str) -> Option<CircuitBreakerStatus> {
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait

error[E0195]: lifetime parameters or bounds on method `reset_all` do not match the trait declaration
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:287:14
    |
74  |     async fn reset_all(&self) -> Result<()>;
    |                       - lifetimes in impl do not match this method in trait
...
247 | #[async_trait::async_trait]
    | --------------------------- this `where` clause might not match the one in the trait
...
287 |     async fn reset_all(&self) -> Result<()> {
    |              ^^^^^^^^^^^^^^^^ lifetimes do not match method in trait

error[E0195]: lifetime parameters or bounds on method `get_statistics` do not match the trait declaration
   --> crates\memory\src\orchestration\circuit_breaker_manager.rs:300:14
    |
77  |     async fn get_statistics(&self) -> HashMap<String, CircuitBreakerStatistics>;
    |                            - lifetimes in impl do not match this method in trait
...
247 | #[async_trait::async_trait]
    | --------------------------- this `where` clause might not match the one in the trait
...
300 |     async fn get_statistics(&self) -> HashMap<String, CircuitBreakerStatistics> {
    |              ^^^^^^^^^^^^^^^^^^^^^ lifetimes do not match method in trait

Some errors have detailed explanations: E0046, E0061, E0195, E0277, E0282, E0308, E0382, E0405, E0412...
For more information about an error, try `rustc --explain E0046`.
warning: `memory` (lib) generated 14 warnings
error: could not compile `memory` (lib) due to 76 previous errors; 14 warnings emitted
