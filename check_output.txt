warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:25:5
   |
25 |     async fn shutdown(&self) -> Result<(), crate::MagrayCoreError> {
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
   = note: `#[warn(async_fn_in_trait)]` on by default
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
25 ~     fn shutdown(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
26 |         Ok(())
27 ~     } }
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:36:5
   |
36 |     async fn update_config(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
36 -     async fn update_config(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
36 +     fn update_config(&mut self, config: T) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:64:5
   |
64 |     async fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> Result<R, E>
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
64 -     async fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> Result<R, E>
64 +     fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> impl std::future::Future<Output = Result<R, E>> + Send
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:83:5
   |
83 |     async fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> Result<R, E>
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
83 -     async fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> Result<R, E>
83 +     fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> impl std::future::Future<Output = Result<R, E>> + Send
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:117:5
    |
117 |     async fn initialize(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
117 -     async fn initialize(&mut self) -> Result<(), crate::MagrayCoreError>;
117 +     fn initialize(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:120:5
    |
120 |     async fn start(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
120 -     async fn start(&mut self) -> Result<(), crate::MagrayCoreError>;
120 +     fn start(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:123:5
    |
123 |     async fn pause(&mut self) -> Result<(), crate::MagrayCoreError> {
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
123 ~     fn pause(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
124 |         Ok(())
125 ~     } }
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:128:5
    |
128 |     async fn resume(&mut self) -> Result<(), crate::MagrayCoreError> {
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
128 ~     fn resume(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
129 |         Ok(())
130 ~     } }
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:133:5
    |
133 |     async fn stop(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
133 -     async fn stop(&mut self) -> Result<(), crate::MagrayCoreError>;
133 +     fn stop(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:156:5
    |
156 |     async fn register_service(&mut self, service: Arc<Self::Service>) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
156 -     async fn register_service(&mut self, service: Arc<Self::Service>) -> Result<(), crate::MagrayCoreError>;
156 +     fn register_service(&mut self, service: Arc<Self::Service>) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:159:5
    |
159 |     async fn unregister_service(&mut self, service_name: &str) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
159 -     async fn unregister_service(&mut self, service_name: &str) -> Result<(), crate::MagrayCoreError>;
159 +     fn unregister_service(&mut self, service_name: &str) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:191:5
    |
191 |     async fn get_connection(&self) -> Result<Self::Connection, Self::Error>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
191 -     async fn get_connection(&self) -> Result<Self::Connection, Self::Error>;
191 +     fn get_connection(&self) -> impl std::future::Future<Output = Result<Self::Connection, Self::Error>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:194:5
    |
194 |     async fn return_connection(&self, connection: Self::Connection) -> Result<(), Self::Error>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
194 -     async fn return_connection(&self, connection: Self::Connection) -> Result<(), Self::Error>;
194 +     fn return_connection(&self, connection: Self::Connection) -> impl std::future::Future<Output = Result<(), Self::Error>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:211:5
    |
211 |     async fn get(&self, key: &K) -> Option<V>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
211 -     async fn get(&self, key: &K) -> Option<V>;
211 +     fn get(&self, key: &K) -> impl std::future::Future<Output = Option<V>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:214:5
    |
214 |     async fn set(&self, key: K, value: V) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
214 -     async fn set(&self, key: K, value: V) -> Result<(), crate::MagrayCoreError>;
214 +     fn set(&self, key: K, value: V) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:217:5
    |
217 |     async fn remove(&self, key: &K) -> Result<bool, crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
217 -     async fn remove(&self, key: &K) -> Result<bool, crate::MagrayCoreError>;
217 +     fn remove(&self, key: &K) -> impl std::future::Future<Output = Result<bool, crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:220:5
    |
220 |     async fn clear(&self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
220 -     async fn clear(&self) -> Result<(), crate::MagrayCoreError>;
220 +     fn clear(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: `common` (lib) generated 17 warnings
    Checking memory v0.1.0 (C:\Users\1\Documents\GitHub\MAGRAY_Cli\crates\memory)
error: expected expression, found `}`
   --> crates\memory\src\orchestration\operation_executor.rs:289:9
    |
289 |         };
    |         ^ expected expression

error: unexpected end of input, expected an expression
   --> crates\memory\src\orchestration\operation_executor.rs:289:9
    |
289 |         };
    |         ^

warning: unused imports: `Deserialize` and `Serialize`
 --> crates\memory\src\ml_promotion\algorithms.rs:4:13
  |
4 | use serde::{Deserialize, Serialize};
  |             ^^^^^^^^^^^  ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused imports: `MLPromotionConfig` and `SemanticContext`
  --> crates\memory\src\ml_promotion\data_processor.rs:13:54
   |
13 | use super::types::{PromotionFeatures, AccessPattern, SemanticContext, MLPromotionConfig};
   |                                                      ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^

warning: unused import: `TrainingExample`
 --> crates\memory\src\ml_promotion\coordinator.rs:8:80
  |
8 |     PromotionAlgorithm, PromotionMetrics, PromotionRulesEngine, DataProcessor, TrainingExample
  |                                                                                ^^^^^^^^^^^^^^^

warning: unused import: `DateTime`
 --> crates\memory\src\ml_promotion\legacy_facade.rs:5:14
  |
5 | use chrono::{DateTime, Utc};
  |              ^^^^^^^^

warning: unused import: `warn`
 --> crates\memory\src\ml_promotion\legacy_facade.rs:7:28
  |
7 | use tracing::{debug, info, warn};
  |                            ^^^^

warning: unused import: `RwLock`
  --> crates\memory\src\service_di\facade.rs:12:19
   |
12 | use tokio::sync::{RwLock, Semaphore};
   |                   ^^^^^^

warning: unused imports: `debug`, `error`, and `warn`
  --> crates\memory\src\service_di\facade.rs:13:15
   |
13 | use tracing::{debug, info, warn, error};
   |               ^^^^^        ^^^^  ^^^^^

warning: unused imports: `CircuitBreakerState`, `CoordinatorFactory`, `LifecycleState`, `MemoryServiceConfig`, and `ProductionMetrics`
  --> crates\memory\src\service_di\facade.rs:26:5
   |
26 |     MemoryServiceConfig, MemoryConfig,
   |     ^^^^^^^^^^^^^^^^^^^
27 |     MemorySystemStats,
28 |     CoordinatorFactory, OrchestrationCoordinators, ProductionCoordinatorFactory,
   |     ^^^^^^^^^^^^^^^^^^
29 |     ProductionMetrics, MetricsCollector as DIMetricsCollector,
   |     ^^^^^^^^^^^^^^^^^
30 |     CircuitBreaker, CircuitBreakerState,
   |                     ^^^^^^^^^^^^^^^^^^^
31 |     LifecycleManager as DILifecycleManager, LifecycleState,
   |                                             ^^^^^^^^^^^^^^

warning: unused import: `Duration`
 --> crates\memory\src\di\lifetime_manager.rs:6:12
  |
6 |     time::{Duration, Instant},
  |            ^^^^^^^^

warning: unused imports: `MetricsReporter` and `TypeMetrics`
  --> crates\memory\src\di\lifetime_manager.rs:11:48
   |
11 | use super::traits::{Lifetime, LifetimeManager, MetricsReporter, TypeMetrics};
   |                                                ^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused imports: `DIRegistrar`, `DIResolver`, `DependencyValidator`, `LifetimeManager`, `MetricsReporter`, `TypeMetrics`, `create_custom_container`, `create_default_container`, and `create_minimal_container`
  --> crates\memory\src\di_container.rs:19:55
   |
19 |     Lifetime, DIContainerStats, DIPerformanceMetrics, TypeMetrics,
   |                                                       ^^^^^^^^^^^
20 |     DIResolver, DIRegistrar, LifetimeManager, DependencyValidator, MetricsReporter,
   |     ^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^
21 |     create_default_container, create_minimal_container, create_custom_container,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::di::container_builder::DIContainer as LegacyDIContainer`
  --> crates\memory\src\di_container.rs:25:9
   |
25 | pub use crate::di::container_builder::DIContainer as LegacyDIContainer;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::di::dependency_validator::DependencyGraph`
  --> crates\memory\src\di_container.rs:26:9
   |
26 | pub use crate::di::dependency_validator::DependencyGraph;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `async_trait::async_trait`
 --> crates\memory\src\orchestration\circuit_breaker_manager.rs:2:5
  |
2 | use async_trait::async_trait;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `BackupCoordinator as BackupCoordinatorTrait`, `EmbeddingCoordinator as EmbeddingCoordinatorTrait`, and `PromotionCoordinator as PromotionCoordinatorTrait`
  --> crates\memory\src\orchestration\operation_executor.rs:17:13
   |
17 |             EmbeddingCoordinator as EmbeddingCoordinatorTrait,  
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
18 |             PromotionCoordinator as PromotionCoordinatorTrait,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
19 |             BackupCoordinator as BackupCoordinatorTrait,
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Duration`
 --> crates\memory\src\orchestration\metrics_collector.rs:4:12
  |
4 |     time::{Duration, Instant},
  |            ^^^^^^^^

warning: variable does not need to be mutable
   --> crates\memory\src\ml_promotion\coordinator.rs:111:24
    |
111 |     pub async fn build(mut self) -> Result<PromotionCoordinator> {
    |                        ----^^^^
    |                        |
    |                        help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

error[E0308]: mismatched types
   --> crates\memory\src\ml_promotion\coordinator.rs:257:44
    |
257 |         let stats = self.build_final_stats(promotion_results, processing_time);
    |                          ----------------- ^^^^^^^^^^^^^^^^^ expected `&PromotionResults`, found `PromotionResults`
    |                          |
    |                          arguments to this method are incorrect
    |
note: method defined here
   --> crates\memory\src\ml_promotion\coordinator.rs:442:8
    |
442 |     fn build_final_stats(&self, results: &PromotionResults, processing_time_ms: u64) -> MLPromotionStats {
    |        ^^^^^^^^^^^^^^^^^        --------------------------
help: consider borrowing here
    |
257 |         let stats = self.build_final_stats(&promotion_results, processing_time);
    |                                            +

error[E0382]: borrow of moved value: `decisions`
    --> crates\memory\src\ml_promotion\coordinator.rs:344:59
     |
323  |     async fn execute_promotions(&mut self, decisions: Vec<PromotionDecision>) -> Result<PromotionResults> {
     |                                            --------- move occurs because `decisions` has type `Vec<PromotionDecision>`, which does not implement the `Copy` trait
...
343  |             decisions,
     |             --------- value moved here
344  |             avg_confidence: self.calculate_avg_confidence(&decisions),
     |                                                           ^^^^^^^^^^ value borrowed here after move
     |
     = note: borrow occurs due to deref coercion to `[PromotionDecision]`
note: deref defined here
    --> C:\Users\1\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\alloc\src\vec\mod.rs:3396:5
     |
3396 |     type Target = [T];
     |     ^^^^^^^^^^^
help: consider cloning the value if the performance cost is acceptable
     |
343  |             decisions: decisions.clone(),
     |                      +++++++++++++++++++

error[E0599]: no method named `check_health` found for reference `&Arc<HealthManager>` in the current scope
   --> crates\memory\src\service_di\coordinator_factory.rs:230:28
    |
230 |             health_manager.check_health().await
    |                            ^^^^^^^^^^^^ method not found in `&Arc<HealthManager>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `MonitoringServiceTrait` defines an item `check_health`, perhaps you need to implement it
   --> crates\memory\src\services\traits.rs:110:1
    |
110 | pub trait MonitoringServiceTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `get_cache_stats` found for reference `&Arc<embedding_coordinator::EmbeddingCoordinator>` in the current scope
   --> crates\memory\src\service_di\coordinator_factory.rs:245:48
    |
245 |             if let Ok(stats) = embedding_coord.get_cache_stats().await {
    |                                                ^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `CacheServiceTrait` defines an item `get_cache_stats`, perhaps you need to implement it
   --> crates\memory\src\services\traits.rs:139:1
    |
139 | pub trait CacheServiceTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `cache_stats` with a similar name
    |
245 -             if let Ok(stats) = embedding_coord.get_cache_stats().await {
245 +             if let Ok(stats) = embedding_coord.cache_stats().await {
    |

error[E0599]: no method named `get_stats` found for reference `&Arc<search_coordinator::SearchCoordinator>` in the current scope
   --> crates\memory\src\service_di\coordinator_factory.rs:254:45
    |
254 |             if let Ok(stats) = search_coord.get_stats().await {
    |                                             ^^^^^^^^^ method not found in `&Arc<search_coordinator::SearchCoordinator>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_stats`, perhaps you need to implement one of them:
            candidate #1: `MetricsReporter`
            candidate #2: `PromotionMetrics`

error[E0061]: this function takes 1 argument but 0 arguments were supplied
   --> crates\memory\src\service_di\coordinator_factory.rs:350:25
    |
350 |         let container = crate::di_container::DIContainer::new();
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-- argument #1 of type `ContainerCore` is missing
    |
note: associated function defined here
   --> crates\memory\src\di\container_builder.rs:134:19
    |
134 |     pub(crate) fn new(core: ContainerCore) -> Self {
    |                   ^^^ -------------------
help: provide the argument
    |
350 |         let container = crate::di_container::DIContainer::new(/* ContainerCore */);
    |                                                               +++++++++++++++++++

error[E0599]: no method named `clone` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:68:79
    |
68  |         let coordinator_factory = ProductionCoordinatorFactory::new(container.clone());
    |                                                                               ^^^^^ method not found in `DIContainer`
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `clone` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0061]: this function takes 0 arguments but 1 argument was supplied
   --> crates\memory\src\service_di\facade.rs:68:35
    |
68  |         let coordinator_factory = ProductionCoordinatorFactory::new(container.clone());
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ----------------- unexpected argument
    |
note: associated function defined here
   --> crates\memory\src\service_di\coordinator_factory.rs:284:12
    |
284 |     pub fn new() -> Self {
    |            ^^^
help: remove the extra argument
    |
68  -         let coordinator_factory = ProductionCoordinatorFactory::new(container.clone());
68  +         let coordinator_factory = ProductionCoordinatorFactory::new();
    |

error[E0782]: expected a type, found a trait
  --> crates\memory\src\service_di\facade.rs:71:32
   |
71 |         let metrics = Arc::new(DIMetricsCollector::new_production());
   |                                ^^^^^^^^^^^^^^^^^^
   |
help: you can add the `dyn` keyword if you want a trait object
   |
71 |         let metrics = Arc::new(<dyn DIMetricsCollector>::new_production());
   |                                ++++                   +

error[E0599]: no function or associated item named `new_production` found for struct `circuit_breaker::CircuitBreaker` in the current scope
   --> crates\memory\src\service_di\facade.rs:72:56
    |
72  |         let circuit_breaker = Arc::new(CircuitBreaker::new_production());
    |                                                        ^^^^^^^^^^^^^^ function or associated item not found in `circuit_breaker::CircuitBreaker`
    |
   ::: crates\memory\src\service_di\circuit_breaker.rs:118:1
    |
118 | pub struct CircuitBreaker {
    | ------------------------- function or associated item `new_production` not found for this struct
    |
note: if you're trying to build a new `circuit_breaker::CircuitBreaker` consider using one of the following associated functions:
      circuit_breaker::CircuitBreaker::new
      circuit_breaker::CircuitBreaker::with_production_config
      circuit_breaker::CircuitBreaker::with_minimal_config
   --> crates\memory\src\service_di\circuit_breaker.rs:126:5
    |
126 |     pub fn new(config: CircuitBreakerConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
144 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
148 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `new_production` found for struct `lifecycle_manager::LifecycleManager` in the current scope
   --> crates\memory\src\service_di\facade.rs:73:62
    |
73  |         let lifecycle_manager = Arc::new(DILifecycleManager::new_production());
    |                                                              ^^^^^^^^^^^^^^ function or associated item not found in `lifecycle_manager::LifecycleManager`
    |
   ::: crates\memory\src\service_di\lifecycle_manager.rs:105:1
    |
105 | pub struct LifecycleManager {
    | --------------------------- function or associated item `new_production` not found for this struct
    |
note: if you're trying to build a new `lifecycle_manager::LifecycleManager` consider using one of the following associated functions:
      lifecycle_manager::LifecycleManager::new
      lifecycle_manager::LifecycleManager::with_production_config
      lifecycle_manager::LifecycleManager::with_minimal_config
   --> crates\memory\src\service_di\lifecycle_manager.rs:123:5
    |
123 |     pub fn new(config: LifecycleConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
135 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
139 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `clone` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:78:27
    |
78  |                 container.clone(),
    |                           ^^^^^ method not found in `DIContainer`
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `clone` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0782]: expected a type, found a trait
   --> crates\memory\src\service_di\facade.rs:107:32
    |
107 |         let metrics = Arc::new(DIMetricsCollector::new_minimal());
    |                                ^^^^^^^^^^^^^^^^^^
    |
help: you can add the `dyn` keyword if you want a trait object
    |
107 |         let metrics = Arc::new(<dyn DIMetricsCollector>::new_minimal());
    |                                ++++                   +

error[E0599]: no function or associated item named `new_minimal` found for struct `circuit_breaker::CircuitBreaker` in the current scope
   --> crates\memory\src\service_di\facade.rs:108:56
    |
108 |         let circuit_breaker = Arc::new(CircuitBreaker::new_minimal());
    |                                                        ^^^^^^^^^^^ function or associated item not found in `circuit_breaker::CircuitBreaker`
    |
   ::: crates\memory\src\service_di\circuit_breaker.rs:118:1
    |
118 | pub struct CircuitBreaker {
    | ------------------------- function or associated item `new_minimal` not found for this struct
    |
note: if you're trying to build a new `circuit_breaker::CircuitBreaker` consider using one of the following associated functions:
      circuit_breaker::CircuitBreaker::new
      circuit_breaker::CircuitBreaker::with_production_config
      circuit_breaker::CircuitBreaker::with_minimal_config
   --> crates\memory\src\service_di\circuit_breaker.rs:126:5
    |
126 |     pub fn new(config: CircuitBreakerConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
144 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
148 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `new_minimal` found for struct `lifecycle_manager::LifecycleManager` in the current scope
   --> crates\memory\src\service_di\facade.rs:109:62
    |
109 |         let lifecycle_manager = Arc::new(DILifecycleManager::new_minimal());
    |                                                              ^^^^^^^^^^^ function or associated item not found in `lifecycle_manager::LifecycleManager`
    |
   ::: crates\memory\src\service_di\lifecycle_manager.rs:105:1
    |
105 | pub struct LifecycleManager {
    | --------------------------- function or associated item `new_minimal` not found for this struct
    |
note: if you're trying to build a new `lifecycle_manager::LifecycleManager` consider using one of the following associated functions:
      lifecycle_manager::LifecycleManager::new
      lifecycle_manager::LifecycleManager::with_production_config
      lifecycle_manager::LifecycleManager::with_minimal_config
   --> crates\memory\src\service_di\lifecycle_manager.rs:123:5
    |
123 |     pub fn new(config: LifecycleConfig) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
135 |     pub fn with_production_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
139 |     pub fn with_minimal_config() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `clone` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:114:27
    |
114 |                 container.clone(),
    |                           ^^^^^ method not found in `DIContainer`
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `clone` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `clone`, perhaps you need to implement it:
            candidate #1: `Clone`

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> crates\memory\src\service_di\facade.rs:135:32
    |
135 |         self.lifecycle_manager.initialize().await?;
    |                                ^^^^^^^^^^-- argument #1 is missing
    |
note: method defined here
   --> crates\memory\src\service_di\lifecycle_manager.rs:144:18
    |
144 |     pub async fn initialize<F, Fut>(&self, init_fn: F) -> Result<()>
    |                  ^^^^^^^^^^                ----------
help: provide the argument
    |
135 |         self.lifecycle_manager.initialize(/* init_fn */).await?;
    |                                           +++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> crates\memory\src\service_di\facade.rs:320:32
    |
320 |         self.lifecycle_manager.shutdown().await?;
    |                                ^^^^^^^^-- argument #1 is missing
    |
note: method defined here
   --> crates\memory\src\service_di\lifecycle_manager.rs:241:18
    |
241 |     pub async fn shutdown<F, Fut>(&self, shutdown_fn: F) -> Result<()>
    |                  ^^^^^^^^                --------------
help: provide the argument
    |
320 |         self.lifecycle_manager.shutdown(/* shutdown_fn */).await?;
    |                                         +++++++++++++++++

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> crates\memory\src\di_memory_config.rs:208:35
    |
208 |         let memory_orchestrator = MemoryOrchestrator::from_container(container.core())?;
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
    |
    = help: the trait `Try` is not implemented for `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
help: consider `await`ing on the `Future`
    |
208 |         let memory_orchestrator = MemoryOrchestrator::from_container(container.core()).await?;
    |                                                                                       ++++++

error[E0615]: attempted to take value of method `max_entries` on type `CacheConfig`
   --> crates\memory\src\di_memory_config.rs:314:38
    |
314 |                   cache_config_clone.max_entries, 
    |                                      ^^^^^^^^^^^ method, not a field
    |
help: use parentheses to call the method
    |
314 |                   cache_config_clone.max_entries(), 
    |                                                 ++

error[E0615]: attempted to take value of method `ttl_seconds` on type `CacheConfig`
   --> crates\memory\src\di_memory_config.rs:315:38
    |
315 |                   cache_config_clone.ttl_seconds.unwrap_or(3600));
    |                                      ^^^^^^^^^^^ method, not a field
    |
help: use parentheses to call the method
    |
315 |                   cache_config_clone.ttl_seconds().unwrap_or(3600));
    |                                                 ++

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> crates\memory\src\di_memory_config.rs:493:29
    |
493 |                 Ok(Arc::new(MemoryOrchestrator::from_container(container)?))
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
    |
    = help: the trait `Try` is not implemented for `impl futures::Future<Output = Result<OrchestrationFacade, anyhow::Error>>`
note: this implements `Future` and its output type supports `?`, but the future cannot be awaited in a synchronous function
   --> crates\memory\src\di_memory_config.rs:493:74
    |
491 |             .register_singleton(|container| {
    |                                 ----------- this is not `async`
492 |                 info!("Создание MemoryOrchestrator");
493 |                 Ok(Arc::new(MemoryOrchestrator::from_container(container)?))
    |                                                                          ^

error[E0521]: borrowed data escapes outside of method
   --> crates\memory\src\orchestration\orchestration_lifecycle_manager.rs:174:24
    |
162 |           coordinators: Vec<(&'static str, &dyn Coordinator)>,
    |           ------------                     - let's call the lifetime of this reference `'1`
    |           |
    |           `coordinators` declared here, outside of the method body
    |           `coordinators` is a reference that is only valid in the method body
...
174 |               let task = tokio::spawn(async move {
    |  ________________________^
175 | |                 let result = timeout(timeout_duration, coordinator.initialize()).await;
176 | |                 let duration = init_start.elapsed();
...   |
207 | |             });
    | |              ^
    | |              |
    | |______________`coordinators` escapes the method body here
    |                argument requires that `'1` must outlive `'static`

error[E0599]: no method named `run_health_check` found for struct `Arc<HealthManager>` in the current scope
   --> crates\memory\src\orchestration\orchestration_lifecycle_manager.rs:264:44
    |
264 |                     if let Err(e) = health.run_health_check().await {
    |                                            ^^^^^^^^^^^^^^^^ method not found in `Arc<HealthManager>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `HealthCoordinator` which provides `run_health_check` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::HealthCoordinator;
    |

error[E0599]: no method named `check_resources` found for struct `Arc<ResourceController>` in the current scope
   --> crates\memory\src\orchestration\operation_executor.rs:169:41
    |
169 |         if !self.coordinators.resources.check_resources(resource_type).await? {
    |                                         ^^^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: there is a method `free_resources` with a similar name, but with different arguments
   --> crates\memory\src\orchestration\traits.rs:134:5
    |
134 |     async fn free_resources(&self) -> Result<()>;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `ResourceCoordinator` which provides `check_resources` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::ResourceCoordinator;
    |

error[E0599]: no method named `adapt_limits` found for struct `Arc<ResourceController>` in the current scope
   --> crates\memory\src\orchestration\operation_executor.rs:171:57
    |
171 |             if let Err(e) = self.coordinators.resources.adapt_limits().await {
    |                                                         ^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ResourceCoordinator` which provides `adapt_limits` is implemented but not in scope; perhaps you want to import it
    |
1   + use crate::orchestration::traits::ResourceCoordinator;
    |
help: there is a method `get_limits` with a similar name
    |
171 -             if let Err(e) = self.coordinators.resources.adapt_limits().await {
171 +             if let Err(e) = self.coordinators.resources.get_limits().await {
    |

error[E0599]: no method named `execute_search` found for struct `Arc<orchestration::operation_executor::OperationExecutor>` in the current scope
   --> crates\memory\src\orchestration\orchestration_facade.rs:110:33
    |
110 |         self.operation_executor.execute_search(query, layer, options).await
    |                                 ^^^^^^^^^^^^^^ method not found in `Arc<orchestration::operation_executor::OperationExecutor>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `OperationExecutorTrait` defines an item `execute_search`, perhaps you need to implement it
   --> crates\memory\src\orchestration\operation_executor.rs:66:1
    |
66  | pub trait OperationExecutorTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `execute_embedding` found for struct `Arc<orchestration::operation_executor::OperationExecutor>` in the current scope
   --> crates\memory\src\orchestration\orchestration_facade.rs:115:33
    |
115 |         self.operation_executor.execute_embedding(text).await
    |                                 ^^^^^^^^^^^^^^^^^ method not found in `Arc<orchestration::operation_executor::OperationExecutor>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `OperationExecutorTrait` defines an item `execute_embedding`, perhaps you need to implement it
   --> crates\memory\src\orchestration\operation_executor.rs:66:1
    |
66  | pub trait OperationExecutorTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `execute_promotion` found for struct `Arc<orchestration::operation_executor::OperationExecutor>` in the current scope
   --> crates\memory\src\orchestration\orchestration_facade.rs:120:33
    |
120 |         self.operation_executor.execute_promotion().await
    |                                 ^^^^^^^^^^^^^^^^^ method not found in `Arc<orchestration::operation_executor::OperationExecutor>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `OperationExecutorTrait` defines an item `execute_promotion`, perhaps you need to implement it
   --> crates\memory\src\orchestration\operation_executor.rs:66:1
    |
66  | pub trait OperationExecutorTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `execute_backup` found for struct `Arc<orchestration::operation_executor::OperationExecutor>` in the current scope
   --> crates\memory\src\orchestration\orchestration_facade.rs:125:33
    |
125 |         self.operation_executor.execute_backup(path).await
    |                                 ^^^^^^^^^^^^^^ method not found in `Arc<orchestration::operation_executor::OperationExecutor>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `OperationExecutorTrait` defines an item `execute_backup`, perhaps you need to implement it
   --> crates\memory\src\orchestration\operation_executor.rs:66:1
    |
66  | pub trait OperationExecutorTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0592]: duplicate definitions with name `new`
   --> crates\memory\src\service_di\coordinator_factory.rs:355:5
    |
284 |     pub fn new() -> Self {
    |     -------------------- other definition for `new`
...
355 |     pub fn new(container: DIContainer) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`

error[E0560]: struct `CacheConfig` has no field named `max_size_bytes`
  --> crates\memory\src\cache_lru.rs:74:13
   |
74 |             max_size_bytes: 4 * 1024 * 1024 * 1024, // 4GB
   |             ^^^^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `max_entries`
  --> crates\memory\src\cache_lru.rs:75:13
   |
75 |             max_entries: 500_000,
   |             ^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `ttl_seconds`
  --> crates\memory\src\cache_lru.rs:76:13
   |
76 |             ttl_seconds: Some(86400 * 30), // 30 days
   |             ^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `eviction_batch_size`
  --> crates\memory\src\cache_lru.rs:77:13
   |
77 |             eviction_batch_size: 200,
   |             ^^^^^^^^^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `max_size_bytes`
  --> crates\memory\src\cache_lru.rs:83:13
   |
83 |             max_size_bytes: 256 * 1024 * 1024, // 256MB
   |             ^^^^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `max_entries`
  --> crates\memory\src\cache_lru.rs:84:13
   |
84 |             max_entries: 10_000,
   |             ^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `ttl_seconds`
  --> crates\memory\src\cache_lru.rs:85:13
   |
85 |             ttl_seconds: Some(86400), // 1 day
   |             ^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `eviction_batch_size`
  --> crates\memory\src\cache_lru.rs:86:13
   |
86 |             eviction_batch_size: 50,
   |             ^^^^^^^^^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `max_size_bytes`
  --> crates\memory\src\cache_migration.rs:52:9
   |
52 |         max_size_bytes,
   |         ^^^^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `max_entries`
  --> crates\memory\src\cache_migration.rs:53:9
   |
53 |         max_entries: max_size_bytes / 10240, // Assume ~10KB per embedding
   |         ^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `ttl_seconds`
  --> crates\memory\src\cache_migration.rs:54:9
   |
54 |         ttl_seconds: Some(86400 * 30), // 30 days
   |         ^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0560]: struct `CacheConfig` has no field named `eviction_batch_size`
  --> crates\memory\src\cache_migration.rs:55:9
   |
55 |         eviction_batch_size: 100,
   |         ^^^^^^^^^^^^^^^^^^^ `CacheConfig` does not have this field
   |
   = note: available fields are: `base`

error[E0689]: can't call method `abs` on ambiguous numeric type `{float}`
   --> crates\memory\src\ml_promotion\algorithms.rs:167:47
    |
167 |             if (predicted_class - true_class).abs() < 0.1f32 {
    |                                               ^^^

error[E0689]: can't call method `abs` on ambiguous numeric type `{float}`
   --> crates\memory\src\ml_promotion\algorithms.rs:356:47
    |
356 |             if (predicted_class - true_class).abs() < 0.1f32 {
    |                                               ^^^

error[E0689]: can't call method `abs` on ambiguous numeric type `{float}`
   --> crates\memory\src\ml_promotion\algorithms.rs:593:47
    |
593 |             if (predicted_class - true_class).abs() < 0.1f32 {
    |                                               ^^^

error[E0599]: no method named `hour` found for struct `NaiveTime` in the current scope
   --> crates\memory\src\ml_promotion\rules_engine.rs:450:58
    |
450 |                     let current_hour = Utc::now().time().hour() as u8;
    |                                                          ^^^^
    |
   ::: C:\Users\1\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\chrono-0.4.41\src\traits.rs:285:8
    |
285 |     fn hour(&self) -> u32;
    |        ---- the method is available for `NaiveTime` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Timelike` which provides `hour` is implemented but not in scope; perhaps you want to import it
    |
1   + use chrono::Timelike;
    |
help: there is a method `hour12` with a similar name
    |
450 |                     let current_hour = Utc::now().time().hour12() as u8;
    |                                                              ++

error[E0599]: no method named `hour` found for struct `NaiveTime` in the current scope
   --> crates\memory\src\ml_promotion\rules_engine.rs:530:46
    |
530 |         let current_hour = Utc::now().time().hour() as u8;
    |                                              ^^^^
    |
   ::: C:\Users\1\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\chrono-0.4.41\src\traits.rs:285:8
    |
285 |     fn hour(&self) -> u32;
    |        ---- the method is available for `NaiveTime` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Timelike` which provides `hour` is implemented but not in scope; perhaps you want to import it
    |
1   + use chrono::Timelike;
    |
help: there is a method `hour12` with a similar name
    |
530 |         let current_hour = Utc::now().time().hour12() as u8;
    |                                                  ++

error[E0599]: no method named `initialize` found for reference `&Arc<embedding_coordinator::EmbeddingCoordinator>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:436:29
    |
436 |             embedding_coord.initialize().await?;
    |                             ^^^^^^^^^^ method not found in `&Arc<embedding_coordinator::EmbeddingCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `initialize` is implemented but not in scope; perhaps you want to import it
    |
7   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `initialize` found for reference `&Arc<search_coordinator::SearchCoordinator>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:440:26
    |
440 |             search_coord.initialize().await?;
    |                          ^^^^^^^^^^ method not found in `&Arc<search_coordinator::SearchCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `initialize` is implemented but not in scope; perhaps you want to import it
    |
7   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `shutdown` found for reference `&Arc<embedding_coordinator::EmbeddingCoordinator>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:453:29
    |
453 |             embedding_coord.shutdown().await?;
    |                             ^^^^^^^^ method not found in `&Arc<embedding_coordinator::EmbeddingCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `shutdown` is implemented but not in scope; perhaps you want to import it
    |
7   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `shutdown` found for reference `&Arc<search_coordinator::SearchCoordinator>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:457:26
    |
457 |             search_coord.shutdown().await?;
    |                          ^^^^^^^^ method not found in `&Arc<search_coordinator::SearchCoordinator>`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Coordinator` which provides `shutdown` is implemented but not in scope; perhaps you want to import it
    |
7   + use crate::orchestration::traits::Coordinator;
    |

error[E0599]: no method named `flush_all` found for struct `Arc<storage::VectorStore>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:470:15
    |
470 |         store.flush_all().await?;
    |               ^^^^^^^^^ method not found in `Arc<storage::VectorStore>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `service_di::operation_executor::OperationExecutor` defines an item `flush_all`, perhaps you need to implement it
   --> crates\memory\src\service_di\operation_executor.rs:93:1
    |
93  | pub trait OperationExecutor: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `run_promotion` found for struct `Arc<PromotionEngine>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:481:38
    |
481 |         let stats = promotion_engine.run_promotion().await?;
    |                                      ^^^^^^^^^^^^^
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `run_promotion`, perhaps you need to implement one of them:
            candidate #1: `orchestration::traits::PromotionCoordinator`
            candidate #2: `service_di::operation_executor::OperationExecutor`
help: there is a method `run_promotion_cycle` with a similar name
    |
481 |         let stats = promotion_engine.run_promotion_cycle().await?;
    |                                                   ++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> crates\memory\src\service_di\operation_executor.rs:492:39
    |
492 |         let metadata = backup_manager.create_backup(path).await?;
    |                                       ^^^^^^^^^^^^^------ argument #2 of type `std::option::Option<std::string::String>` is missing
    |
note: expected `Arc<VectorStore>`, found `&str`
   --> crates\memory\src\service_di\operation_executor.rs:492:53
    |
492 |         let metadata = backup_manager.create_backup(path).await?;
    |                                                     ^^^^
    = note: expected struct `Arc<storage::VectorStore>`
            found reference `&'life1 str`
note: method defined here
   --> crates\memory\src\backup.rs:65:18
    |
65  |     pub async fn create_backup(
    |                  ^^^^^^^^^^^^^
66  |         &self,
67  |         store: Arc<VectorStore>,
    |         -----------------------
68  |         backup_name: Option<String>,
    |         ---------------------------
help: provide the argument
    |
492 -         let metadata = backup_manager.create_backup(path).await?;
492 +         let metadata = backup_manager.create_backup(/* Arc<storage::VectorStore> */, /* std::option::Option<std::string::String> */).await?;
    |

error[E0609]: no field `size_bytes` on type `PathBuf`
   --> crates\memory\src\service_di\operation_executor.rs:494:51
    |
494 |         debug!("✅ Backup создан: {} MB", metadata.size_bytes / 1024 / 1024);
    |                                                    ^^^^^^^^^^ unknown field

error[E0308]: mismatched types
   --> crates\memory\src\service_di\operation_executor.rs:495:12
    |
495 |         Ok(metadata)
    |         -- ^^^^^^^^ expected `BackupMetadata`, found `PathBuf`
    |         |
    |         arguments to this enum variant are incorrect
    |
help: the type constructed contains `PathBuf` due to the type of the argument passed
   --> crates\memory\src\service_di\operation_executor.rs:495:9
    |
495 |         Ok(metadata)
    |         ^^^--------^
    |            |
    |            this argument influences the type of `Ok`
note: tuple variant defined here
   --> C:\Users\1\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\result.rs:552:5
    |
552 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^

error[E0599]: no method named `flush_all` found for struct `Arc<storage::VectorStore>` in the current scope
   --> crates\memory\src\service_di\operation_executor.rs:604:15
    |
604 |         store.flush_all().await
    |               ^^^^^^^^^ method not found in `Arc<storage::VectorStore>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `service_di::operation_executor::OperationExecutor` defines an item `flush_all`, perhaps you need to implement it
   --> crates\memory\src\service_di\operation_executor.rs:93:1
    |
93  | pub trait OperationExecutor: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0560]: struct `BackupMetadata` has no field named `size_bytes`
   --> crates\memory\src\service_di\operation_executor.rs:623:13
    |
623 |             size_bytes: 0,
    |             ^^^^^^^^^^ `BackupMetadata` does not have this field
    |
    = note: available fields are: `layer_checksums`

error[E0308]: mismatched types
   --> crates\memory\src\service_di\operation_executor.rs:624:23
    |
624 |             checksum: "mock".to_string(),
    |                       ^^^^^^^^^^^^^^^^^^ expected `Option<String>`, found `String`
    |
    = note: expected enum `std::option::Option<std::string::String>`
             found struct `std::string::String`
help: try wrapping the expression in `Some`
    |
624 |             checksum: Some("mock".to_string()),
    |                       +++++                  +

error[E0560]: struct `BackupMetadata` has no field named `compression`
   --> crates\memory\src\service_di\operation_executor.rs:625:13
    |
625 |             compression: None,
    |             ^^^^^^^^^^^ `BackupMetadata` does not have this field
    |
    = note: available fields are: `layer_checksums`

error[E0599]: no method named `get_performance_metrics` found for struct `DIContainer` in the current scope
   --> crates\memory\src\service_di\facade.rs:297:24
    |
297 |         self.container.get_performance_metrics()
    |                        ^^^^^^^^^^^^^^^^^^^^^^^
    |
   ::: crates\memory\src\di\container_builder.rs:128:1
    |
128 | pub struct DIContainer {
    | ---------------------- method `get_performance_metrics` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_performance_metrics`, perhaps you need to implement one of them:
            candidate #1: `MetricsCollectorTrait`
            candidate #2: `MetricsReporter`
help: there is a method `performance_metrics` with a similar name
    |
297 -         self.container.get_performance_metrics()
297 +         self.container.performance_metrics()
    |

warning: unused import: `SearchCoordinator`
  --> crates\memory\src\orchestration\operation_executor.rs:16:13
   |
16 |             SearchCoordinator as SearchCoordinatorTrait,
   |             ^^^^^^^^^^^^^^^^^

error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable
   --> crates\memory\src\ml_promotion\metrics.rs:256:9
    |
253 |         let mut stats = self.stats.lock().unwrap();
    |                         ---------- immutable borrow occurs here
...
256 |         self.take_historical_snapshot(&stats);
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here
...
259 |         stats.inference_times.clear();
    |         ----- immutable borrow later used here

warning: unused variable: `container`
   --> crates\memory\src\service_di\coordinator_factory.rs:355:16
    |
355 |     pub fn new(container: DIContainer) -> Self {
    |                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_container`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `dependency`
   --> crates\memory\src\di\dependency_validator.rs:131:18
    |
131 |             for &dependency in deps {
    |                  ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dependency`

Some errors have detailed explanations: E0061, E0277, E0308, E0382, E0502, E0521, E0560, E0592, E0599...
For more information about an error, try `rustc --explain E0061`.
warning: `memory` (lib) generated 20 warnings
error: could not compile `memory` (lib) due to 65 previous errors; 20 warnings emitted
