## MAGRAY Agent Report — 20250810_013647

### Environment

- hostname: cursor
- kernel: 6.1.147
- rustc: rustc 1.91.0-nightly (de3efa79f 2025-08-08)
- cargo: cargo 1.91.0-nightly (840b83a10 2025-07-30)

### Workspace Summary

- packages: n/a
- git branch: cursor/deep-project-analysis-and-critique-b66a
- git status: 1 changes

### Code Stats

- *.rs files: 466
- rust LOC: 198989

### Suspicious Patterns

rg not found; skipping

### Build Health

    cargo fmt --check:
    Diff in /workspace/crates/ai/examples/check_gpu_usage.rs:1:
     // Проверка использования GPU в ONNX Runtime
    [31m-#[cfg(feature = "gpu")]
    (B[m[31m-use ai::gpu_detector::GpuDetector;
    (B[m use ai::config::EmbeddingConfig;
     use ai::embeddings_cpu::CpuEmbeddingService;
    [32m+#[cfg(feature = "gpu")]
    (B[m[32m+use ai::gpu_detector::GpuDetector;
    (B[m 
     fn main() -> anyhow::Result<()> {
         // Инициализация логирования с максимальным уровнем
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:1:
     use crate::memory_pool::GLOBAL_MEMORY_POOL;
    [32m+use crate::should_disable_ort;
    (B[m use crate::tokenization::{
         BatchTokenized, OptimizedTokenizer, TokenizedInput as OptTokenizedInput,
     };
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:5:
     use crate::EmbeddingConfig;
    [31m-use crate::should_disable_ort;
    (B[m #[cfg(feature = "gpu")]
     use crate::{GpuConfig, GpuInfo};
     use anyhow::Result as AnyhowResult;
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:839:
                 }
             }
         }
    [31m-    let inv = if seq_len > 0 { 1.0 / (seq_len as f32) } else { 0.0 };
    (B[m[32m+    let inv = if seq_len > 0 {
    (B[m[32m+        1.0 / (seq_len as f32)
    (B[m[32m+    } else {
    (B[m[32m+        0.0
    (B[m[32m+    };
    (B[m     for v in &mut pooled {
             *v *= inv;
         }
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:849:
     /// Pure scalar L2 normalization
     pub(crate) fn l2_normalize_scalar(mut v: Vec<f32>) -> Vec<f32> {
         let mut norm_sq = 0.0f32;
    [31m-    for &x in &v { norm_sq += x * x; }
    (B[m[32m+    for &x in &v {
    (B[m[32m+        norm_sq += x * x;
    (B[m[32m+    }
    (B[m     let norm = norm_sq.sqrt();
         if norm > 1e-8 {
             let inv = 1.0 / norm;
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:856:
    [31m-        for x in &mut v { *x *= inv; }
    (B[m[32m+        for x in &mut v {
    (B[m[32m+            *x *= inv;
    (B[m[32m+        }
    (B[m     }
         v
     }
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:865:
         seq_len: usize,
         hidden_size: usize,
     ) -> Option<Vec<f32>> {
    [31m-    if shape_vec.len() != 3 || shape_vec[0] != 1 || shape_vec[1] != seq_len as i64 || shape_vec[2] != hidden_size as i64 {
    (B[m[32m+    if shape_vec.len() != 3
    (B[m[32m+        || shape_vec[0] != 1
    (B[m[32m+        || shape_vec[1] != seq_len as i64
    (B[m[32m+        || shape_vec[2] != hidden_size as i64
    (B[m[32m+    {
    (B[m         return None;
         }
         let need = seq_len.checked_mul(hidden_size)?;
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:872:
    [31m-    if need > data.len() { return None; }
    (B[m[32m+    if need > data.len() {
    (B[m[32m+        return None;
    (B[m[32m+    }
    (B[m     let pooled = mean_pool_scalar(&data[0..need], seq_len, hidden_size);
         Some(l2_normalize_scalar(pooled))
     }
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:881:
         #[test]
         fn test_mean_pool_scalar_basic() {
             // seq_len=2, hidden=4: rows [1,2,3,4] and [5,6,7,8]
    [31m-        let data = vec![1.0,2.0,3.0,4.0, 5.0,6.0,7.0,8.0];
    (B[m[32m+        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
    (B[m         let pooled = mean_pool_scalar(&data, 2, 4);
    [31m-        assert_eq!(pooled, vec![3.0,4.0,5.0,6.0]);
    (B[m[32m+        assert_eq!(pooled, vec![3.0, 4.0, 5.0, 6.0]);
    (B[m     }
     
         #[test]
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:890:
         fn test_l2_normalize_scalar_unit_norm() {
             let v = vec![3.0, 4.0];
             let n = l2_normalize_scalar(v);
    [31m-        let norm: f32 = n.iter().map(|x| x*x).sum::<f32>().sqrt();
    (B[m[32m+        let norm: f32 = n.iter().map(|x| x * x).sum::<f32>().sqrt();
    (B[m         assert!((norm - 1.0).abs() < 1e-6);
         }
     
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:899:
             let seq_len = 2usize;
             let hidden = 4usize;
             let shape = [1i64, seq_len as i64, hidden as i64];
    [31m-        let data = vec![1.0,2.0,3.0,4.0, 5.0,6.0,7.0,8.0];
    (B[m[32m+        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
    (B[m         let emb = extract_embedding_from_3d_scalar(&shape, &data, seq_len, hidden).expect("ok");
             assert_eq!(emb.len(), hidden);
             // mean pooled = [3,4,5,6] → norm ~ sqrt(86) ≈ 9.2736 → normalized first ~ 0.323
    Diff in /workspace/crates/ai/src/embeddings_cpu.rs:906:
             let expected0 = 3.0f32 / 86.0f32.sqrt();
             assert!((emb[0] - expected0).abs() < 1e-3);
    [31m-        let norm: f32 = emb.iter().map(|x| x*x).sum::<f32>().sqrt();
    (B[m[32m+        let norm: f32 = emb.iter().map(|x| x * x).sum::<f32>().sqrt();
    (B[m         assert!((norm - 1.0).abs() < 1e-5);
         }
     
    Diff in /workspace/crates/ai/src/lib.rs:119:
     }
     
     pub fn should_disable_ort() -> bool {
    [31m-    std::env::var("MAGRAY_FORCE_NO_ORT").map(|v| matches!(v.to_lowercase().as_str(), "1"|"true"|"yes"|"y"))
    (B[m[32m+    std::env::var("MAGRAY_FORCE_NO_ORT")
    (B[m[32m+        .map(|v| matches!(v.to_lowercase().as_str(), "1" | "true" | "yes" | "y"))
    (B[m         .unwrap_or(false)
     }
     
    Diff in /workspace/crates/ai/src/model_downloader.rs:37:
             let mut headers = reqwest::header::HeaderMap::new();
             if let Ok(token) = std::env::var("HF_TOKEN") {
                 if !token.is_empty() {
    [31m-                if let Ok(value) = reqwest::header::HeaderValue::from_str(&format!("Bearer {}", token)) {
    (B[m[32m+                if let Ok(value) =
    (B[m[32m+                    reqwest::header::HeaderValue::from_str(&format!("Bearer {}", token))
    (B[m[32m+                {
    (B[m                     headers.insert(reqwest::header::AUTHORIZATION, value);
                     }
                 }
    Diff in /workspace/crates/ai/src/model_downloader.rs:118:
     
             // Если есть известные контрольные суммы, проверим
             // (Сейчас нет реестра checksum'ов здесь; поле sha256 на каждом файле может быть задано из get_model_info)
    [31m-        let info = self.get_model_info(model_path.file_name().and_then(|s| s.to_str()).unwrap_or(""));
    (B[m[32m+        let info = self.get_model_info(
    (B[m[32m+            model_path
    (B[m[32m+                .file_name()
    (B[m[32m+                .and_then(|s| s.to_str())
    (B[m[32m+                .unwrap_or(""),
    (B[m[32m+        );
    (B[m         if let Ok(info) = info {
                 for f in &info.files {
                     if let Some(sum) = &f.sha256 {
    Diff in /workspace/crates/ai/src/model_downloader.rs:202:
             let mut out = Vec::new();
             match (model_name, filename) {
                 ("qwen3emb", "tokenizer.json") => {
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/tokenizer.json".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/tokenizer.json"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m             }
                 ("qwen3emb", "config.json") => {
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/config.json".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/config.json"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m             }
                 ("qwen3emb", "model.onnx") => {
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/model.onnx".to_string());
    (B[m[31m-                out.push("https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/onnx/model.onnx".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/model.onnx"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/onnx/model.onnx"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m                 out.push("https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/onnx/encoder_model.onnx".to_string());
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/model_fp16.onnx".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Embedding-0.6B/resolve/main/model_fp16.onnx"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m             }
                 ("qwen3_reranker", "tokenizer.json") => {
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/tokenizer.json".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/tokenizer.json"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m             }
                 ("qwen3_reranker", "config.json") => {
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/config.json".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/config.json"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m             }
                 ("qwen3_reranker", "model.onnx") => {
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/model.onnx".to_string());
    (B[m[31m-                out.push("https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/onnx/model.onnx".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/model.onnx"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/onnx/model.onnx"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m                 out.push("https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/onnx/encoder_model.onnx".to_string());
    [31m-                out.push("https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/model_fp16.onnx".to_string());
    (B[m[32m+                out.push(
    (B[m[32m+                    "https://huggingface.co/Qwen/Qwen3-Reranker-0.6B/resolve/main/model_fp16.onnx"
    (B[m[32m+                        .to_string(),
    (B[m[32m+                );
    (B[m             }
                 _ => {}
             }
    Diff in /workspace/crates/ai/src/model_downloader.rs:269:
                             return Ok(());
                         }
                         Err(e) => {
    [31m-                        warn!("Попытка {}/{}: не удалось скачать {} из {}: {}", idx + 1, candidates.len(), file.filename, url, e);
    (B[m[32m+                        warn!(
    (B[m[32m+                            "Попытка {}/{}: не удалось скачать {} из {}: {}",
    (B[m[32m+                            idx + 1,
    (B[m[32m+                            candidates.len(),
    (B[m[32m+                            file.filename,
    (B[m[32m+                            url,
    (B[m[32m+                            e
    (B[m[32m+                        );
    (B[m                         last_err = Some(e);
                             // небольшой backoff
                             tokio::time::sleep(std::time::Duration::from_millis(250)).await;
    Diff in /workspace/crates/ai/src/model_downloader.rs:278:
                     }
                 }
                 // Если ни один URL не сработал, возвращаем последнюю ошибку
    [31m-            if let Some(e) = last_err { return Err(e); }
    (B[m[32m+            if let Some(e) = last_err {
    (B[m[32m+                return Err(e);
    (B[m[32m+            }
    (B[m             return Err(anyhow::anyhow!("Не удалось скачать {}", file.filename));
             }
     
    Diff in /workspace/crates/ai/src/model_downloader.rs:292:
                             info!("✅ Файл {} уже загружен (checksum ok)", file.filename);
                             return Ok(());
                         }
    [31m-                    warn!("Checksum mismatch for existing {}, re-downloading", file.filename);
    (B[m[32m+                    warn!(
    (B[m[32m+                        "Checksum mismatch for existing {}, re-downloading",
    (B[m[32m+                        file.filename
    (B[m[32m+                    );
    (B[m                 } else {
                         info!("✅ Файл {} уже загружен", file.filename);
                         return Ok(());
    Diff in /workspace/crates/ai/src/model_downloader.rs:395:
             // Верификация checksum если задана
             if let Some(sum) = &file.sha256 {
                 if !verify_sha256(&temp_path, sum).await? {
    [31m-                return Err(anyhow::anyhow!("Checksum verification failed for {}", file.filename));
    (B[m[32m+                return Err(anyhow::anyhow!(
    (B[m[32m+                    "Checksum verification failed for {}",
    (B[m[32m+                    file.filename
    (B[m[32m+                ));
    (B[m             }
             }
     
    Diff in /workspace/crates/ai/src/model_downloader.rs:500:
         let mut buf = vec![0u8; 1024 * 1024];
         loop {
             let n = file.read(&mut buf).await?;
    [31m-        if n == 0 { break; }
    (B[m[32m+        if n == 0 {
    (B[m[32m+            break;
    (B[m[32m+        }
    (B[m         hasher.update(&buf[..n]);
         }
         let result = hasher.finalize();
    Diff in /workspace/crates/ai/src/ort_setup.rs:61:
                     // Extend LD_LIBRARY_PATH/DYLD_LIBRARY_PATH for current process
                     #[cfg(any(target_os = "linux", target_os = "macos"))]
                     {
    [31m-                    let key = if cfg!(target_os = "macos") { "DYLD_LIBRARY_PATH" } else { "LD_LIBRARY_PATH" };
    (B[m[32m+                    let key = if cfg!(target_os = "macos") {
    (B[m[32m+                        "DYLD_LIBRARY_PATH"
    (B[m[32m+                    } else {
    (B[m[32m+                        "LD_LIBRARY_PATH"
    (B[m[32m+                    };
    (B[m                     let mut new_val = parent.display().to_string();
                         if let Ok(prev) = std::env::var(key) {
    [31m-                        if !prev.is_empty() { new_val = format!("{}:{}", parent.display(), prev); }
    (B[m[32m+                        if !prev.is_empty() {
    (B[m[32m+                            new_val = format!("{}:{}", parent.display(), prev);
    (B[m[32m+                        }
    (B[m                     }
                         std::env::set_var(key, &new_val);
                     }
    Diff in /workspace/crates/ai/src/ort_setup.rs:79:
         }
         warn!(target: "ai::ort_setup", "ONNX Runtime library not found. If you see init errors, run scripts/install_onnxruntime.sh or set ORT_DYLIB_PATH.");
     }
    [32m+
    (B[mDiff in /workspace/crates/ai/src/reranker_qwen3.rs:1:
     use crate::memory_pool::GLOBAL_MEMORY_POOL;
    [31m-use crate::{ModelLoader, RerankingConfig};
    (B[m use crate::should_disable_ort;
     use crate::tokenization::OptimizedTokenizer;
     #[cfg(feature = "gpu")]
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:6:
     use crate::{GpuConfig, GpuInfo};
    [32m+use crate::{ModelLoader, RerankingConfig};
    (B[m use anyhow::Result as AnyhowResult;
     // use common::service_traits::StatisticsProvider;
     use ort::{inputs, session::Session, value::Tensor};
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:198:
                         processing_time_ms: 0,
                     })
                     .collect();
    [31m-            results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
    (B[m[31m-            if let Some(k) = batch.top_k { results.truncate(k); }
    (B[m[32m+            results.sort_by(|a, b| {
    (B[m[32m+                b.score
    (B[m[32m+                    .partial_cmp(&a.score)
    (B[m[32m+                    .unwrap_or(std::cmp::Ordering::Equal)
    (B[m[32m+            });
    (B[m[32m+            if let Some(k) = batch.top_k {
    (B[m[32m+                results.truncate(k);
    (B[m[32m+            }
    (B[m             let total_time = start_time.elapsed().as_millis();
                 let throughput = 1000.0 * documents.len() as f64 / (total_time.max(1)) as f64;
    [31m-            return Ok(BatchRerankResult { results, total_time_ms: total_time, throughput_docs_per_sec: throughput });
    (B[m[32m+            return Ok(BatchRerankResult {
    (B[m[32m+                results,
    (B[m[32m+                total_time_ms: total_time,
    (B[m[32m+                throughput_docs_per_sec: throughput,
    (B[m[32m+            });
    (B[m         }
     
             // Process documents in optimized batches
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:266:
     
             // Tokenize all query-document pairs in batch using OptimizedTokenizer
             let tokenizer = self.create_tokenizer()?;
    [31m-        let pairs: Vec<(&str, &str)> = documents.iter().map(|d| (query.as_ref(), d.as_str())).collect();
    (B[m[32m+        let pairs: Vec<(&str, &str)> = documents
    (B[m[32m+            .iter()
    (B[m[32m+            .map(|d| (query.as_ref(), d.as_str()))
    (B[m[32m+            .collect();
    (B[m         let mut batch_tokenized = tokenizer.encode_batch_pairs(&pairs)?;
     
             // Find maximum sequence length for padding
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:327:
                 }
                 RerankerInner::Fallback => {
                     // Should not reach here, rerank_batch handles fallback early
    [31m-                return Err(anyhow::anyhow!("Fallback path should not call process_batch_optimized"));
    (B[m[32m+                return Err(anyhow::anyhow!(
    (B[m[32m+                    "Fallback path should not call process_batch_optimized"
    (B[m[32m+                ));
    (B[m             }
             };
     
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:367:
                 if let Ok((shape, data)) = output.try_extract_tensor::<f32>() {
                     let shape_vec: Vec<i64> = (0..shape.len()).map(|i| shape[i]).collect();
     
    [31m-                if let Some(scores) = try_extract_scores_from_shape_and_data(batch_size, &shape_vec, data) {
    (B[m[32m+                if let Some(scores) =
    (B[m[32m+                    try_extract_scores_from_shape_and_data(batch_size, &shape_vec, data)
    (B[m[32m+                {
    (B[m                     return Ok(scores);
                     }
                 }
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:445:
             top_k,
         };
     
    [31m-    let service = OptimizedQwen3RerankerService::new(PathBuf::from("test_models/qwen3_reranker/model.onnx"), 512, 8)?;
    (B[m[32m+    let service = OptimizedQwen3RerankerService::new(
    (B[m[32m+        PathBuf::from("test_models/qwen3_reranker/model.onnx"),
    (B[m[32m+        512,
    (B[m[32m+        8,
    (B[m[32m+    )?;
    (B[m     let batch_result = service.rerank_batch(&batch)?;
         Ok(batch_result.results)
     }
    Diff in /workspace/crates/ai/src/reranker_qwen3.rs:469:
         }
         let q = tokenize(query);
         let d = tokenize(doc);
    [31m-    if q.is_empty() || d.is_empty() { return 0.0; }
    (B[m[32m+    if q.is_empty() || d.is_empty() {
    (B[m[32m+        return 0.0;
    (B[m[32m+    }
    (B[m     let inter = q.intersection(&d).count() as f32;
         let union = q.union(&d).count() as f32;
    [31m-    if union <= 0.0 { 0.0 } else { inter / union }
    (B[m[32m+    if union <= 0.0 {
    (B[m[32m+        0.0
    (B[m[32m+    } else {
    (B[m[32m+        inter / union
    (B[m[32m+    }
    (B[m }
     
     #[cfg(test)]
    Diff in /workspace/crates/ai/src/tokenization/mod.rs:1:
     use anyhow::Result;
     use std::path::Path;
     use std::sync::Arc;
    [31m-use tokenizers::{PaddingDirection, PaddingParams, PaddingStrategy, Tokenizer, TruncationParams};
    (B[m use tokenizers::EncodeInput;
    [32m+use tokenizers::{PaddingDirection, PaddingParams, PaddingStrategy, Tokenizer, TruncationParams};
    (B[m use tracing::{debug, info, warn};
     
     // Подмодули
    Diff in /workspace/crates/ai/src/tokenization/mod.rs:57:
             let path_str = tokenizer_path.to_string_lossy();
             let model_name = if path_str.contains("qwen3") {
                 "qwen3"
    [31m-        } else if false { // legacy bge-m3 removed
    (B[m[32m+        } else if false {
    (B[m[32m+            // legacy bge-m3 removed
    (B[m             "bge-m3"
             } else {
                 "unknown"
    Diff in /workspace/crates/ai/tests/test_embeddings_gpu_advanced.rs:1:
     #[cfg(feature = "gpu")]
     use ai::embeddings_gpu::{GpuEmbeddingService, PerformanceMetrics};
    [32m+use ai::EmbeddingConfig;
    (B[m #[cfg(feature = "gpu")]
     use ai::GpuConfig;
    [31m-use ai::EmbeddingConfig;
    (B[m use anyhow::Result;
     
     #[cfg(feature = "gpu")]
    Diff in /workspace/crates/ai/tests/test_gpu_config.rs:69:
     #[test]
     fn test_gpu_memory_limits() {
         let memory_limits = vec![
    [31m-        512 * 1024 * 1024,  // 512MB
    (B[m[31m-        1 * 1024 * 1024 * 1024, // 1GB
    (B[m[31m-        2 * 1024 * 1024 * 1024, // 2GB
    (B[m[31m-        8 * 1024 * 1024 * 1024, // 8GB
    (B[m[32m+        512 * 1024 * 1024,       // 512MB
    (B[m[32m+        1 * 1024 * 1024 * 1024,  // 1GB
    (B[m[32m+        2 * 1024 * 1024 * 1024,  // 2GB
    (B[m[32m+        8 * 1024 * 1024 * 1024,  // 8GB
    (B[m         16 * 1024 * 1024 * 1024, // 16GB
         ];
     
    Diff in /workspace/crates/ai/tests/test_gpu_config.rs:165:
         // Provider creation simulation
         assert!(matches!(
             config.preferred_provider,
    [31m-        GpuProviderType::Auto | GpuProviderType::CUDA | GpuProviderType::DirectML | GpuProviderType::OpenVINO
    (B[m[32m+        GpuProviderType::Auto
    (B[m[32m+            | GpuProviderType::CUDA
    (B[m[32m+            | GpuProviderType::DirectML
    (B[m[32m+            | GpuProviderType::OpenVINO
    (B[m     ));
     }
     
    Diff in /workspace/crates/ai/tests/test_model_downloader_comprehensive.rs:5:
         path::{Path, PathBuf},
         sync::Arc,
     };
    [31m-use tokio::fs;
    (B[m use tempfile::TempDir;
    [32m+use tokio::fs;
    (B[m 
     // Mock для тестирования HTTP клиента
     // Убираем зависимости на внешние тестовые фреймворки (mockall, proptest, rstest, wiremock, serial_test)
    Diff in /workspace/crates/ai/tests/test_ort_setup.rs:1:
    [31m-#![cfg(all(feature = "embeddings", feature = "extended-tests", feature = "legacy-tests"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    feature = "embeddings",
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m 
     use ai::ort_setup::configure_ort_env;
     
    Diff in /workspace/crates/ai/tests/test_ort_setup.rs:18:
         configure_ort_env();
         // Either set or not set — both acceptable; main point is no panic
     }
    [32m+
    (B[mDiff in /workspace/crates/ai/tests/test_tokenizer_comprehensive.rs:1:
    [31m-#![cfg(all(feature = "embeddings", feature = "extended-tests", feature = "legacy-tests"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    feature = "embeddings",
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m 
     use ai::{
         errors::Result,
    Diff in /workspace/crates/cli/src/commands/gpu.rs:6:
     };
     use anyhow::Result;
     use clap::{Args, Subcommand};
    [31m-use tracing::{info, warn, error};
    (B[m[32m+use tracing::{error, info, warn};
    (B[m 
     #[derive(Debug, Args)]
     pub struct GpuCommand {
    Diff in /workspace/crates/cli/src/commands/memory.rs:2:
     use anyhow::{anyhow, Result};
     use clap::{Args, Subcommand};
     use colored::*;
    [31m-use memory::{default_config};
    (B[m[31m-use memory::api::{MemoryContext, UnifiedMemoryAPI, MemoryServiceTrait};
    (B[m[32m+use common::policy::{default_document, load_from_path, merge_documents, PolicyEngine};
    (B[m[32m+use common::{events, topics};
    (B[m[32m+use memory::api::{MemoryContext, MemoryServiceTrait, UnifiedMemoryAPI};
    (B[m[32m+use memory::default_config;
    (B[m use memory::di::core_traits::ServiceResolver;
     use memory::types::Layer;
     use prettytable::{row, Table};
    Diff in /workspace/crates/cli/src/commands/memory.rs:10:
     use std::path::PathBuf;
     use std::sync::Arc;
    [31m-use common::{events, topics};
    (B[m[31m-use common::policy::{default_document, load_from_path, merge_documents, PolicyEngine};
    (B[m 
     /// Команда для управления системой памяти
     #[derive(Debug, Args)]
    Diff in /workspace/crates/cli/src/commands/memory.rs:146:
         // Prepare effective policy for commands (env-json > env-path/file > default)
         let mut home = crate::util::magray_home();
         home.push("policy.json");
    [31m-    let effective = common::policy::load_effective_policy(if home.exists() { Some(&home) } else { None });
    (B[m[32m+    let effective =
    (B[m[32m+        common::policy::load_effective_policy(if home.exists() { Some(&home) } else { None });
    (B[m     let policy = PolicyEngine::from_document(effective);
     
         match cmd {
    Diff in /workspace/crates/cli/src/commands/memory.rs:153:
             MemorySubcommand::Stats { detailed } => {
    [31m-            tokio::spawn(events::publish(topics::TOPIC_INTENT, serde_json::json!({"command":"memory.stats","detailed":detailed })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_INTENT,
    (B[m[32m+                serde_json::json!({"command":"memory.stats","detailed":detailed }),
    (B[m[32m+            ));
    (B[m             show_memory_stats(&api, detailed).await?;
             }
     
    Diff in /workspace/crates/cli/src/commands/memory.rs:164:
                 hybrid,
             } => {
                 // intent event
    [31m-            tokio::spawn(events::publish(topics::TOPIC_INTENT, serde_json::json!({
    (B[m[31m-                "command": "memory.search", "query": query, "top_k": top_k, "rerank": rerank, "hybrid": hybrid
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_INTENT,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "command": "memory.search", "query": query, "top_k": top_k, "rerank": rerank, "hybrid": hybrid
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m             search_memory(&api, &query, layer, top_k, min_score, rerank, hybrid).await?;
             }
     
    Diff in /workspace/crates/cli/src/commands/memory.rs:176:
                 tags,
                 kind,
             } => {
    [31m-            tokio::spawn(events::publish(topics::TOPIC_INTENT, serde_json::json!({
    (B[m[31m-                "command": "memory.add", "layer": layer, "kind": kind
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_INTENT,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "command": "memory.add", "layer": layer, "kind": kind
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m             add_to_memory(&api, text, &layer, tags, &kind).await?;
             }
     
    Diff in /workspace/crates/cli/src/commands/memory.rs:185:
             MemorySubcommand::Backup { name } => {
                 // Check policy for command
    [31m-            let decision = policy.evaluate_command("memory.backup", &std::collections::HashMap::new());
    (B[m[32m+            let decision =
    (B[m[32m+                policy.evaluate_command("memory.backup", &std::collections::HashMap::new());
    (B[m             if !decision.allowed {
    [31m-                let reason = decision.matched_rule.and_then(|r| r.reason).unwrap_or_else(|| "blocked".into());
    (B[m[32m+                let reason = decision
    (B[m[32m+                    .matched_rule
    (B[m[32m+                    .and_then(|r| r.reason)
    (B[m[32m+                    .unwrap_or_else(|| "blocked".into());
    (B[m                 let evt = serde_json::json!({"command": "memory.backup", "reason": reason});
                     tokio::spawn(events::publish(topics::TOPIC_POLICY_BLOCK, evt));
                     anyhow::bail!("Command 'memory backup' blocked by policy");
    Diff in /workspace/crates/cli/src/commands/memory.rs:193:
                 }
                 if matches!(decision.action, common::policy::PolicyAction::Ask) {
    [31m-                let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[32m+                let non_interactive =
    (B[m[32m+                    std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m                 if non_interactive {
    [31m-                    tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.backup","error":"non-interactive ask"})));
    (B[m[32m+                    tokio::spawn(events::publish(
    (B[m[32m+                        topics::TOPIC_ERROR,
    (B[m[32m+                        serde_json::json!({"command":"memory.backup","error":"non-interactive ask"}),
    (B[m[32m+                    ));
    (B[m                     anyhow::bail!("Command 'memory backup' requires confirmation (ask), but running non-interactive");
                     }
    [31m-                let auto_approve = std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[32m+                let auto_approve =
    (B[m[32m+                    std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m                 if !auto_approve {
                         use std::io::{self, Write};
    [31m-                    println!("\nОперация backup может занять время. Риск: {:?}", decision.risk);
    (B[m[32m+                    println!(
    (B[m[32m+                        "\nОперация backup может занять время. Риск: {:?}",
    (B[m[32m+                        decision.risk
    (B[m[32m+                    );
    (B[m                     print!("Продолжить? [y/N]: ");
                         let _ = io::stdout().flush();
                         let mut answer = String::new();
    Diff in /workspace/crates/cli/src/commands/memory.rs:207:
    [31m-                    if io::stdin().read_line(&mut answer).is_err() { anyhow::bail!("confirmation failed"); }
    (B[m[32m+                    if io::stdin().read_line(&mut answer).is_err() {
    (B[m[32m+                        anyhow::bail!("confirmation failed");
    (B[m[32m+                    }
    (B[m                     let ans = answer.trim().to_lowercase();
                         if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") {
    [31m-                        tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.backup","error":"user-cancel"})));
    (B[m[32m+                        tokio::spawn(events::publish(
    (B[m[32m+                            topics::TOPIC_ERROR,
    (B[m[32m+                            serde_json::json!({"command":"memory.backup","error":"user-cancel"}),
    (B[m[32m+                        ));
    (B[m                         anyhow::bail!("Отменено пользователем");
                         }
                     }
    Diff in /workspace/crates/cli/src/commands/memory.rs:214:
                 }
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({"job":"memory.backup","status":"started"})));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({"job":"memory.backup","status":"started"}),
    (B[m[32m+            ));
    (B[m             create_backup(&api, name).await?;
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({
    (B[m[31m-                "job": "memory.backup", "status": "done"
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "job": "memory.backup", "status": "done"
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m         }
     
             MemorySubcommand::Restore { backup_path } => {
    Diff in /workspace/crates/cli/src/commands/memory.rs:223:
    [31m-            let decision = policy.evaluate_command("memory.restore", &std::collections::HashMap::new());
    (B[m[32m+            let decision =
    (B[m[32m+                policy.evaluate_command("memory.restore", &std::collections::HashMap::new());
    (B[m             if !decision.allowed {
    [31m-                let reason = decision.matched_rule.and_then(|r| r.reason).unwrap_or_else(|| "blocked".into());
    (B[m[32m+                let reason = decision
    (B[m[32m+                    .matched_rule
    (B[m[32m+                    .and_then(|r| r.reason)
    (B[m[32m+                    .unwrap_or_else(|| "blocked".into());
    (B[m                 let evt = serde_json::json!({"command": "memory.restore", "reason": reason});
                     tokio::spawn(events::publish(topics::TOPIC_POLICY_BLOCK, evt));
                     anyhow::bail!("Command 'memory restore' blocked by policy");
    Diff in /workspace/crates/cli/src/commands/memory.rs:229:
                 }
                 if matches!(decision.action, common::policy::PolicyAction::Ask) {
    [31m-                let auto_approve = std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[31m-                let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[32m+                let auto_approve =
    (B[m[32m+                    std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[32m+                let non_interactive =
    (B[m[32m+                    std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m                 if non_interactive && auto_approve {
                         // proceed silently
                     } else if non_interactive && !auto_approve {
    Diff in /workspace/crates/cli/src/commands/memory.rs:236:
    [31m-                    tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.restore","error":"non-interactive ask"})));
    (B[m[32m+                    tokio::spawn(events::publish(
    (B[m[32m+                        topics::TOPIC_ERROR,
    (B[m[32m+                        serde_json::json!({"command":"memory.restore","error":"non-interactive ask"}),
    (B[m[32m+                    ));
    (B[m                     anyhow::bail!("Command 'memory restore' requires confirmation (ask), but running non-interactive");
                     }
                     if !auto_approve {
    Diff in /workspace/crates/cli/src/commands/memory.rs:240:
                         use std::io::{self, Write};
    [31m-                    println!("\nОперация restore может перезаписать данные. Риск: {:?}", decision.risk);
    (B[m[32m+                    println!(
    (B[m[32m+                        "\nОперация restore может перезаписать данные. Риск: {:?}",
    (B[m[32m+                        decision.risk
    (B[m[32m+                    );
    (B[m                     print!("Продолжить? [y/N]: ");
                         let _ = io::stdout().flush();
                         let mut answer = String::new();
    Diff in /workspace/crates/cli/src/commands/memory.rs:245:
    [31m-                    if io::stdin().read_line(&mut answer).is_err() { anyhow::bail!("confirmation failed"); }
    (B[m[32m+                    if io::stdin().read_line(&mut answer).is_err() {
    (B[m[32m+                        anyhow::bail!("confirmation failed");
    (B[m[32m+                    }
    (B[m                     let ans = answer.trim().to_lowercase();
                         if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") {
    [31m-                        tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.restore","error":"user-cancel"})));
    (B[m[32m+                        tokio::spawn(events::publish(
    (B[m[32m+                            topics::TOPIC_ERROR,
    (B[m[32m+                            serde_json::json!({"command":"memory.restore","error":"user-cancel"}),
    (B[m[32m+                        ));
    (B[m                         anyhow::bail!("Отменено пользователем");
                         }
                     }
    Diff in /workspace/crates/cli/src/commands/memory.rs:252:
                 }
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({"job":"memory.restore","status":"started"})));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({"job":"memory.restore","status":"started"}),
    (B[m[32m+            ));
    (B[m             restore_backup(&api, backup_path).await?;
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({
    (B[m[31m-                "job": "memory.restore", "status": "done"
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "job": "memory.restore", "status": "done"
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m         }
     
             MemorySubcommand::ListBackups => {
    Diff in /workspace/crates/cli/src/commands/memory.rs:402:
             ..Default::default()
         };
     
    [31m-    if rerank { println!("{}", "[hint] Rerank enabled (Qwen3)".dimmed()); }
    (B[m[32m+    if rerank {
    (B[m[32m+        println!("{}", "[hint] Rerank enabled (Qwen3)".dimmed());
    (B[m[32m+    }
    (B[m     if hybrid {
             #[cfg(feature = "keyword-search")]
             println!("{}", "[hint] Hybrid (vector + BM25 keyword)".dimmed());
    Diff in /workspace/crates/cli/src/commands/memory.rs:409:
             #[cfg(not(feature = "keyword-search"))]
    [31m-        println!("{}", "[hint] Hybrid mode requested (vector-only fallback)".dimmed());
    (B[m[32m+        println!(
    (B[m[32m+            "{}",
    (B[m[32m+            "[hint] Hybrid mode requested (vector-only fallback)".dimmed()
    (B[m[32m+        );
    (B[m     }
     
         // Orchestrated path (if enabled) uses SearchCoordinator with optional rerank
    Diff in /workspace/crates/cli/src/commands/memory.rs:417:
             use memory::orchestration::SearchCoordinator;
             let container = memory::di::UnifiedContainer::new();
             if let Ok(search) = container.resolve::<SearchCoordinator>() {
    [31m-            let layer_to_use = options.layers.clone().and_then(|v| v.first().cloned()).unwrap_or(Layer::Interact);
    (B[m[31m-            let coord_opts = memory::types::SearchOptions { top_k, ..Default::default() };
    (B[m[32m+            let layer_to_use = options
    (B[m[32m+                .layers
    (B[m[32m+                .clone()
    (B[m[32m+                .and_then(|v| v.first().cloned())
    (B[m[32m+                .unwrap_or(Layer::Interact);
    (B[m[32m+            let coord_opts = memory::types::SearchOptions {
    (B[m[32m+                top_k,
    (B[m[32m+                ..Default::default()
    (B[m[32m+            };
    (B[m             let results = if rerank {
    [31m-                SearchCoordinatorTrait::search_with_rerank(&*search, query, layer_to_use, coord_opts, top_k).await?
    (B[m[32m+                SearchCoordinatorTrait::search_with_rerank(
    (B[m[32m+                    &*search,
    (B[m[32m+                    query,
    (B[m[32m+                    layer_to_use,
    (B[m[32m+                    coord_opts,
    (B[m[32m+                    top_k,
    (B[m[32m+                )
    (B[m[32m+                .await?
    (B[m             } else if hybrid {
                     // hybrid: text embedding first; in future accept vector input
    [31m-                SearchCoordinatorTrait::hybrid_search(&*search, query, None, layer_to_use, coord_opts).await?
    (B[m[32m+                SearchCoordinatorTrait::hybrid_search(
    (B[m[32m+                    &*search,
    (B[m[32m+                    query,
    (B[m[32m+                    None,
    (B[m[32m+                    layer_to_use,
    (B[m[32m+                    coord_opts,
    (B[m[32m+                )
    (B[m[32m+                .await?
    (B[m             } else {
                     SearchCoordinatorTrait::search(&*search, query, layer_to_use, coord_opts).await?
                 };
    Diff in /workspace/crates/cli/src/commands/memory.rs:453:
                 }
                 return Ok(());
             }
    [31m-        println!("{}", "[hint] Orchestrated search unavailable; falling back to unified API".dimmed());
    (B[m[32m+        println!(
    (B[m[32m+            "{}",
    (B[m[32m+            "[hint] Orchestrated search unavailable; falling back to unified API".dimmed()
    (B[m[32m+        );
    (B[m     }
     
         println!("{} '{}'...", "Searching for".cyan(), query.bold());
    Diff in /workspace/crates/cli/src/commands/memory.rs:538:
     async fn create_backup(api: &UnifiedMemoryAPI, name: Option<String>) -> Result<()> {
         let spinner = ProgressBuilder::backup("Creating memory backup...");
     
    [31m-    let backup_name = name.unwrap_or_else(|| format!("backup_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S")));
    (B[m[32m+    let backup_name = name
    (B[m[32m+        .unwrap_or_else(|| format!("backup_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S")));
    (B[m     let path = std::path::PathBuf::from("backups").join(backup_name);
     
    [31m-    match tokio::time::timeout(std::time::Duration::from_secs(30), api.backup_to_path(&path)).await {
    (B[m[32m+    match tokio::time::timeout(
    (B[m[32m+        std::time::Duration::from_secs(30),
    (B[m[32m+        api.backup_to_path(&path),
    (B[m[32m+    )
    (B[m[32m+    .await
    (B[m[32m+    {
    (B[m         Ok(Ok(count)) => {
                 spinner.finish_success(Some("Backup created successfully!"));
                 println!("{}: {}", "Path".cyan(), path.display());
    Diff in /workspace/crates/cli/src/commands/memory.rs:561:
     }
     
     async fn restore_backup(api: &UnifiedMemoryAPI, backup_path: PathBuf) -> Result<()> {
    [31m-    let file_name = backup_path.file_name().unwrap_or_default().to_string_lossy();
    (B[m[32m+    let file_name = backup_path
    (B[m[32m+        .file_name()
    (B[m[32m+        .unwrap_or_default()
    (B[m[32m+        .to_string_lossy();
    (B[m     let spinner = ProgressBuilder::backup(&format!("Restoring from backup: {file_name}"));
     
    [31m-    match tokio::time::timeout(std::time::Duration::from_secs(45), api.restore_from_path(&backup_path)).await {
    (B[m[32m+    match tokio::time::timeout(
    (B[m[32m+        std::time::Duration::from_secs(45),
    (B[m[32m+        api.restore_from_path(&backup_path),
    (B[m[32m+    )
    (B[m[32m+    .await
    (B[m[32m+    {
    (B[m         Ok(Ok(inserted)) => {
                 spinner.finish_success(Some("Restore completed!"));
                 println!("{}: {}", "Path".cyan(), backup_path.display());
    Diff in /workspace/crates/cli/src/commands/memory.rs:574:
                 // Treat invalid/missing file as no-op restore for better UX in env-policy tests
                 spinner.finish_success(Some("Restore completed (no data)"));
                 println!("{}: {}", "Path".cyan(), backup_path.display());
    [31m-            println!("{}", "No records restored (empty or invalid backup)".yellow());
    (B[m[32m+            println!(
    (B[m[32m+                "{}",
    (B[m[32m+                "No records restored (empty or invalid backup)".yellow()
    (B[m[32m+            );
    (B[m         }
             Err(_) => {
                 spinner.finish_error("Restore timeout");
    Diff in /workspace/crates/cli/src/commands/memory.rs:586:
     }
     
     fn list_backups(_api: &UnifiedMemoryAPI) -> Result<()> {
    [31m-    use std::fs; use std::path::PathBuf;
    (B[m[32m+    use std::fs;
    (B[m[32m+    use std::path::PathBuf;
    (B[m     let dir = PathBuf::from("backups");
         println!("{}", "Available backups:".bold());
         if let Ok(read) = fs::read_dir(&dir) {
    Diff in /workspace/crates/cli/src/commands/memory.rs:593:
             let mut any = false;
             for e in read.flatten() {
    [31m-            if let Ok(ft) = e.file_type() { if ft.is_file() { println!("- {}", e.path().display()); any = true; } }
    (B[m[32m+            if let Ok(ft) = e.file_type() {
    (B[m[32m+                if ft.is_file() {
    (B[m[32m+                    println!("- {}", e.path().display());
    (B[m[32m+                    any = true;
    (B[m[32m+                }
    (B[m[32m+            }
    (B[m         }
    [31m-        if !any { println!("{}", "(no backups)".dimmed()); }
    (B[m[32m+        if !any {
    (B[m[32m+            println!("{}", "(no backups)".dimmed());
    (B[m[32m+        }
    (B[m     } else {
             println!("{}", "(directory 'backups' not found)".dimmed());
         }
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:36:
     }
     
     impl MemoryCommand {
    [31m-    pub async fn execute(self) -> Result<()> { handle(self.command).await }
    (B[m[32m+    pub async fn execute(self) -> Result<()> {
    (B[m[32m+        handle(self.command).await
    (B[m[32m+    }
    (B[m }
     
     async fn handle(cmd: MemorySubcommand) -> Result<()> {
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:52:
                 let results = svc.search(&query, top_k).await?;
                 println!("{} Результатов: {}", "🔎".yellow(), results.len());
                 for (i, rec) in results.iter().enumerate() {
    [31m-                println!("{} {} {}", format!("{}.", i + 1).bold(), rec.id, rec.created_ms);
    (B[m[31m-                if !rec.tags.is_empty() { println!("   tags: {:?}", rec.tags); }
    (B[m[32m+                println!(
    (B[m[32m+                    "{} {} {}",
    (B[m[32m+                    format!("{}.", i + 1).bold(),
    (B[m[32m+                    rec.id,
    (B[m[32m+                    rec.created_ms
    (B[m[32m+                );
    (B[m[32m+                if !rec.tags.is_empty() {
    (B[m[32m+                    println!("   tags: {:?}", rec.tags);
    (B[m[32m+                }
    (B[m                 println!("   {}", rec.text);
                 }
             }
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:60:
             MemorySubcommand::Stats => {
                 let h = svc.check_health().await?;
    [31m-            println!("{} healthy={}, records={}", "Σ".yellow(), h.healthy, h.records);
    (B[m[32m+            println!(
    (B[m[32m+                "{} healthy={}, records={}",
    (B[m[32m+                "Σ".yellow(),
    (B[m[32m+                h.healthy,
    (B[m[32m+                h.records
    (B[m[32m+            );
    (B[m         }
         }
         Ok(())
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:66:
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/mod.rs:4:
     #[cfg(feature = "minimal")]
     pub mod memory_stub;
     pub mod models;
    [31m-pub mod tools;
    (B[m pub mod smart;
     pub mod tasks;
    [32m+pub mod tools;
    (B[m 
     pub use gpu::GpuCommand;
     #[cfg(not(feature = "minimal"))]
    Diff in /workspace/crates/cli/src/commands/mod.rs:14:
     #[cfg(feature = "minimal")]
     pub use memory_stub::MemoryCommand;
     pub use models::ModelsCommand;
    [31m-pub use tools::ToolsCommand;
    (B[m pub use smart::SmartCommand;
     pub use tasks::TasksCommand;
    [32m+pub use tools::ToolsCommand;
    (B[m 
    Diff in /workspace/crates/cli/src/commands/smart.rs:1:
     use anyhow::{anyhow, Result};
    [32m+use async_trait::async_trait;
    (B[m use clap::Args;
     use colored::*;
     use domain::orchestrator::{Executor, Goal, Orchestrator, Plan, Planner, StepResult, StepStatus};
    Diff in /workspace/crates/cli/src/commands/smart.rs:5:
    [31m-use async_trait::async_trait;
    (B[m[31m-use tools::{Tool, ToolInput, ToolOutput, ToolRegistry};
    (B[m use std::collections::HashMap;
    [31m-use todo::{TodoService, Priority, TaskState, TodoItem, create_default_service};
    (B[m[31m-use std::path::PathBuf;
    (B[m use std::fs;
    [32m+use std::path::PathBuf;
    (B[m[32m+use todo::{create_default_service, Priority, TaskState, TodoItem, TodoService};
    (B[m[32m+use tools::{Tool, ToolInput, ToolOutput, ToolRegistry};
    (B[m 
     #[derive(Debug)]
     struct SimplePlanner;
    Diff in /workspace/crates/cli/src/commands/smart.rs:62:
                         if !out.result.trim().is_empty() {
                             if let Ok(path) = save_text_artifact(&task.id, &out.result) {
                                 let mut meta = std::collections::HashMap::new();
    [31m-                            meta.insert("artifact_path".to_string(), serde_json::json!(path.to_string_lossy()));
    (B[m[31m-                            meta.insert("tool".to_string(), serde_json::json!(step.tool_hint.clone().unwrap_or_else(|| "auto".to_string())));
    (B[m[32m+                            meta.insert(
    (B[m[32m+                                "artifact_path".to_string(),
    (B[m[32m+                                serde_json::json!(path.to_string_lossy()),
    (B[m[32m+                            );
    (B[m[32m+                            meta.insert(
    (B[m[32m+                                "tool".to_string(),
    (B[m[32m+                                serde_json::json!(step
    (B[m[32m+                                    .tool_hint
    (B[m[32m+                                    .clone()
    (B[m[32m+                                    .unwrap_or_else(|| "auto".to_string())),
    (B[m[32m+                            );
    (B[m                             todo_service.upsert_metadata(&task.id, meta).await.ok();
                             }
                         }
    Diff in /workspace/crates/cli/src/commands/smart.rs:79:
                         let mut meta = std::collections::HashMap::new();
                         meta.insert("error".to_string(), serde_json::json!(e.to_string()));
                         todo_service.upsert_metadata(&task.id, meta).await.ok();
    [31m-                    todo_service.update_state(&task.id, TaskState::Failed).await?;
    (B[m[32m+                    todo_service
    (B[m[32m+                        .update_state(&task.id, TaskState::Failed)
    (B[m[32m+                        .await?;
    (B[m                     results.push(StepResult {
                             step_id: step.id.clone(),
    [31m-                        status: StepStatus::Failed { error: e.to_string() },
    (B[m[32m+                        status: StepStatus::Failed {
    (B[m[32m+                            error: e.to_string(),
    (B[m[32m+                        },
    (B[m                         output: None,
                             artifacts: vec![],
                         })
    Diff in /workspace/crates/cli/src/commands/smart.rs:110:
         let mut path = dir;
         path.push(format!("{}.txt", task_id));
         // Ограничим размер до ~64KB
    [31m-    let truncated = if text.len() > 64 * 1024 { &text[..64 * 1024] } else { text };
    (B[m[32m+    let truncated = if text.len() > 64 * 1024 {
    (B[m[32m+        &text[..64 * 1024]
    (B[m[32m+    } else {
    (B[m[32m+        text
    (B[m[32m+    };
    (B[m     fs::write(&path, truncated)?;
         Ok(path)
     }
    Diff in /workspace/crates/cli/src/commands/smart.rs:126:
     }
     
     #[async_trait]
    [31m-impl<P: Planner + Send + Sync, E: Executor + Send + Sync> Orchestrator for SimpleOrchestrator<P, E> {
    (B[m[32m+impl<P: Planner + Send + Sync, E: Executor + Send + Sync> Orchestrator
    (B[m[32m+    for SimpleOrchestrator<P, E>
    (B[m[32m+{
    (B[m     async fn plan(&self, goal: Goal) -> Result<Plan> {
             self.planner.create_plan(&goal).await
         }
    Diff in /workspace/crates/cli/src/commands/smart.rs:166:
         }
     
         let results = orchestrator.run(plan).await?;
    [31m-    println!("{} Выполнение завершено: {} шаг(ов)", "✓".green(), results.len());
    (B[m[32m+    println!(
    (B[m[32m+        "{} Выполнение завершено: {} шаг(ов)",
    (B[m[32m+        "✓".green(),
    (B[m[32m+        results.len()
    (B[m[32m+    );
    (B[m     for r in results {
             println!("  • {}: {:?}", r.step_id.bold(), r.status);
             if let Some(out) = r.output {
    Diff in /workspace/crates/cli/src/commands/smart.rs:173:
    [31m-            if !out.trim().is_empty() { println!("{}", out); }
    (B[m[32m+            if !out.trim().is_empty() {
    (B[m[32m+                println!("{}", out);
    (B[m[32m+            }
    (B[m         }
         }
     
    Diff in /workspace/crates/cli/src/commands/smart.rs:184:
         {
             return Some("file_read".to_string());
         }
    [31m-    if lower.contains("создай файл") || lower.contains("write") || lower.contains("запиши в файл") {
    (B[m[32m+    if lower.contains("создай файл") || lower.contains("write") || lower.contains("запиши в файл")
    (B[m[32m+    {
    (B[m         return Some("file_write".to_string());
         }
    [31m-    if lower.contains("папк") || lower.contains("директор") || lower.contains("list dir") || lower.contains("ls ") {
    (B[m[32m+    if lower.contains("папк")
    (B[m[32m+        || lower.contains("директор")
    (B[m[32m+        || lower.contains("list dir")
    (B[m[32m+        || lower.contains("ls ")
    (B[m[32m+    {
    (B[m         return Some("dir_list".to_string());
         }
         if lower.contains("git diff") || lower.contains("показать diff") {
    Diff in /workspace/crates/cli/src/commands/smart.rs:199:
         if lower.contains("git commit") || lower.contains("коммит") {
             return Some("git_commit".to_string());
         }
    [31m-    if lower.starts_with("выполни") || lower.contains("выполни команду") || lower.starts_with("exec") || lower.starts_with("run ") {
    (B[m[32m+    if lower.starts_with("выполни")
    (B[m[32m+        || lower.contains("выполни команду")
    (B[m[32m+        || lower.starts_with("exec")
    (B[m[32m+        || lower.starts_with("run ")
    (B[m[32m+    {
    (B[m         return Some("shell_exec".to_string());
         }
         if lower.contains("найди ") || lower.contains("поиск ") || lower.contains("search ") {
    Diff in /workspace/crates/cli/src/commands/smart.rs:209:
     }
     
     fn looks_like_path(text: &str) -> bool {
    [31m-    text.contains('/') || text.contains('\\') || text.contains(".rs") || text.contains(".md") || text.contains(".toml")
    (B[m[32m+    text.contains('/')
    (B[m[32m+        || text.contains('\\')
    (B[m[32m+        || text.contains(".rs")
    (B[m[32m+        || text.contains(".md")
    (B[m[32m+        || text.contains(".toml")
    (B[m }
     
    [31m-async fn execute_step(registry: &ToolRegistry, description: &str, hint: Option<String>) -> Result<ToolOutput> {
    (B[m[32m+async fn execute_step(
    (B[m[32m+    registry: &ToolRegistry,
    (B[m[32m+    description: &str,
    (B[m[32m+    hint: Option<String>,
    (B[m[32m+) -> Result<ToolOutput> {
    (B[m     if let Some(name) = hint {
             if let Some(tool) = registry.get(&name) {
                 // Попробуем использовать парсер NL, иначе отправим пустые args
    Diff in /workspace/crates/cli/src/commands/smart.rs:219:
                 let input = if tool.supports_natural_language() {
                     match tool.parse_natural_language(description).await {
    [31m-                    Ok(mut i) => { i.dry_run = false; i.timeout_ms = None; i },
    (B[m[31m-                    Err(_) => ToolInput { command: name.clone(), args: HashMap::new(), context: Some(description.to_string()), dry_run: false, timeout_ms: None },
    (B[m[32m+                    Ok(mut i) => {
    (B[m[32m+                        i.dry_run = false;
    (B[m[32m+                        i.timeout_ms = None;
    (B[m[32m+                        i
    (B[m[32m+                    }
    (B[m[32m+                    Err(_) => ToolInput {
    (B[m[32m+                        command: name.clone(),
    (B[m[32m+                        args: HashMap::new(),
    (B[m[32m+                        context: Some(description.to_string()),
    (B[m[32m+                        dry_run: false,
    (B[m[32m+                        timeout_ms: None,
    (B[m[32m+                    },
    (B[m                 }
                 } else {
    [31m-                ToolInput { command: name.clone(), args: HashMap::new(), context: Some(description.to_string()), dry_run: false, timeout_ms: None }
    (B[m[32m+                ToolInput {
    (B[m[32m+                    command: name.clone(),
    (B[m[32m+                    args: HashMap::new(),
    (B[m[32m+                    context: Some(description.to_string()),
    (B[m[32m+                    dry_run: false,
    (B[m[32m+                    timeout_ms: None,
    (B[m[32m+                }
    (B[m             };
                 return tool.execute(input).await;
             } else {
    Diff in /workspace/crates/cli/src/commands/smart.rs:232:
     
         // Автовыбор: пробуем набор инструментов в приоритетном порядке
         let candidates = [
    [31m-        "file_read", "file_write", "dir_list", "git_status", "git_diff", "git_commit", "shell_exec", "web_search",
    (B[m[32m+        "file_read",
    (B[m[32m+        "file_write",
    (B[m[32m+        "dir_list",
    (B[m[32m+        "git_status",
    (B[m[32m+        "git_diff",
    (B[m[32m+        "git_commit",
    (B[m[32m+        "shell_exec",
    (B[m[32m+        "web_search",
    (B[m     ];
     
         for name in candidates {
    Diff in /workspace/crates/cli/src/commands/smart.rs:239:
             if let Some(tool) = registry.get(name) {
    [31m-            if !tool.supports_natural_language() { continue; }
    (B[m[32m+            if !tool.supports_natural_language() {
    (B[m[32m+                continue;
    (B[m[32m+            }
    (B[m             if let Ok(input) = tool.parse_natural_language(description).await {
                     // Если парсер выдал какие‑то аргументы — пробуем исполнить
                     if !input.args.is_empty() || input.context.is_some() {
    Diff in /workspace/crates/cli/src/commands/smart.rs:249:
     
         Err(anyhow!("Не удалось подобрать инструмент для шага"))
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/tasks.rs:13:
     pub enum TasksSubcommand {
         /// Показать N готовых задач
         #[command(name = "list")]
    [31m-    List { #[arg(long, default_value_t = 20)] limit: usize },
    (B[m[32m+    List {
    (B[m[32m+        #[arg(long, default_value_t = 20)]
    (B[m[32m+        limit: usize,
    (B[m[32m+    },
    (B[m     /// Показать задачу по ID
         #[command(name = "show")]
         Show { id: String },
    Diff in /workspace/crates/cli/src/commands/tasks.rs:29:
     }
     
     impl TasksCommand {
    [31m-    pub async fn execute(self) -> Result<()> { handle(self.command).await }
    (B[m[32m+    pub async fn execute(self) -> Result<()> {
    (B[m[32m+        handle(self.command).await
    (B[m[32m+    }
    (B[m }
     
     async fn handle(cmd: TasksSubcommand) -> Result<()> {
    Diff in /workspace/crates/cli/src/commands/tasks.rs:39:
         match cmd {
             TasksSubcommand::List { limit } => {
                 let tasks = svc.get_next_ready(limit).await?;
    [31m-            println!("{} {}", "✓".green(), format!("Готовые задачи: {}", tasks.len()).bold());
    (B[m[32m+            println!(
    (B[m[32m+                "{} {}",
    (B[m[32m+                "✓".green(),
    (B[m[32m+                format!("Готовые задачи: {}", tasks.len()).bold()
    (B[m[32m+            );
    (B[m             for t in tasks {
    [31m-                println!("- {} {} [{}]", t.id, t.title.bold(), format!("{:?}", t.priority).to_lowercase());
    (B[m[32m+                println!(
    (B[m[32m+                    "- {} {} [{}]",
    (B[m[32m+                    t.id,
    (B[m[32m+                    t.title.bold(),
    (B[m[32m+                    format!("{:?}", t.priority).to_lowercase()
    (B[m[32m+                );
    (B[m             }
             }
             TasksSubcommand::Show { id } => {
    Diff in /workspace/crates/cli/src/commands/tasks.rs:52:
                     println!("  state: {:?}", t.state);
                     println!("  created: {}", t.created_at);
                     println!("  updated: {}", t.updated_at);
    [31m-                if let Some(r) = &t.reasoning { println!("  reasoning: {}", r); }
    (B[m[31m-                if let Some(tool) = &t.tool_hint { println!("  tool_hint: {}", tool); }
    (B[m[32m+                if let Some(r) = &t.reasoning {
    (B[m[32m+                    println!("  reasoning: {}", r);
    (B[m[32m+                }
    (B[m[32m+                if let Some(tool) = &t.tool_hint {
    (B[m[32m+                    println!("  tool_hint: {}", tool);
    (B[m[32m+                }
    (B[m             } else {
                     println!("{} Задача не найдена", "✗".red());
                 }
    Diff in /workspace/crates/cli/src/commands/tasks.rs:72:
                 let (task_stats, graph_stats) = svc.get_stats().await?;
                 println!("{} Статистика задач", "Σ".yellow());
                 println!("  total: {}", task_stats.total);
    [31m-            println!("  ready: {}  in_progress: {}  blocked: {}",
    (B[m[31m-                     task_stats.ready, task_stats.in_progress, task_stats.blocked);
    (B[m[31m-            println!("  done: {}  failed: {}  cancelled: {}",
    (B[m[31m-                     task_stats.done, task_stats.failed, task_stats.cancelled);
    (B[m[31m-            println!("{} Граф: total_tasks={}, total_deps={}, cache_entries={}",
    (B[m[31m-                     "ℹ".blue(), graph_stats.total_tasks, graph_stats.total_dependencies, graph_stats.cache_size);
    (B[m[32m+            println!(
    (B[m[32m+                "  ready: {}  in_progress: {}  blocked: {}",
    (B[m[32m+                task_stats.ready, task_stats.in_progress, task_stats.blocked
    (B[m[32m+            );
    (B[m[32m+            println!(
    (B[m[32m+                "  done: {}  failed: {}  cancelled: {}",
    (B[m[32m+                task_stats.done, task_stats.failed, task_stats.cancelled
    (B[m[32m+            );
    (B[m[32m+            println!(
    (B[m[32m+                "{} Граф: total_tasks={}, total_deps={}, cache_entries={}",
    (B[m[32m+                "ℹ".blue(),
    (B[m[32m+                graph_stats.total_tasks,
    (B[m[32m+                graph_stats.total_dependencies,
    (B[m[32m+                graph_stats.cache_size
    (B[m[32m+            );
    (B[m         }
         }
         Ok(())
    Diff in /workspace/crates/cli/src/commands/tasks.rs:84:
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/tools.rs:1:
     use anyhow::Result;
     use clap::{Args, Subcommand};
     use colored::*;
    [31m-use tools::ToolRegistry;
    (B[m[32m+use common::policy::{
    (B[m[32m+    load_effective_policy, PolicyAction, PolicyDocument, PolicyEngine, PolicyRule,
    (B[m[32m+    PolicySubjectKind,
    (B[m[32m+};
    (B[m[32m+use common::{events, topics};
    (B[m use serde::{Deserialize, Serialize};
     use std::fs;
    [31m-use common::{events, topics};
    (B[m[31m-use common::policy::{PolicyDocument, PolicyEngine, PolicyRule, PolicySubjectKind, PolicyAction, load_effective_policy};
    (B[m[31m-use tools::intelligent_selector::{IntelligentToolSelector, SelectorConfig, ToolSelectionContext, TaskComplexity, UrgencyLevel, UserExpertise};
    (B[m[32m+use tools::intelligent_selector::{
    (B[m[32m+    IntelligentToolSelector, SelectorConfig, TaskComplexity, ToolSelectionContext, UrgencyLevel,
    (B[m[32m+    UserExpertise,
    (B[m[32m+};
    (B[m[32m+use tools::ToolRegistry;
    (B[m 
     #[derive(Debug, Serialize, Deserialize, Clone)]
     struct McpToolConfig {
    Diff in /workspace/crates/cli/src/commands/tools.rs:50:
     
     fn preload_persisted_into_registry(registry: &mut ToolRegistry) {
         for cfg in load_persisted_mcp() {
    [31m-        registry.register_mcp_tool(&cfg.name, cfg.cmd.clone(), cfg.args.clone(), cfg.remote_tool.clone(), cfg.description.clone());
    (B[m[32m+        registry.register_mcp_tool(
    (B[m[32m+            &cfg.name,
    (B[m[32m+            cfg.cmd.clone(),
    (B[m[32m+            cfg.args.clone(),
    (B[m[32m+            cfg.remote_tool.clone(),
    (B[m[32m+            cfg.description.clone(),
    (B[m[32m+        );
    (B[m     }
     }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:61:
             if let Ok(content) = fs::read_to_string(path) {
                 if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                     if let Some(obj) = json.as_object() {
    [31m-                    for (k, v) in obj { map.insert(k.clone(), v.clone()); }
    (B[m[32m+                    for (k, v) in obj {
    (B[m[32m+                        map.insert(k.clone(), v.clone());
    (B[m[32m+                    }
    (B[m                 }
                 }
             }
    Diff in /workspace/crates/cli/src/commands/tools.rs:70:
             if !json_str.trim().is_empty() {
                 if let Ok(json) = serde_json::from_str::<serde_json::Value>(&json_str) {
                     if let Some(obj) = json.as_object() {
    [31m-                    for (k, v) in obj { map.insert(k.clone(), v.clone()); }
    (B[m[32m+                    for (k, v) in obj {
    (B[m[32m+                        map.insert(k.clone(), v.clone());
    (B[m[32m+                    }
    (B[m                 }
                 }
             }
    Diff in /workspace/crates/cli/src/commands/tools.rs:80:
     
     fn apply_usage_guide_override(spec: &mut tools::ToolSpec, override_v: &serde_json::Value) {
         // Merge only known fields; create UsageGuide if absent
    [31m-    let mut guide = spec.usage_guide.clone().unwrap_or_else(|| tools::generate_usage_guide(spec));
    (B[m[32m+    let mut guide = spec
    (B[m[32m+        .usage_guide
    (B[m[32m+        .clone()
    (B[m[32m+        .unwrap_or_else(|| tools::generate_usage_guide(spec));
    (B[m     if let Some(obj) = override_v.as_object() {
    [31m-        if let Some(v) = obj.get("usage_title").and_then(|v| v.as_str()) { guide.usage_title = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("usage_summary").and_then(|v| v.as_str()) { guide.usage_summary = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("preconditions").and_then(|v| v.as_array()) { guide.preconditions = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[32m+        if let Some(v) = obj.get("usage_title").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.usage_title = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("usage_summary").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.usage_summary = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("preconditions").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.preconditions = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m         if let Some(v) = obj.get("arguments_brief").and_then(|v| v.as_object()) {
                 let mut ab = std::collections::HashMap::new();
    [31m-            for (k, val) in v { if let Some(s) = val.as_str() { ab.insert(k.clone(), s.to_string()); } }
    (B[m[32m+            for (k, val) in v {
    (B[m[32m+                if let Some(s) = val.as_str() {
    (B[m[32m+                    ab.insert(k.clone(), s.to_string());
    (B[m[32m+                }
    (B[m[32m+            }
    (B[m             guide.arguments_brief = ab;
             }
    [31m-        if let Some(v) = obj.get("good_for").and_then(|v| v.as_array()) { guide.good_for = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("not_for").and_then(|v| v.as_array()) { guide.not_for = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("constraints").and_then(|v| v.as_array()) { guide.constraints = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("examples").and_then(|v| v.as_array()) { guide.examples = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("platforms").and_then(|v| v.as_array()) { guide.platforms = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("cost_class").and_then(|v| v.as_str()) { guide.cost_class = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("latency_class").and_then(|v| v.as_str()) { guide.latency_class = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("side_effects").and_then(|v| v.as_array()) { guide.side_effects = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("risk_score").and_then(|v| v.as_u64()) { guide.risk_score = v as u8; }
    (B[m[31m-        if let Some(v) = obj.get("capabilities").and_then(|v| v.as_array()) { guide.capabilities = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("tags").and_then(|v| v.as_array()) { guide.tags = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[32m+        if let Some(v) = obj.get("good_for").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.good_for = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("not_for").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.not_for = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("constraints").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.constraints = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("examples").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.examples = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("platforms").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.platforms = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("cost_class").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.cost_class = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("latency_class").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.latency_class = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("side_effects").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.side_effects = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("risk_score").and_then(|v| v.as_u64()) {
    (B[m[32m+            guide.risk_score = v as u8;
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("capabilities").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.capabilities = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("tags").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.tags = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m     }
         spec.usage_guide = Some(guide);
     }
    Diff in /workspace/crates/cli/src/commands/tools.rs:107:
     
    [31m-fn map_plugin_perms_to_tools_permissions(p: &tools::registry::ToolPermissions) -> Option<tools::ToolPermissions> {
    (B[m[32m+fn map_plugin_perms_to_tools_permissions(
    (B[m[32m+    p: &tools::registry::ToolPermissions,
    (B[m[32m+) -> Option<tools::ToolPermissions> {
    (B[m     use tools::registry::{FileSystemPermissions, NetworkPermissions};
         let mut fs_read = Vec::new();
         let mut fs_write = Vec::new();
    Diff in /workspace/crates/cli/src/commands/tools.rs:112:
         match &p.file_system {
             FileSystemPermissions::None => {}
    [31m-        FileSystemPermissions::ReadOnly => { fs_read.push("/".into()); }
    (B[m[31m-        FileSystemPermissions::ReadWrite | FileSystemPermissions::FullAccess => { fs_read.push("/".into()); fs_write.push("/".into()); }
    (B[m[32m+        FileSystemPermissions::ReadOnly => {
    (B[m[32m+            fs_read.push("/".into());
    (B[m[32m+        }
    (B[m[32m+        FileSystemPermissions::ReadWrite | FileSystemPermissions::FullAccess => {
    (B[m[32m+            fs_read.push("/".into());
    (B[m[32m+            fs_write.push("/".into());
    (B[m[32m+        }
    (B[m         FileSystemPermissions::Restricted { allowed_paths } => {
    [31m-            for ap in allowed_paths { fs_read.push(ap.clone()); fs_write.push(ap.clone()); }
    (B[m[32m+            for ap in allowed_paths {
    (B[m[32m+                fs_read.push(ap.clone());
    (B[m[32m+                fs_write.push(ap.clone());
    (B[m[32m+            }
    (B[m         }
         }
         let mut net = Vec::new();
    Diff in /workspace/crates/cli/src/commands/tools.rs:121:
         match &p.network {
             NetworkPermissions::None => {}
    [31m-        NetworkPermissions::LocalHost => { net.push("localhost".into()); net.push("127.0.0.1".into()); }
    (B[m[32m+        NetworkPermissions::LocalHost => {
    (B[m[32m+            net.push("localhost".into());
    (B[m[32m+            net.push("127.0.0.1".into());
    (B[m[32m+        }
    (B[m         NetworkPermissions::InternalNetworks => { /* keep empty to enforce env allowlist */ }
             NetworkPermissions::Internet => { /* empty -> allow by env */ }
    [31m-        NetworkPermissions::Restricted { allowed_hosts } => { for h in allowed_hosts { net.push(h.clone()); } }
    (B[m[32m+        NetworkPermissions::Restricted { allowed_hosts } => {
    (B[m[32m+            for h in allowed_hosts {
    (B[m[32m+                net.push(h.clone());
    (B[m[32m+            }
    (B[m[32m+        }
    (B[m     }
    [31m-    Some(tools::ToolPermissions { fs_read_roots: fs_read, fs_write_roots: fs_write, net_allowlist: net, allow_shell: false })
    (B[m[32m+    Some(tools::ToolPermissions {
    (B[m[32m+        fs_read_roots: fs_read,
    (B[m[32m+        fs_write_roots: fs_write,
    (B[m[32m+        net_allowlist: net,
    (B[m[32m+        allow_shell: false,
    (B[m[32m+    })
    (B[m }
     
     #[derive(Debug, Args)]
    Diff in /workspace/crates/cli/src/commands/tools.rs:248:
     }
     
     impl ToolsCommand {
    [31m-    pub async fn execute(self) -> Result<()> { handle_tools_command(self.command).await }
    (B[m[32m+    pub async fn execute(self) -> Result<()> {
    (B[m[32m+        handle_tools_command(self.command).await
    (B[m[32m+    }
    (B[m }
     
     fn parse_kv(s: &str) -> Result<(String, String), String> {
    Diff in /workspace/crates/cli/src/commands/tools.rs:255:
    [31m-    let (k, v) = s.split_once('=').ok_or_else(|| "arg must be in key=value format".to_string())?;
    (B[m[32m+    let (k, v) = s
    (B[m[32m+        .split_once('=')
    (B[m[32m+        .ok_or_else(|| "arg must be in key=value format".to_string())?;
    (B[m     Ok((k.to_string(), v.to_string()))
     }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:263:
     
         // Helper: export plugins into registry (quiet; best-effort)
         async fn export_plugins_into_registry(registry: &mut ToolRegistry) {
    [31m-        if std::env::var("MAGRAY_EXPORT_PLUGINS_AS_TOOLS").ok().map(|s| s=="1" || s.to_lowercase()=="true").unwrap_or(true) {
    (B[m[32m+        if std::env::var("MAGRAY_EXPORT_PLUGINS_AS_TOOLS")
    (B[m[32m+            .ok()
    (B[m[32m+            .map(|s| s == "1" || s.to_lowercase() == "true")
    (B[m[32m+            .unwrap_or(true)
    (B[m[32m+        {
    (B[m             let mut home = crate::util::magray_home();
    [31m-            let mut plugins_dir = home.clone(); plugins_dir.push("plugins");
    (B[m[31m-            let mut cfg_dir = home.clone(); cfg_dir.push("plugin-configs");
    (B[m[32m+            let mut plugins_dir = home.clone();
    (B[m[32m+            plugins_dir.push("plugins");
    (B[m[32m+            let mut cfg_dir = home.clone();
    (B[m[32m+            cfg_dir.push("plugin-configs");
    (B[m             let _ = tokio::fs::create_dir_all(&plugins_dir).await;
                 let _ = tokio::fs::create_dir_all(&cfg_dir).await;
    [31m-            let pregistry = tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m[32m+            let pregistry =
    (B[m[32m+                tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m             let _ = pregistry.load_manifests_from_directory().await;
                 let _ = pregistry.load_from_filesystem().await;
                 let plugins = pregistry.list_plugins(None).await;
    Diff in /workspace/crates/cli/src/commands/tools.rs:276:
                 for p in plugins {
    [31m-                if matches!(p.plugin_type, tools::plugins::plugin_manager::PluginType::Wasm | tools::plugins::plugin_manager::PluginType::ExternalProcess) {
    (B[m[32m+                if matches!(
    (B[m[32m+                    p.plugin_type,
    (B[m[32m+                    tools::plugins::plugin_manager::PluginType::Wasm
    (B[m[32m+                        | tools::plugins::plugin_manager::PluginType::ExternalProcess
    (B[m[32m+                ) {
    (B[m                     if let Ok(tool_box) = pregistry.materialize_as_tool(&p.id).await {
                             registry.register(&p.id, tool_box);
                         }
    Diff in /workspace/crates/cli/src/commands/tools.rs:292:
                 let mut specs = registry.list_tools();
                 // Apply overrides
                 for spec in &mut specs {
    [31m-                if let Some(ov) = guide_overrides.get(&spec.name) { apply_usage_guide_override(spec, ov); }
    (B[m[32m+                if let Some(ov) = guide_overrides.get(&spec.name) {
    (B[m[32m+                    apply_usage_guide_override(spec, ov);
    (B[m[32m+                }
    (B[m             }
                 if json {
                     println!("{}", serde_json::to_string_pretty(&specs)?);
    Diff in /workspace/crates/cli/src/commands/tools.rs:302:
                 if details {
                     // Effective sandbox summary from env (centralized)
                     let cfg = common::sandbox_config::SandboxConfig::from_env();
    [31m-                println!("  FS sandbox: {}  roots: {}", if cfg.fs.enabled { "on" } else { "off" }, if cfg.fs.roots.is_empty() { "<none>" } else { &cfg.fs.roots.join(":") });
    (B[m[31m-                let net = if cfg.net.allowlist.is_empty() { "<none>".to_string() } else { cfg.net.allowlist.join(",") };
    (B[m[32m+                println!(
    (B[m[32m+                    "  FS sandbox: {}  roots: {}",
    (B[m[32m+                    if cfg.fs.enabled { "on" } else { "off" },
    (B[m[32m+                    if cfg.fs.roots.is_empty() {
    (B[m[32m+                        "<none>"
    (B[m[32m+                    } else {
    (B[m[32m+                        &cfg.fs.roots.join(":")
    (B[m[32m+                    }
    (B[m[32m+                );
    (B[m[32m+                let net = if cfg.net.allowlist.is_empty() {
    (B[m[32m+                    "<none>".to_string()
    (B[m[32m+                } else {
    (B[m[32m+                    cfg.net.allowlist.join(",")
    (B[m[32m+                };
    (B[m                 println!("  NET allow: {}", net);
    [31m-                println!("  SHELL allow: {}", if cfg.shell.allow_shell { "yes" } else { "no" });
    (B[m[32m+                println!(
    (B[m[32m+                    "  SHELL allow: {}",
    (B[m[32m+                    if cfg.shell.allow_shell { "yes" } else { "no" }
    (B[m[32m+                );
    (B[m             }
                 for spec in specs {
                     println!("- {}: {}", spec.name.bold(), spec.description);
    Diff in /workspace/crates/cli/src/commands/tools.rs:312:
                     if details {
                         println!("  usage: {}", spec.usage);
    [31m-                    println!("  supports_dry_run: {}", if spec.supports_dry_run { "true" } else { "false" });
    (B[m[32m+                    println!(
    (B[m[32m+                        "  supports_dry_run: {}",
    (B[m[32m+                        if spec.supports_dry_run {
    (B[m[32m+                            "true"
    (B[m[32m+                        } else {
    (B[m[32m+                            "false"
    (B[m[32m+                        }
    (B[m[32m+                    );
    (B[m                     if let Some(perms) = &spec.permissions {
    [31m-                        if !perms.fs_read_roots.is_empty() { println!("  perm.fs_read: {}", perms.fs_read_roots.join(":")); }
    (B[m[31m-                        if !perms.fs_write_roots.is_empty() { println!("  perm.fs_write: {}", perms.fs_write_roots.join(":")); }
    (B[m[31m-                        if !perms.net_allowlist.is_empty() { println!("  perm.net_allow: {}", perms.net_allowlist.join(",")); }
    (B[m[31m-                        if perms.allow_shell { println!("  perm.shell: allow"); }
    (B[m[32m+                        if !perms.fs_read_roots.is_empty() {
    (B[m[32m+                            println!("  perm.fs_read: {}", perms.fs_read_roots.join(":"));
    (B[m[32m+                        }
    (B[m[32m+                        if !perms.fs_write_roots.is_empty() {
    (B[m[32m+                            println!("  perm.fs_write: {}", perms.fs_write_roots.join(":"));
    (B[m[32m+                        }
    (B[m[32m+                        if !perms.net_allowlist.is_empty() {
    (B[m[32m+                            println!("  perm.net_allow: {}", perms.net_allowlist.join(","));
    (B[m[32m+                        }
    (B[m[32m+                        if perms.allow_shell {
    (B[m[32m+                            println!("  perm.shell: allow");
    (B[m[32m+                        }
    (B[m                     }
                         if let Some(guide) = &spec.usage_guide {
    [31m-                        if !guide.good_for.is_empty() { println!("  good_for: {}", guide.good_for.join(", ")); }
    (B[m[31m-                        if !guide.tags.is_empty() { println!("  tags: {}", guide.tags.join(", ")); }
    (B[m[31m-                        if !guide.capabilities.is_empty() { println!("  capabilities: {}", guide.capabilities.join(", ")); }
    (B[m[31m-                        println!("  latency: {}  risk: {}", guide.latency_class, guide.risk_score);
    (B[m[32m+                        if !guide.good_for.is_empty() {
    (B[m[32m+                            println!("  good_for: {}", guide.good_for.join(", "));
    (B[m[32m+                        }
    (B[m[32m+                        if !guide.tags.is_empty() {
    (B[m[32m+                            println!("  tags: {}", guide.tags.join(", "));
    (B[m[32m+                        }
    (B[m[32m+                        if !guide.capabilities.is_empty() {
    (B[m[32m+                            println!("  capabilities: {}", guide.capabilities.join(", "));
    (B[m[32m+                        }
    (B[m[32m+                        println!(
    (B[m[32m+                            "  latency: {}  risk: {}",
    (B[m[32m+                            guide.latency_class, guide.risk_score
    (B[m[32m+                        );
    (B[m                     }
                     }
                 }
    Diff in /workspace/crates/cli/src/commands/tools.rs:340:
                             let ok = v.get("successes").and_then(|x| x.as_u64()).unwrap_or(0);
                             let ask = v.get("asks").and_then(|x| x.as_u64()).unwrap_or(0);
                             let deny = v.get("denies").and_then(|x| x.as_u64()).unwrap_or(0);
    [31m-                        println!("- {}: invocations={}, successes={}, asks={}, denies={}", tool.bold(), inv, ok, ask, deny);
    (B[m[32m+                        println!(
    (B[m[32m+                            "- {}: invocations={}, successes={}, asks={}, denies={}",
    (B[m[32m+                            tool.bold(),
    (B[m[32m+                            inv,
    (B[m[32m+                            ok,
    (B[m[32m+                            ask,
    (B[m[32m+                            deny
    (B[m[32m+                        );
    (B[m                     }
                     } else {
                         println!("(нет данных)");
    Diff in /workspace/crates/cli/src/commands/tools.rs:348:
                 }
                 Ok(())
             }
    [31m-        ToolsSubcommand::Select { query, urgency, json } => {
    (B[m[31m-            if !json { export_plugins_into_registry(&mut registry).await; }
    (B[m[32m+        ToolsSubcommand::Select {
    (B[m[32m+            query,
    (B[m[32m+            urgency,
    (B[m[32m+            json,
    (B[m[32m+        } => {
    (B[m[32m+            if !json {
    (B[m[32m+                export_plugins_into_registry(&mut registry).await;
    (B[m[32m+            }
    (B[m             // Build selector and register all tools from registry's specs
                 let mut specs = registry.list_tools();
                 for spec in &mut specs {
    Diff in /workspace/crates/cli/src/commands/tools.rs:356:
    [31m-                if let Some(ov) = guide_overrides.get(&spec.name) { apply_usage_guide_override(spec, ov); }
    (B[m[32m+                if let Some(ov) = guide_overrides.get(&spec.name) {
    (B[m[32m+                    apply_usage_guide_override(spec, ov);
    (B[m[32m+                }
    (B[m             }
                 let selector = IntelligentToolSelector::new(SelectorConfig::default());
                 for spec in specs.clone() {
    Diff in /workspace/crates/cli/src/commands/tools.rs:379:
                 } else {
                     println!("{}", "=== Tool Selection ===".bold().cyan());
                     for e in explained {
    [31m-                    println!("- {}: score={:.2} (ctx {:.2}, cap {:.2}, perf {:.2})",
    (B[m[31m-                        e.tool_name.bold(), e.confidence_score, e.context_match, e.capability_match, e.performance_factor);
    (B[m[31m-                    if !e.matched.tags.is_empty() { println!("  tags: {}", e.matched.tags.join(", ")); }
    (B[m[31m-                    if !e.matched.capabilities.is_empty() { println!("  caps: {}", e.matched.capabilities.join(", ")); }
    (B[m[31m-                    if !e.matched.good_for.is_empty() { println!("  good_for: {}", e.matched.good_for.join(", ")); }
    (B[m[32m+                    println!(
    (B[m[32m+                        "- {}: score={:.2} (ctx {:.2}, cap {:.2}, perf {:.2})",
    (B[m[32m+                        e.tool_name.bold(),
    (B[m[32m+                        e.confidence_score,
    (B[m[32m+                        e.context_match,
    (B[m[32m+                        e.capability_match,
    (B[m[32m+                        e.performance_factor
    (B[m[32m+                    );
    (B[m[32m+                    if !e.matched.tags.is_empty() {
    (B[m[32m+                        println!("  tags: {}", e.matched.tags.join(", "));
    (B[m[32m+                    }
    (B[m[32m+                    if !e.matched.capabilities.is_empty() {
    (B[m[32m+                        println!("  caps: {}", e.matched.capabilities.join(", "));
    (B[m[32m+                    }
    (B[m[32m+                    if !e.matched.good_for.is_empty() {
    (B[m[32m+                        println!("  good_for: {}", e.matched.good_for.join(", "));
    (B[m[32m+                    }
    (B[m                     // Show safety-related breakdown
                         println!(
                             "  breakdown: latency_bonus={:.2} low_risk={:.2} perms_adj={:.2} dry_run={:.2}",
    Diff in /workspace/crates/cli/src/commands/tools.rs:412:
                     return Ok(());
                 }
                 // If neither flag provided, show help-like hint
    [31m-            println!("Использование: magray tools sandbox --show | --save --json '<SandboxConfig JSON>'");
    (B[m[32m+            println!(
    (B[m[32m+                "Использование: magray tools sandbox --show | --save --json '<SandboxConfig JSON>'"
    (B[m[32m+            );
    (B[m             Ok(())
             }
    [31m-        ToolsSubcommand::Plugins { list, load_manifests, dir, json, export_tools } => {
    (B[m[32m+        ToolsSubcommand::Plugins {
    (B[m[32m+            list,
    (B[m[32m+            load_manifests,
    (B[m[32m+            dir,
    (B[m[32m+            json,
    (B[m[32m+            export_tools,
    (B[m[32m+        } => {
    (B[m             // Resolve plugin dir and config dir under ~/.magray
                 let mut home = crate::util::magray_home();
    [31m-            let plugins_dir = if let Some(d) = dir { std::path::PathBuf::from(d) } else { let mut p = home.clone(); p.push("plugins"); p };
    (B[m[31m-            let mut cfg_dir = home.clone(); cfg_dir.push("plugin-configs");
    (B[m[32m+            let plugins_dir = if let Some(d) = dir {
    (B[m[32m+                std::path::PathBuf::from(d)
    (B[m[32m+            } else {
    (B[m[32m+                let mut p = home.clone();
    (B[m[32m+                p.push("plugins");
    (B[m[32m+                p
    (B[m[32m+            };
    (B[m[32m+            let mut cfg_dir = home.clone();
    (B[m[32m+            cfg_dir.push("plugin-configs");
    (B[m             tokio::fs::create_dir_all(&plugins_dir).await.ok();
                 tokio::fs::create_dir_all(&cfg_dir).await.ok();
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:426:
    [31m-            let registry = tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m[32m+            let registry =
    (B[m[32m+                tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m             if load_manifests {
                     let n = registry.load_manifests_from_directory().await?;
                     println!("{} Загрузлено манифестов: {}", "✓".green(), n);
    Diff in /workspace/crates/cli/src/commands/tools.rs:437:
                         for p in &items {
                             println!("- {} v{} — {}", p.name.bold(), p.version, p.description);
                             println!("  type: {:?}  entry: {}", p.plugin_type, p.entry_point);
    [31m-                        println!("  perms: fs={:?} net={:?} sys={:?}", p.required_permissions.file_system, p.required_permissions.network, p.required_permissions.system);
    (B[m[32m+                        println!(
    (B[m[32m+                            "  perms: fs={:?} net={:?} sys={:?}",
    (B[m[32m+                            p.required_permissions.file_system,
    (B[m[32m+                            p.required_permissions.network,
    (B[m[32m+                            p.required_permissions.system
    (B[m[32m+                        );
    (B[m                     }
                     }
                     if export_tools {
    Diff in /workspace/crates/cli/src/commands/tools.rs:444:
                         // Adapt to ToolSpec for visibility (not persisting to registry in this command)
                         let mut specs: Vec<tools::ToolSpec> = Vec::new();
                         for p in items {
    [31m-                        let perms_opt = map_plugin_perms_to_tools_permissions(&p.required_permissions);
    (B[m[32m+                        let perms_opt =
    (B[m[32m+                            map_plugin_perms_to_tools_permissions(&p.required_permissions);
    (B[m                         let spec = tools::ToolSpec {
                                 name: p.id.clone(),
                                 description: format!("[plugin:{:?}] {}", p.plugin_type, p.description),
    Diff in /workspace/crates/cli/src/commands/tools.rs:460:
                         if json {
                             println!("{}", serde_json::to_string_pretty(&specs)?);
                         } else {
    [31m-                        println!("{}", "=== Exported Plugin Tools (preview) ===".bold().cyan());
    (B[m[32m+                        println!(
    (B[m[32m+                            "{}",
    (B[m[32m+                            "=== Exported Plugin Tools (preview) ===".bold().cyan()
    (B[m[32m+                        );
    (B[m                         for s in specs {
                                 println!("- {}: {}", s.name.bold(), s.description);
                                 if let Some(perms) = &s.permissions {
    Diff in /workspace/crates/cli/src/commands/tools.rs:467:
    [31m-                                println!("  perm.fs_read: {}", if perms.fs_read_roots.is_empty() { "-".into() } else { perms.fs_read_roots.join(":") });
    (B[m[31m-                                println!("  perm.fs_write: {}", if perms.fs_write_roots.is_empty() { "-".into() } else { perms.fs_write_roots.join(":") });
    (B[m[31m-                                println!("  perm.net_allow: {}", if perms.net_allowlist.is_empty() { "-".into() } else { perms.net_allowlist.join(",") });
    (B[m[31m-                                println!("  perm.shell: {}", if perms.allow_shell { "allow" } else { "deny" });
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.fs_read: {}",
    (B[m[32m+                                    if perms.fs_read_roots.is_empty() {
    (B[m[32m+                                        "-".into()
    (B[m[32m+                                    } else {
    (B[m[32m+                                        perms.fs_read_roots.join(":")
    (B[m[32m+                                    }
    (B[m[32m+                                );
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.fs_write: {}",
    (B[m[32m+                                    if perms.fs_write_roots.is_empty() {
    (B[m[32m+                                        "-".into()
    (B[m[32m+                                    } else {
    (B[m[32m+                                        perms.fs_write_roots.join(":")
    (B[m[32m+                                    }
    (B[m[32m+                                );
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.net_allow: {}",
    (B[m[32m+                                    if perms.net_allowlist.is_empty() {
    (B[m[32m+                                        "-".into()
    (B[m[32m+                                    } else {
    (B[m[32m+                                        perms.net_allowlist.join(",")
    (B[m[32m+                                    }
    (B[m[32m+                                );
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.shell: {}",
    (B[m[32m+                                    if perms.allow_shell { "allow" } else { "deny" }
    (B[m[32m+                                );
    (B[m                             }
                             }
                         }
    Diff in /workspace/crates/cli/src/commands/tools.rs:475:
                 }
                 Ok(())
             }
    [31m-        ToolsSubcommand::AddMcp { name, cmd, args, remote_tool, description } => {
    (B[m[31m-            let args_vec: Vec<String> = if args.trim().is_empty() { Vec::new() } else { args.split_whitespace().map(|s| s.to_string()).collect() };
    (B[m[31m-            registry.register_mcp_tool(&name, cmd.clone(), args_vec.clone(), remote_tool.clone(), description.clone());
    (B[m[31m-            upsert_mcp_config(McpToolConfig { name: name.clone(), cmd, args: args_vec, remote_tool, description })?;
    (B[m[31m-            println!("{} Зарегистрирован MCP инструмент: {}", "✓".green(), name.bold());
    (B[m[32m+        ToolsSubcommand::AddMcp {
    (B[m[32m+            name,
    (B[m[32m+            cmd,
    (B[m[32m+            args,
    (B[m[32m+            remote_tool,
    (B[m[32m+            description,
    (B[m[32m+        } => {
    (B[m[32m+            let args_vec: Vec<String> = if args.trim().is_empty() {
    (B[m[32m+                Vec::new()
    (B[m[32m+            } else {
    (B[m[32m+                args.split_whitespace().map(|s| s.to_string()).collect()
    (B[m[32m+            };
    (B[m[32m+            registry.register_mcp_tool(
    (B[m[32m+                &name,
    (B[m[32m+                cmd.clone(),
    (B[m[32m+                args_vec.clone(),
    (B[m[32m+                remote_tool.clone(),
    (B[m[32m+                description.clone(),
    (B[m[32m+            );
    (B[m[32m+            upsert_mcp_config(McpToolConfig {
    (B[m[32m+                name: name.clone(),
    (B[m[32m+                cmd,
    (B[m[32m+                args: args_vec,
    (B[m[32m+                remote_tool,
    (B[m[32m+                description,
    (B[m[32m+            })?;
    (B[m[32m+            println!(
    (B[m[32m+                "{} Зарегистрирован MCP инструмент: {}",
    (B[m[32m+                "✓".green(),
    (B[m[32m+                name.bold()
    (B[m[32m+            );
    (B[m             Ok(())
             }
    [31m-        ToolsSubcommand::Run { name, command, arg, context, dry_run, timeout_ms } => {
    (B[m[32m+        ToolsSubcommand::Run {
    (B[m[32m+            name,
    (B[m[32m+            command,
    (B[m[32m+            arg,
    (B[m[32m+            context,
    (B[m[32m+            dry_run,
    (B[m[32m+            timeout_ms,
    (B[m[32m+        } => {
    (B[m             export_plugins_into_registry(&mut registry).await;
    [31m-            let tool = registry.get(&name).ok_or_else(|| anyhow::anyhow!("Tool not found: {}", name))?;
    (B[m[32m+            let tool = registry
    (B[m[32m+                .get(&name)
    (B[m[32m+                .ok_or_else(|| anyhow::anyhow!("Tool not found: {}", name))?;
    (B[m             let mut args_map = std::collections::HashMap::new();
    [31m-            for (k, v) in arg { args_map.insert(k, v); }
    (B[m[32m+            for (k, v) in arg {
    (B[m[32m+                args_map.insert(k, v);
    (B[m[32m+            }
    (B[m             // Load effective policy
                 let mut home = crate::util::magray_home();
                 home.push("policy.json");
    Diff in /workspace/crates/cli/src/commands/tools.rs:495:
                 // Enrich policy args
                 if name == "web_fetch" {
                     if let Some(url) = args_map.get("url").cloned() {
    [31m-                    let domain = url.split('/').nth(2).unwrap_or("").split(':').next().unwrap_or("").to_string();
    (B[m[31m-                    if !domain.is_empty() { args_map.insert("domain".into(), domain); }
    (B[m[32m+                    let domain = url
    (B[m[32m+                        .split('/')
    (B[m[32m+                        .nth(2)
    (B[m[32m+                        .unwrap_or("")
    (B[m[32m+                        .split(':')
    (B[m[32m+                        .next()
    (B[m[32m+                        .unwrap_or("")
    (B[m[32m+                        .to_string();
    (B[m[32m+                    if !domain.is_empty() {
    (B[m[32m+                        args_map.insert("domain".into(), domain);
    (B[m[32m+                    }
    (B[m                 }
                 } else if name == "web_search" {
                     if let Some(q) = args_map.get("query").cloned() {
    Diff in /workspace/crates/cli/src/commands/tools.rs:503:
                         let lowered = q.to_lowercase();
    [31m-                    if lowered.contains("internal") { args_map.insert("keyword".into(), "internal".into()); }
    (B[m[31m-                    if lowered.contains("secret") { args_map.insert("keyword".into(), "secret".into()); }
    (B[m[32m+                    if lowered.contains("internal") {
    (B[m[32m+                        args_map.insert("keyword".into(), "internal".into());
    (B[m[32m+                    }
    (B[m[32m+                    if lowered.contains("secret") {
    (B[m[32m+                        args_map.insert("keyword".into(), "secret".into());
    (B[m[32m+                    }
    (B[m                 }
                 }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:516:
                         net_allowlist: perms.net_allowlist.clone(),
                         allow_shell: perms.allow_shell,
                     };
    [31m-                if let Some(pre) = common::policy::precheck_permissions(&name, &simple, &sandbox_cfg) {
    (B[m[32m+                if let Some(pre) =
    (B[m[32m+                    common::policy::precheck_permissions(&name, &simple, &sandbox_cfg)
    (B[m[32m+                {
    (B[m                     match pre.action {
                             common::policy::PolicyAction::Deny => {
    [31m-                            anyhow::bail!("Инструмент '{}' заблокирован политикой (precheck)", name);
    (B[m[32m+                            anyhow::bail!(
    (B[m[32m+                                "Инструмент '{}' заблокирован политикой (precheck)",
    (B[m[32m+                                name
    (B[m[32m+                            );
    (B[m                         }
                             common::policy::PolicyAction::Ask => {
    [31m-                            let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[31m-                            if non_interactive { anyhow::bail!("Инструмент '{}' требует подтверждения (precheck), но режим non-interactive", name); }
    (B[m[32m+                            let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE")
    (B[m[32m+                                .unwrap_or_default()
    (B[m[32m+                                == "true";
    (B[m[32m+                            if non_interactive {
    (B[m[32m+                                anyhow::bail!("Инструмент '{}' требует подтверждения (precheck), но режим non-interactive", name);
    (B[m[32m+                            }
    (B[m                         }
                             common::policy::PolicyAction::Allow => { /* continue */ }
                         }
    Diff in /workspace/crates/cli/src/commands/tools.rs:535:
                 // Dynamic guard based on UsageGuide overrides/spec
                 let mut require_ask_due_to_guide = false;
                 let mut spec = tool.spec();
    [31m-            if let Some(ov) = guide_overrides.get(&name) { apply_usage_guide_override(&mut spec, ov); }
    (B[m[31m-            if matches!(decision.action, common::policy::PolicyAction::Allow) && decision.matched_rule.is_none() {
    (B[m[32m+            if let Some(ov) = guide_overrides.get(&name) {
    (B[m[32m+                apply_usage_guide_override(&mut spec, ov);
    (B[m[32m+            }
    (B[m[32m+            if matches!(decision.action, common::policy::PolicyAction::Allow)
    (B[m[32m+                && decision.matched_rule.is_none()
    (B[m[32m+            {
    (B[m                 if let Some(guide) = &spec.usage_guide {
                         let high_risk = guide.risk_score >= 4;
                         let has_side_effects = !guide.side_effects.is_empty();
    Diff in /workspace/crates/cli/src/commands/tools.rs:543:
    [31m-                    if high_risk || has_side_effects { require_ask_due_to_guide = true; }
    (B[m[32m+                    if high_risk || has_side_effects {
    (B[m[32m+                        require_ask_due_to_guide = true;
    (B[m[32m+                    }
    (B[m                 }
                 }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:547:
                 if matches!(decision.action, common::policy::PolicyAction::Deny) {
    [31m-                let reason = decision.matched_rule.and_then(|r| r.reason).unwrap_or_else(|| "blocked".into());
    (B[m[32m+                let reason = decision
    (B[m[32m+                    .matched_rule
    (B[m[32m+                    .and_then(|r| r.reason)
    (B[m[32m+                    .unwrap_or_else(|| "blocked".into());
    (B[m                 let evt = serde_json::json!({"tool": name, "reason": reason});
                     tokio::spawn(events::publish(topics::TOPIC_POLICY_BLOCK, evt));
                     anyhow::bail!("Tool '{}' blocked by policy", name);
    Diff in /workspace/crates/cli/src/commands/tools.rs:552:
                 }
    [31m-            if matches!(decision.action, common::policy::PolicyAction::Ask) || require_ask_due_to_guide {
    (B[m[31m-                let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[31m-                if non_interactive { anyhow::bail!("Tool '{}' requires confirmation (ask), but running non-interactive", name); }
    (B[m[31m-                let auto_approve = std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[32m+            if matches!(decision.action, common::policy::PolicyAction::Ask)
    (B[m[32m+                || require_ask_due_to_guide
    (B[m[32m+            {
    (B[m[32m+                let non_interactive =
    (B[m[32m+                    std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[32m+                if non_interactive {
    (B[m[32m+                    anyhow::bail!(
    (B[m[32m+                        "Tool '{}' requires confirmation (ask), but running non-interactive",
    (B[m[32m+                        name
    (B[m[32m+                    );
    (B[m[32m+                }
    (B[m[32m+                let auto_approve =
    (B[m[32m+                    std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m                 if !auto_approve {
    [31m-                    let preview_input = tools::ToolInput { command: command.clone(), args: args_map.clone(), context: context.clone(), dry_run: true, timeout_ms };
    (B[m[31m-                    let preview = tool.execute(preview_input).await.unwrap_or_else(|e| tools::ToolOutput { success: false, result: format!("preview error: {}", e), formatted_output: None, metadata: std::collections::HashMap::new() });
    (B[m[32m+                    let preview_input = tools::ToolInput {
    (B[m[32m+                        command: command.clone(),
    (B[m[32m+                        args: args_map.clone(),
    (B[m[32m+                        context: context.clone(),
    (B[m[32m+                        dry_run: true,
    (B[m[32m+                        timeout_ms,
    (B[m[32m+                    };
    (B[m[32m+                    let preview =
    (B[m[32m+                        tool.execute(preview_input)
    (B[m[32m+                            .await
    (B[m[32m+                            .unwrap_or_else(|e| tools::ToolOutput {
    (B[m[32m+                                success: false,
    (B[m[32m+                                result: format!("preview error: {}", e),
    (B[m[32m+                                formatted_output: None,
    (B[m[32m+                                metadata: std::collections::HashMap::new(),
    (B[m[32m+                            });
    (B[m                     println!("\n=== Предпросмотр (dry-run) {} ===", name.bold());
    [31m-                    if let Some(fmt) = preview.formatted_output { println!("{}", fmt); } else { println!("{}", preview.result); }
    (B[m[31m-                    if require_ask_due_to_guide { println!("Требуется подтверждение по UsageGuide (risk/side_effects)"); }
    (B[m[32m+                    if let Some(fmt) = preview.formatted_output {
    (B[m[32m+                        println!("{}", fmt);
    (B[m[32m+                    } else {
    (B[m[32m+                        println!("{}", preview.result);
    (B[m[32m+                    }
    (B[m[32m+                    if require_ask_due_to_guide {
    (B[m[32m+                        println!("Требуется подтверждение по UsageGuide (risk/side_effects)");
    (B[m[32m+                    }
    (B[m                     use std::io::{self, Write};
                         print!("Продолжить выполнение? [y/N]: ");
                         let _ = io::stdout().flush();
    Diff in /workspace/crates/cli/src/commands/tools.rs:566:
                         let mut answer = String::new();
    [31m-                    if io::stdin().read_line(&mut answer).is_err() { anyhow::bail!("confirmation failed"); }
    (B[m[32m+                    if io::stdin().read_line(&mut answer).is_err() {
    (B[m[32m+                        anyhow::bail!("confirmation failed");
    (B[m[32m+                    }
    (B[m                     let ans = answer.trim().to_lowercase();
    [31m-                    if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") { anyhow::bail!("Отменено пользователем"); }
    (B[m[32m+                    if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") {
    (B[m[32m+                        anyhow::bail!("Отменено пользователем");
    (B[m[32m+                    }
    (B[m                 }
                 }
    [31m-            let input = tools::ToolInput { command, args: args_map, context, dry_run, timeout_ms };
    (B[m[32m+            let input = tools::ToolInput {
    (B[m[32m+                command,
    (B[m[32m+                args: args_map,
    (B[m[32m+                context,
    (B[m[32m+                dry_run,
    (B[m[32m+                timeout_ms,
    (B[m[32m+            };
    (B[m             let output = tool.execute(input).await?;
    [31m-            if output.success { println!("{} {}", "✓".green(), output.result); } else { println!("{} {}", "✗".red(), output.result); }
    (B[m[32m+            if output.success {
    (B[m[32m+                println!("{} {}", "✓".green(), output.result);
    (B[m[32m+            } else {
    (B[m[32m+                println!("{} {}", "✗".red(), output.result);
    (B[m[32m+            }
    (B[m             let evt = serde_json::json!({"tool": name, "success": output.success});
                 tokio::spawn(events::publish(topics::TOPIC_TOOL_INVOKED, evt));
                 Ok(())
    Diff in /workspace/crates/cli/src/commands/tools.rs:578:
             }
         }
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/handlers/admin_handler.rs:258:
                 return Err(anyhow::anyhow!("AdminHandler не инициализирован"));
             }
             let state = self.circuit_breaker.get_state().await;
    [31m-        if state == "Open" { return Err(anyhow::anyhow!("Circuit breaker открыт")); }
    (B[m[32m+        if state == "Open" {
    (B[m[32m+            return Err(anyhow::anyhow!("Circuit breaker открыт"));
    (B[m[32m+        }
    (B[m         Ok(())
         }
     
    Diff in /workspace/crates/cli/src/handlers/memory_handler.rs:213:
         C: CircuitBreakerTrait,
     {
         async fn initialize(&self) -> Result<()> {
    [31m-        super::standard_component_initialize("MemoryHandler", self.memory_service.health_check()).await
    (B[m[32m+        super::standard_component_initialize("MemoryHandler", self.memory_service.health_check())
    (B[m[32m+            .await
    (B[m     }
     
         async fn health_check(&self) -> Result<()> {
    Diff in /workspace/crates/cli/src/handlers/mod.rs:16:
     pub use tools_handler::*;
     
     use anyhow::{anyhow, Result};
    [31m-use tracing::info;
    (B[m use std::collections::HashMap;
    [32m+use tracing::info;
    (B[m 
     /// Общая инициализация компонента с проверкой зависимости
     pub async fn standard_component_initialize<DFut, D, E>(
    Diff in /workspace/crates/cli/src/handlers/mod.rs:29:
         E: std::fmt::Display,
     {
         info!("{}: инициализация начата", component_name);
    [31m-    dep_check.await.map(|_| ()).map_err(|e| anyhow!(e.to_string()))?;
    (B[m[32m+    dep_check
    (B[m[32m+        .await
    (B[m[32m+        .map(|_| ())
    (B[m[32m+        .map_err(|e| anyhow!(e.to_string()))?;
    (B[m     info!("{}: инициализация завершена", component_name);
         Ok(())
     }
    Diff in /workspace/crates/cli/src/handlers/tools_handler.rs:179:
         C: CircuitBreakerTrait,
     {
         async fn initialize(&self) -> Result<()> {
    [31m-        super::standard_component_initialize("ToolsHandler", self.routing_service.health_check()).await
    (B[m[32m+        super::standard_component_initialize("ToolsHandler", self.routing_service.health_check())
    (B[m[32m+            .await
    (B[m     }
     
         async fn health_check(&self) -> Result<()> {
    Diff in /workspace/crates/cli/src/health_checks.rs:1:
     use anyhow::Result;
     use chrono::{DateTime, Utc};
     use colored::Colorize;
    [32m+use common::policy::{default_document, load_effective_policy};
    (B[m use common::OperationTimer;
     use serde::{Deserialize, Serialize};
     use std::collections::HashMap;
    Diff in /workspace/crates/cli/src/health_checks.rs:7:
     use std::sync::Arc;
     use tracing::{debug, error, info, warn};
    [31m-use common::policy::{default_document, load_effective_policy};
    (B[m 
     /// Результат проверки здоровья компонента
     #[derive(Debug, Clone, Serialize, Deserialize)]
    Diff in /workspace/crates/cli/src/unified_agent_v2.rs:13:
     use std::sync::Arc;
     use tracing::{debug, error, info, warn};
     
    [31m-use crate::agent_traits::*;
    (B[m use crate::agent_traits::RequestProcessorTrait;
    [32m+use crate::agent_traits::*;
    (B[m use crate::handlers::*;
     use crate::orchestrator::*;
     use crate::strategies::*;
    Diff in /workspace/crates/cli/src/unified_agent_v2.rs:21:
     use tools::enhanced_tool_system::EnhancedToolSystemConfig;
     
     // Импорт общих трейтов для устранения дублирования
    [31m-use common::service_traits::{BaseService, HealthCheckService};
    (B[m use crate::agent_traits::RequestProcessorTrait as _;
    [32m+use common::service_traits::{BaseService, HealthCheckService};
    (B[m 
     // ============================================================================
     // ADAPTER IMPLEMENTATIONS FOR EXISTING SERVICES
    Diff in /workspace/crates/cli/src/unified_agent_v2.rs:282:
     #[cfg(feature = "minimal")]
     #[async_trait]
     impl MemoryManagementTrait for MemoryManagementAdapter {
    [31m-    async fn store_message(&self, _message: &str, _context: &HashMap<String, String>) -> Result<()> {
    (B[m[32m+    async fn store_message(
    (B[m[32m+        &self,
    (B[m[32m+        _message: &str,
    (B[m[32m+        _context: &HashMap<String, String>,
    (B[m[32m+    ) -> Result<()> {
    (B[m         Ok(())
         }
     
    Diff in /workspace/crates/cli/src/util.rs:24:
         std::fs::create_dir_all(&dir).ok();
         dir
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/gpu.rs:6:
     };
     use anyhow::Result;
     use clap::{Args, Subcommand};
    [31m-use tracing::{info, warn, error};
    (B[m[32m+use tracing::{error, info, warn};
    (B[m 
     #[derive(Debug, Args)]
     pub struct GpuCommand {
    Diff in /workspace/crates/cli/src/commands/memory.rs:2:
     use anyhow::{anyhow, Result};
     use clap::{Args, Subcommand};
     use colored::*;
    [31m-use memory::{default_config};
    (B[m[31m-use memory::api::{MemoryContext, UnifiedMemoryAPI, MemoryServiceTrait};
    (B[m[32m+use common::policy::{default_document, load_from_path, merge_documents, PolicyEngine};
    (B[m[32m+use common::{events, topics};
    (B[m[32m+use memory::api::{MemoryContext, MemoryServiceTrait, UnifiedMemoryAPI};
    (B[m[32m+use memory::default_config;
    (B[m use memory::di::core_traits::ServiceResolver;
     use memory::types::Layer;
     use prettytable::{row, Table};
    Diff in /workspace/crates/cli/src/commands/memory.rs:10:
     use std::path::PathBuf;
     use std::sync::Arc;
    [31m-use common::{events, topics};
    (B[m[31m-use common::policy::{default_document, load_from_path, merge_documents, PolicyEngine};
    (B[m 
     /// Команда для управления системой памяти
     #[derive(Debug, Args)]
    Diff in /workspace/crates/cli/src/commands/memory.rs:146:
         // Prepare effective policy for commands (env-json > env-path/file > default)
         let mut home = crate::util::magray_home();
         home.push("policy.json");
    [31m-    let effective = common::policy::load_effective_policy(if home.exists() { Some(&home) } else { None });
    (B[m[32m+    let effective =
    (B[m[32m+        common::policy::load_effective_policy(if home.exists() { Some(&home) } else { None });
    (B[m     let policy = PolicyEngine::from_document(effective);
     
         match cmd {
    Diff in /workspace/crates/cli/src/commands/memory.rs:153:
             MemorySubcommand::Stats { detailed } => {
    [31m-            tokio::spawn(events::publish(topics::TOPIC_INTENT, serde_json::json!({"command":"memory.stats","detailed":detailed })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_INTENT,
    (B[m[32m+                serde_json::json!({"command":"memory.stats","detailed":detailed }),
    (B[m[32m+            ));
    (B[m             show_memory_stats(&api, detailed).await?;
             }
     
    Diff in /workspace/crates/cli/src/commands/memory.rs:164:
                 hybrid,
             } => {
                 // intent event
    [31m-            tokio::spawn(events::publish(topics::TOPIC_INTENT, serde_json::json!({
    (B[m[31m-                "command": "memory.search", "query": query, "top_k": top_k, "rerank": rerank, "hybrid": hybrid
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_INTENT,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "command": "memory.search", "query": query, "top_k": top_k, "rerank": rerank, "hybrid": hybrid
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m             search_memory(&api, &query, layer, top_k, min_score, rerank, hybrid).await?;
             }
     
    Diff in /workspace/crates/cli/src/commands/memory.rs:176:
                 tags,
                 kind,
             } => {
    [31m-            tokio::spawn(events::publish(topics::TOPIC_INTENT, serde_json::json!({
    (B[m[31m-                "command": "memory.add", "layer": layer, "kind": kind
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_INTENT,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "command": "memory.add", "layer": layer, "kind": kind
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m             add_to_memory(&api, text, &layer, tags, &kind).await?;
             }
     
    Diff in /workspace/crates/cli/src/commands/memory.rs:185:
             MemorySubcommand::Backup { name } => {
                 // Check policy for command
    [31m-            let decision = policy.evaluate_command("memory.backup", &std::collections::HashMap::new());
    (B[m[32m+            let decision =
    (B[m[32m+                policy.evaluate_command("memory.backup", &std::collections::HashMap::new());
    (B[m             if !decision.allowed {
    [31m-                let reason = decision.matched_rule.and_then(|r| r.reason).unwrap_or_else(|| "blocked".into());
    (B[m[32m+                let reason = decision
    (B[m[32m+                    .matched_rule
    (B[m[32m+                    .and_then(|r| r.reason)
    (B[m[32m+                    .unwrap_or_else(|| "blocked".into());
    (B[m                 let evt = serde_json::json!({"command": "memory.backup", "reason": reason});
                     tokio::spawn(events::publish(topics::TOPIC_POLICY_BLOCK, evt));
                     anyhow::bail!("Command 'memory backup' blocked by policy");
    Diff in /workspace/crates/cli/src/commands/memory.rs:193:
                 }
                 if matches!(decision.action, common::policy::PolicyAction::Ask) {
    [31m-                let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[32m+                let non_interactive =
    (B[m[32m+                    std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m                 if non_interactive {
    [31m-                    tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.backup","error":"non-interactive ask"})));
    (B[m[32m+                    tokio::spawn(events::publish(
    (B[m[32m+                        topics::TOPIC_ERROR,
    (B[m[32m+                        serde_json::json!({"command":"memory.backup","error":"non-interactive ask"}),
    (B[m[32m+                    ));
    (B[m                     anyhow::bail!("Command 'memory backup' requires confirmation (ask), but running non-interactive");
                     }
    [31m-                let auto_approve = std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[32m+                let auto_approve =
    (B[m[32m+                    std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m                 if !auto_approve {
                         use std::io::{self, Write};
    [31m-                    println!("\nОперация backup может занять время. Риск: {:?}", decision.risk);
    (B[m[32m+                    println!(
    (B[m[32m+                        "\nОперация backup может занять время. Риск: {:?}",
    (B[m[32m+                        decision.risk
    (B[m[32m+                    );
    (B[m                     print!("Продолжить? [y/N]: ");
                         let _ = io::stdout().flush();
                         let mut answer = String::new();
    Diff in /workspace/crates/cli/src/commands/memory.rs:207:
    [31m-                    if io::stdin().read_line(&mut answer).is_err() { anyhow::bail!("confirmation failed"); }
    (B[m[32m+                    if io::stdin().read_line(&mut answer).is_err() {
    (B[m[32m+                        anyhow::bail!("confirmation failed");
    (B[m[32m+                    }
    (B[m                     let ans = answer.trim().to_lowercase();
                         if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") {
    [31m-                        tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.backup","error":"user-cancel"})));
    (B[m[32m+                        tokio::spawn(events::publish(
    (B[m[32m+                            topics::TOPIC_ERROR,
    (B[m[32m+                            serde_json::json!({"command":"memory.backup","error":"user-cancel"}),
    (B[m[32m+                        ));
    (B[m                         anyhow::bail!("Отменено пользователем");
                         }
                     }
    Diff in /workspace/crates/cli/src/commands/memory.rs:214:
                 }
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({"job":"memory.backup","status":"started"})));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({"job":"memory.backup","status":"started"}),
    (B[m[32m+            ));
    (B[m             create_backup(&api, name).await?;
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({
    (B[m[31m-                "job": "memory.backup", "status": "done"
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "job": "memory.backup", "status": "done"
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m         }
     
             MemorySubcommand::Restore { backup_path } => {
    Diff in /workspace/crates/cli/src/commands/memory.rs:223:
    [31m-            let decision = policy.evaluate_command("memory.restore", &std::collections::HashMap::new());
    (B[m[32m+            let decision =
    (B[m[32m+                policy.evaluate_command("memory.restore", &std::collections::HashMap::new());
    (B[m             if !decision.allowed {
    [31m-                let reason = decision.matched_rule.and_then(|r| r.reason).unwrap_or_else(|| "blocked".into());
    (B[m[32m+                let reason = decision
    (B[m[32m+                    .matched_rule
    (B[m[32m+                    .and_then(|r| r.reason)
    (B[m[32m+                    .unwrap_or_else(|| "blocked".into());
    (B[m                 let evt = serde_json::json!({"command": "memory.restore", "reason": reason});
                     tokio::spawn(events::publish(topics::TOPIC_POLICY_BLOCK, evt));
                     anyhow::bail!("Command 'memory restore' blocked by policy");
    Diff in /workspace/crates/cli/src/commands/memory.rs:229:
                 }
                 if matches!(decision.action, common::policy::PolicyAction::Ask) {
    [31m-                let auto_approve = std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[31m-                let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[32m+                let auto_approve =
    (B[m[32m+                    std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[32m+                let non_interactive =
    (B[m[32m+                    std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m                 if non_interactive && auto_approve {
                         // proceed silently
                     } else if non_interactive && !auto_approve {
    Diff in /workspace/crates/cli/src/commands/memory.rs:236:
    [31m-                    tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.restore","error":"non-interactive ask"})));
    (B[m[32m+                    tokio::spawn(events::publish(
    (B[m[32m+                        topics::TOPIC_ERROR,
    (B[m[32m+                        serde_json::json!({"command":"memory.restore","error":"non-interactive ask"}),
    (B[m[32m+                    ));
    (B[m                     anyhow::bail!("Command 'memory restore' requires confirmation (ask), but running non-interactive");
                     }
                     if !auto_approve {
    Diff in /workspace/crates/cli/src/commands/memory.rs:240:
                         use std::io::{self, Write};
    [31m-                    println!("\nОперация restore может перезаписать данные. Риск: {:?}", decision.risk);
    (B[m[32m+                    println!(
    (B[m[32m+                        "\nОперация restore может перезаписать данные. Риск: {:?}",
    (B[m[32m+                        decision.risk
    (B[m[32m+                    );
    (B[m                     print!("Продолжить? [y/N]: ");
                         let _ = io::stdout().flush();
                         let mut answer = String::new();
    Diff in /workspace/crates/cli/src/commands/memory.rs:245:
    [31m-                    if io::stdin().read_line(&mut answer).is_err() { anyhow::bail!("confirmation failed"); }
    (B[m[32m+                    if io::stdin().read_line(&mut answer).is_err() {
    (B[m[32m+                        anyhow::bail!("confirmation failed");
    (B[m[32m+                    }
    (B[m                     let ans = answer.trim().to_lowercase();
                         if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") {
    [31m-                        tokio::spawn(events::publish(topics::TOPIC_ERROR, serde_json::json!({"command":"memory.restore","error":"user-cancel"})));
    (B[m[32m+                        tokio::spawn(events::publish(
    (B[m[32m+                            topics::TOPIC_ERROR,
    (B[m[32m+                            serde_json::json!({"command":"memory.restore","error":"user-cancel"}),
    (B[m[32m+                        ));
    (B[m                         anyhow::bail!("Отменено пользователем");
                         }
                     }
    Diff in /workspace/crates/cli/src/commands/memory.rs:252:
                 }
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({"job":"memory.restore","status":"started"})));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({"job":"memory.restore","status":"started"}),
    (B[m[32m+            ));
    (B[m             restore_backup(&api, backup_path).await?;
    [31m-            tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, serde_json::json!({
    (B[m[31m-                "job": "memory.restore", "status": "done"
    (B[m[31m-            })));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+                serde_json::json!({
    (B[m[32m+                    "job": "memory.restore", "status": "done"
    (B[m[32m+                }),
    (B[m[32m+            ));
    (B[m         }
     
             MemorySubcommand::ListBackups => {
    Diff in /workspace/crates/cli/src/commands/memory.rs:402:
             ..Default::default()
         };
     
    [31m-    if rerank { println!("{}", "[hint] Rerank enabled (Qwen3)".dimmed()); }
    (B[m[32m+    if rerank {
    (B[m[32m+        println!("{}", "[hint] Rerank enabled (Qwen3)".dimmed());
    (B[m[32m+    }
    (B[m     if hybrid {
             #[cfg(feature = "keyword-search")]
             println!("{}", "[hint] Hybrid (vector + BM25 keyword)".dimmed());
    Diff in /workspace/crates/cli/src/commands/memory.rs:409:
             #[cfg(not(feature = "keyword-search"))]
    [31m-        println!("{}", "[hint] Hybrid mode requested (vector-only fallback)".dimmed());
    (B[m[32m+        println!(
    (B[m[32m+            "{}",
    (B[m[32m+            "[hint] Hybrid mode requested (vector-only fallback)".dimmed()
    (B[m[32m+        );
    (B[m     }
     
         // Orchestrated path (if enabled) uses SearchCoordinator with optional rerank
    Diff in /workspace/crates/cli/src/commands/memory.rs:417:
             use memory::orchestration::SearchCoordinator;
             let container = memory::di::UnifiedContainer::new();
             if let Ok(search) = container.resolve::<SearchCoordinator>() {
    [31m-            let layer_to_use = options.layers.clone().and_then(|v| v.first().cloned()).unwrap_or(Layer::Interact);
    (B[m[31m-            let coord_opts = memory::types::SearchOptions { top_k, ..Default::default() };
    (B[m[32m+            let layer_to_use = options
    (B[m[32m+                .layers
    (B[m[32m+                .clone()
    (B[m[32m+                .and_then(|v| v.first().cloned())
    (B[m[32m+                .unwrap_or(Layer::Interact);
    (B[m[32m+            let coord_opts = memory::types::SearchOptions {
    (B[m[32m+                top_k,
    (B[m[32m+                ..Default::default()
    (B[m[32m+            };
    (B[m             let results = if rerank {
    [31m-                SearchCoordinatorTrait::search_with_rerank(&*search, query, layer_to_use, coord_opts, top_k).await?
    (B[m[32m+                SearchCoordinatorTrait::search_with_rerank(
    (B[m[32m+                    &*search,
    (B[m[32m+                    query,
    (B[m[32m+                    layer_to_use,
    (B[m[32m+                    coord_opts,
    (B[m[32m+                    top_k,
    (B[m[32m+                )
    (B[m[32m+                .await?
    (B[m             } else if hybrid {
                     // hybrid: text embedding first; in future accept vector input
    [31m-                SearchCoordinatorTrait::hybrid_search(&*search, query, None, layer_to_use, coord_opts).await?
    (B[m[32m+                SearchCoordinatorTrait::hybrid_search(
    (B[m[32m+                    &*search,
    (B[m[32m+                    query,
    (B[m[32m+                    None,
    (B[m[32m+                    layer_to_use,
    (B[m[32m+                    coord_opts,
    (B[m[32m+                )
    (B[m[32m+                .await?
    (B[m             } else {
                     SearchCoordinatorTrait::search(&*search, query, layer_to_use, coord_opts).await?
                 };
    Diff in /workspace/crates/cli/src/commands/memory.rs:453:
                 }
                 return Ok(());
             }
    [31m-        println!("{}", "[hint] Orchestrated search unavailable; falling back to unified API".dimmed());
    (B[m[32m+        println!(
    (B[m[32m+            "{}",
    (B[m[32m+            "[hint] Orchestrated search unavailable; falling back to unified API".dimmed()
    (B[m[32m+        );
    (B[m     }
     
         println!("{} '{}'...", "Searching for".cyan(), query.bold());
    Diff in /workspace/crates/cli/src/commands/memory.rs:538:
     async fn create_backup(api: &UnifiedMemoryAPI, name: Option<String>) -> Result<()> {
         let spinner = ProgressBuilder::backup("Creating memory backup...");
     
    [31m-    let backup_name = name.unwrap_or_else(|| format!("backup_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S")));
    (B[m[32m+    let backup_name = name
    (B[m[32m+        .unwrap_or_else(|| format!("backup_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S")));
    (B[m     let path = std::path::PathBuf::from("backups").join(backup_name);
     
    [31m-    match tokio::time::timeout(std::time::Duration::from_secs(30), api.backup_to_path(&path)).await {
    (B[m[32m+    match tokio::time::timeout(
    (B[m[32m+        std::time::Duration::from_secs(30),
    (B[m[32m+        api.backup_to_path(&path),
    (B[m[32m+    )
    (B[m[32m+    .await
    (B[m[32m+    {
    (B[m         Ok(Ok(count)) => {
                 spinner.finish_success(Some("Backup created successfully!"));
                 println!("{}: {}", "Path".cyan(), path.display());
    Diff in /workspace/crates/cli/src/commands/memory.rs:561:
     }
     
     async fn restore_backup(api: &UnifiedMemoryAPI, backup_path: PathBuf) -> Result<()> {
    [31m-    let file_name = backup_path.file_name().unwrap_or_default().to_string_lossy();
    (B[m[32m+    let file_name = backup_path
    (B[m[32m+        .file_name()
    (B[m[32m+        .unwrap_or_default()
    (B[m[32m+        .to_string_lossy();
    (B[m     let spinner = ProgressBuilder::backup(&format!("Restoring from backup: {file_name}"));
     
    [31m-    match tokio::time::timeout(std::time::Duration::from_secs(45), api.restore_from_path(&backup_path)).await {
    (B[m[32m+    match tokio::time::timeout(
    (B[m[32m+        std::time::Duration::from_secs(45),
    (B[m[32m+        api.restore_from_path(&backup_path),
    (B[m[32m+    )
    (B[m[32m+    .await
    (B[m[32m+    {
    (B[m         Ok(Ok(inserted)) => {
                 spinner.finish_success(Some("Restore completed!"));
                 println!("{}: {}", "Path".cyan(), backup_path.display());
    Diff in /workspace/crates/cli/src/commands/memory.rs:574:
                 // Treat invalid/missing file as no-op restore for better UX in env-policy tests
                 spinner.finish_success(Some("Restore completed (no data)"));
                 println!("{}: {}", "Path".cyan(), backup_path.display());
    [31m-            println!("{}", "No records restored (empty or invalid backup)".yellow());
    (B[m[32m+            println!(
    (B[m[32m+                "{}",
    (B[m[32m+                "No records restored (empty or invalid backup)".yellow()
    (B[m[32m+            );
    (B[m         }
             Err(_) => {
                 spinner.finish_error("Restore timeout");
    Diff in /workspace/crates/cli/src/commands/memory.rs:586:
     }
     
     fn list_backups(_api: &UnifiedMemoryAPI) -> Result<()> {
    [31m-    use std::fs; use std::path::PathBuf;
    (B[m[32m+    use std::fs;
    (B[m[32m+    use std::path::PathBuf;
    (B[m     let dir = PathBuf::from("backups");
         println!("{}", "Available backups:".bold());
         if let Ok(read) = fs::read_dir(&dir) {
    Diff in /workspace/crates/cli/src/commands/memory.rs:593:
             let mut any = false;
             for e in read.flatten() {
    [31m-            if let Ok(ft) = e.file_type() { if ft.is_file() { println!("- {}", e.path().display()); any = true; } }
    (B[m[32m+            if let Ok(ft) = e.file_type() {
    (B[m[32m+                if ft.is_file() {
    (B[m[32m+                    println!("- {}", e.path().display());
    (B[m[32m+                    any = true;
    (B[m[32m+                }
    (B[m[32m+            }
    (B[m         }
    [31m-        if !any { println!("{}", "(no backups)".dimmed()); }
    (B[m[32m+        if !any {
    (B[m[32m+            println!("{}", "(no backups)".dimmed());
    (B[m[32m+        }
    (B[m     } else {
             println!("{}", "(directory 'backups' not found)".dimmed());
         }
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:36:
     }
     
     impl MemoryCommand {
    [31m-    pub async fn execute(self) -> Result<()> { handle(self.command).await }
    (B[m[32m+    pub async fn execute(self) -> Result<()> {
    (B[m[32m+        handle(self.command).await
    (B[m[32m+    }
    (B[m }
     
     async fn handle(cmd: MemorySubcommand) -> Result<()> {
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:52:
                 let results = svc.search(&query, top_k).await?;
                 println!("{} Результатов: {}", "🔎".yellow(), results.len());
                 for (i, rec) in results.iter().enumerate() {
    [31m-                println!("{} {} {}", format!("{}.", i + 1).bold(), rec.id, rec.created_ms);
    (B[m[31m-                if !rec.tags.is_empty() { println!("   tags: {:?}", rec.tags); }
    (B[m[32m+                println!(
    (B[m[32m+                    "{} {} {}",
    (B[m[32m+                    format!("{}.", i + 1).bold(),
    (B[m[32m+                    rec.id,
    (B[m[32m+                    rec.created_ms
    (B[m[32m+                );
    (B[m[32m+                if !rec.tags.is_empty() {
    (B[m[32m+                    println!("   tags: {:?}", rec.tags);
    (B[m[32m+                }
    (B[m                 println!("   {}", rec.text);
                 }
             }
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:60:
             MemorySubcommand::Stats => {
                 let h = svc.check_health().await?;
    [31m-            println!("{} healthy={}, records={}", "Σ".yellow(), h.healthy, h.records);
    (B[m[32m+            println!(
    (B[m[32m+                "{} healthy={}, records={}",
    (B[m[32m+                "Σ".yellow(),
    (B[m[32m+                h.healthy,
    (B[m[32m+                h.records
    (B[m[32m+            );
    (B[m         }
         }
         Ok(())
    Diff in /workspace/crates/cli/src/commands/memory_stub.rs:66:
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/mod.rs:4:
     #[cfg(feature = "minimal")]
     pub mod memory_stub;
     pub mod models;
    [31m-pub mod tools;
    (B[m pub mod smart;
     pub mod tasks;
    [32m+pub mod tools;
    (B[m 
     pub use gpu::GpuCommand;
     #[cfg(not(feature = "minimal"))]
    Diff in /workspace/crates/cli/src/commands/mod.rs:14:
     #[cfg(feature = "minimal")]
     pub use memory_stub::MemoryCommand;
     pub use models::ModelsCommand;
    [31m-pub use tools::ToolsCommand;
    (B[m pub use smart::SmartCommand;
     pub use tasks::TasksCommand;
    [32m+pub use tools::ToolsCommand;
    (B[m 
    Diff in /workspace/crates/cli/src/commands/smart.rs:1:
     use anyhow::{anyhow, Result};
    [32m+use async_trait::async_trait;
    (B[m use clap::Args;
     use colored::*;
     use domain::orchestrator::{Executor, Goal, Orchestrator, Plan, Planner, StepResult, StepStatus};
    Diff in /workspace/crates/cli/src/commands/smart.rs:5:
    [31m-use async_trait::async_trait;
    (B[m[31m-use tools::{Tool, ToolInput, ToolOutput, ToolRegistry};
    (B[m use std::collections::HashMap;
    [31m-use todo::{TodoService, Priority, TaskState, TodoItem, create_default_service};
    (B[m[31m-use std::path::PathBuf;
    (B[m use std::fs;
    [32m+use std::path::PathBuf;
    (B[m[32m+use todo::{create_default_service, Priority, TaskState, TodoItem, TodoService};
    (B[m[32m+use tools::{Tool, ToolInput, ToolOutput, ToolRegistry};
    (B[m 
     #[derive(Debug)]
     struct SimplePlanner;
    Diff in /workspace/crates/cli/src/commands/smart.rs:62:
                         if !out.result.trim().is_empty() {
                             if let Ok(path) = save_text_artifact(&task.id, &out.result) {
                                 let mut meta = std::collections::HashMap::new();
    [31m-                            meta.insert("artifact_path".to_string(), serde_json::json!(path.to_string_lossy()));
    (B[m[31m-                            meta.insert("tool".to_string(), serde_json::json!(step.tool_hint.clone().unwrap_or_else(|| "auto".to_string())));
    (B[m[32m+                            meta.insert(
    (B[m[32m+                                "artifact_path".to_string(),
    (B[m[32m+                                serde_json::json!(path.to_string_lossy()),
    (B[m[32m+                            );
    (B[m[32m+                            meta.insert(
    (B[m[32m+                                "tool".to_string(),
    (B[m[32m+                                serde_json::json!(step
    (B[m[32m+                                    .tool_hint
    (B[m[32m+                                    .clone()
    (B[m[32m+                                    .unwrap_or_else(|| "auto".to_string())),
    (B[m[32m+                            );
    (B[m                             todo_service.upsert_metadata(&task.id, meta).await.ok();
                             }
                         }
    Diff in /workspace/crates/cli/src/commands/smart.rs:79:
                         let mut meta = std::collections::HashMap::new();
                         meta.insert("error".to_string(), serde_json::json!(e.to_string()));
                         todo_service.upsert_metadata(&task.id, meta).await.ok();
    [31m-                    todo_service.update_state(&task.id, TaskState::Failed).await?;
    (B[m[32m+                    todo_service
    (B[m[32m+                        .update_state(&task.id, TaskState::Failed)
    (B[m[32m+                        .await?;
    (B[m                     results.push(StepResult {
                             step_id: step.id.clone(),
    [31m-                        status: StepStatus::Failed { error: e.to_string() },
    (B[m[32m+                        status: StepStatus::Failed {
    (B[m[32m+                            error: e.to_string(),
    (B[m[32m+                        },
    (B[m                         output: None,
                             artifacts: vec![],
                         })
    Diff in /workspace/crates/cli/src/commands/smart.rs:110:
         let mut path = dir;
         path.push(format!("{}.txt", task_id));
         // Ограничим размер до ~64KB
    [31m-    let truncated = if text.len() > 64 * 1024 { &text[..64 * 1024] } else { text };
    (B[m[32m+    let truncated = if text.len() > 64 * 1024 {
    (B[m[32m+        &text[..64 * 1024]
    (B[m[32m+    } else {
    (B[m[32m+        text
    (B[m[32m+    };
    (B[m     fs::write(&path, truncated)?;
         Ok(path)
     }
    Diff in /workspace/crates/cli/src/commands/smart.rs:126:
     }
     
     #[async_trait]
    [31m-impl<P: Planner + Send + Sync, E: Executor + Send + Sync> Orchestrator for SimpleOrchestrator<P, E> {
    (B[m[32m+impl<P: Planner + Send + Sync, E: Executor + Send + Sync> Orchestrator
    (B[m[32m+    for SimpleOrchestrator<P, E>
    (B[m[32m+{
    (B[m     async fn plan(&self, goal: Goal) -> Result<Plan> {
             self.planner.create_plan(&goal).await
         }
    Diff in /workspace/crates/cli/src/commands/smart.rs:166:
         }
     
         let results = orchestrator.run(plan).await?;
    [31m-    println!("{} Выполнение завершено: {} шаг(ов)", "✓".green(), results.len());
    (B[m[32m+    println!(
    (B[m[32m+        "{} Выполнение завершено: {} шаг(ов)",
    (B[m[32m+        "✓".green(),
    (B[m[32m+        results.len()
    (B[m[32m+    );
    (B[m     for r in results {
             println!("  • {}: {:?}", r.step_id.bold(), r.status);
             if let Some(out) = r.output {
    Diff in /workspace/crates/cli/src/commands/smart.rs:173:
    [31m-            if !out.trim().is_empty() { println!("{}", out); }
    (B[m[32m+            if !out.trim().is_empty() {
    (B[m[32m+                println!("{}", out);
    (B[m[32m+            }
    (B[m         }
         }
     
    Diff in /workspace/crates/cli/src/commands/smart.rs:184:
         {
             return Some("file_read".to_string());
         }
    [31m-    if lower.contains("создай файл") || lower.contains("write") || lower.contains("запиши в файл") {
    (B[m[32m+    if lower.contains("создай файл") || lower.contains("write") || lower.contains("запиши в файл")
    (B[m[32m+    {
    (B[m         return Some("file_write".to_string());
         }
    [31m-    if lower.contains("папк") || lower.contains("директор") || lower.contains("list dir") || lower.contains("ls ") {
    (B[m[32m+    if lower.contains("папк")
    (B[m[32m+        || lower.contains("директор")
    (B[m[32m+        || lower.contains("list dir")
    (B[m[32m+        || lower.contains("ls ")
    (B[m[32m+    {
    (B[m         return Some("dir_list".to_string());
         }
         if lower.contains("git diff") || lower.contains("показать diff") {
    Diff in /workspace/crates/cli/src/commands/smart.rs:199:
         if lower.contains("git commit") || lower.contains("коммит") {
             return Some("git_commit".to_string());
         }
    [31m-    if lower.starts_with("выполни") || lower.contains("выполни команду") || lower.starts_with("exec") || lower.starts_with("run ") {
    (B[m[32m+    if lower.starts_with("выполни")
    (B[m[32m+        || lower.contains("выполни команду")
    (B[m[32m+        || lower.starts_with("exec")
    (B[m[32m+        || lower.starts_with("run ")
    (B[m[32m+    {
    (B[m         return Some("shell_exec".to_string());
         }
         if lower.contains("найди ") || lower.contains("поиск ") || lower.contains("search ") {
    Diff in /workspace/crates/cli/src/commands/smart.rs:209:
     }
     
     fn looks_like_path(text: &str) -> bool {
    [31m-    text.contains('/') || text.contains('\\') || text.contains(".rs") || text.contains(".md") || text.contains(".toml")
    (B[m[32m+    text.contains('/')
    (B[m[32m+        || text.contains('\\')
    (B[m[32m+        || text.contains(".rs")
    (B[m[32m+        || text.contains(".md")
    (B[m[32m+        || text.contains(".toml")
    (B[m }
     
    [31m-async fn execute_step(registry: &ToolRegistry, description: &str, hint: Option<String>) -> Result<ToolOutput> {
    (B[m[32m+async fn execute_step(
    (B[m[32m+    registry: &ToolRegistry,
    (B[m[32m+    description: &str,
    (B[m[32m+    hint: Option<String>,
    (B[m[32m+) -> Result<ToolOutput> {
    (B[m     if let Some(name) = hint {
             if let Some(tool) = registry.get(&name) {
                 // Попробуем использовать парсер NL, иначе отправим пустые args
    Diff in /workspace/crates/cli/src/commands/smart.rs:219:
                 let input = if tool.supports_natural_language() {
                     match tool.parse_natural_language(description).await {
    [31m-                    Ok(mut i) => { i.dry_run = false; i.timeout_ms = None; i },
    (B[m[31m-                    Err(_) => ToolInput { command: name.clone(), args: HashMap::new(), context: Some(description.to_string()), dry_run: false, timeout_ms: None },
    (B[m[32m+                    Ok(mut i) => {
    (B[m[32m+                        i.dry_run = false;
    (B[m[32m+                        i.timeout_ms = None;
    (B[m[32m+                        i
    (B[m[32m+                    }
    (B[m[32m+                    Err(_) => ToolInput {
    (B[m[32m+                        command: name.clone(),
    (B[m[32m+                        args: HashMap::new(),
    (B[m[32m+                        context: Some(description.to_string()),
    (B[m[32m+                        dry_run: false,
    (B[m[32m+                        timeout_ms: None,
    (B[m[32m+                    },
    (B[m                 }
                 } else {
    [31m-                ToolInput { command: name.clone(), args: HashMap::new(), context: Some(description.to_string()), dry_run: false, timeout_ms: None }
    (B[m[32m+                ToolInput {
    (B[m[32m+                    command: name.clone(),
    (B[m[32m+                    args: HashMap::new(),
    (B[m[32m+                    context: Some(description.to_string()),
    (B[m[32m+                    dry_run: false,
    (B[m[32m+                    timeout_ms: None,
    (B[m[32m+                }
    (B[m             };
                 return tool.execute(input).await;
             } else {
    Diff in /workspace/crates/cli/src/commands/smart.rs:232:
     
         // Автовыбор: пробуем набор инструментов в приоритетном порядке
         let candidates = [
    [31m-        "file_read", "file_write", "dir_list", "git_status", "git_diff", "git_commit", "shell_exec", "web_search",
    (B[m[32m+        "file_read",
    (B[m[32m+        "file_write",
    (B[m[32m+        "dir_list",
    (B[m[32m+        "git_status",
    (B[m[32m+        "git_diff",
    (B[m[32m+        "git_commit",
    (B[m[32m+        "shell_exec",
    (B[m[32m+        "web_search",
    (B[m     ];
     
         for name in candidates {
    Diff in /workspace/crates/cli/src/commands/smart.rs:239:
             if let Some(tool) = registry.get(name) {
    [31m-            if !tool.supports_natural_language() { continue; }
    (B[m[32m+            if !tool.supports_natural_language() {
    (B[m[32m+                continue;
    (B[m[32m+            }
    (B[m             if let Ok(input) = tool.parse_natural_language(description).await {
                     // Если парсер выдал какие‑то аргументы — пробуем исполнить
                     if !input.args.is_empty() || input.context.is_some() {
    Diff in /workspace/crates/cli/src/commands/smart.rs:249:
     
         Err(anyhow!("Не удалось подобрать инструмент для шага"))
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/tasks.rs:13:
     pub enum TasksSubcommand {
         /// Показать N готовых задач
         #[command(name = "list")]
    [31m-    List { #[arg(long, default_value_t = 20)] limit: usize },
    (B[m[32m+    List {
    (B[m[32m+        #[arg(long, default_value_t = 20)]
    (B[m[32m+        limit: usize,
    (B[m[32m+    },
    (B[m     /// Показать задачу по ID
         #[command(name = "show")]
         Show { id: String },
    Diff in /workspace/crates/cli/src/commands/tasks.rs:29:
     }
     
     impl TasksCommand {
    [31m-    pub async fn execute(self) -> Result<()> { handle(self.command).await }
    (B[m[32m+    pub async fn execute(self) -> Result<()> {
    (B[m[32m+        handle(self.command).await
    (B[m[32m+    }
    (B[m }
     
     async fn handle(cmd: TasksSubcommand) -> Result<()> {
    Diff in /workspace/crates/cli/src/commands/tasks.rs:39:
         match cmd {
             TasksSubcommand::List { limit } => {
                 let tasks = svc.get_next_ready(limit).await?;
    [31m-            println!("{} {}", "✓".green(), format!("Готовые задачи: {}", tasks.len()).bold());
    (B[m[32m+            println!(
    (B[m[32m+                "{} {}",
    (B[m[32m+                "✓".green(),
    (B[m[32m+                format!("Готовые задачи: {}", tasks.len()).bold()
    (B[m[32m+            );
    (B[m             for t in tasks {
    [31m-                println!("- {} {} [{}]", t.id, t.title.bold(), format!("{:?}", t.priority).to_lowercase());
    (B[m[32m+                println!(
    (B[m[32m+                    "- {} {} [{}]",
    (B[m[32m+                    t.id,
    (B[m[32m+                    t.title.bold(),
    (B[m[32m+                    format!("{:?}", t.priority).to_lowercase()
    (B[m[32m+                );
    (B[m             }
             }
             TasksSubcommand::Show { id } => {
    Diff in /workspace/crates/cli/src/commands/tasks.rs:52:
                     println!("  state: {:?}", t.state);
                     println!("  created: {}", t.created_at);
                     println!("  updated: {}", t.updated_at);
    [31m-                if let Some(r) = &t.reasoning { println!("  reasoning: {}", r); }
    (B[m[31m-                if let Some(tool) = &t.tool_hint { println!("  tool_hint: {}", tool); }
    (B[m[32m+                if let Some(r) = &t.reasoning {
    (B[m[32m+                    println!("  reasoning: {}", r);
    (B[m[32m+                }
    (B[m[32m+                if let Some(tool) = &t.tool_hint {
    (B[m[32m+                    println!("  tool_hint: {}", tool);
    (B[m[32m+                }
    (B[m             } else {
                     println!("{} Задача не найдена", "✗".red());
                 }
    Diff in /workspace/crates/cli/src/commands/tasks.rs:72:
                 let (task_stats, graph_stats) = svc.get_stats().await?;
                 println!("{} Статистика задач", "Σ".yellow());
                 println!("  total: {}", task_stats.total);
    [31m-            println!("  ready: {}  in_progress: {}  blocked: {}",
    (B[m[31m-                     task_stats.ready, task_stats.in_progress, task_stats.blocked);
    (B[m[31m-            println!("  done: {}  failed: {}  cancelled: {}",
    (B[m[31m-                     task_stats.done, task_stats.failed, task_stats.cancelled);
    (B[m[31m-            println!("{} Граф: total_tasks={}, total_deps={}, cache_entries={}",
    (B[m[31m-                     "ℹ".blue(), graph_stats.total_tasks, graph_stats.total_dependencies, graph_stats.cache_size);
    (B[m[32m+            println!(
    (B[m[32m+                "  ready: {}  in_progress: {}  blocked: {}",
    (B[m[32m+                task_stats.ready, task_stats.in_progress, task_stats.blocked
    (B[m[32m+            );
    (B[m[32m+            println!(
    (B[m[32m+                "  done: {}  failed: {}  cancelled: {}",
    (B[m[32m+                task_stats.done, task_stats.failed, task_stats.cancelled
    (B[m[32m+            );
    (B[m[32m+            println!(
    (B[m[32m+                "{} Граф: total_tasks={}, total_deps={}, cache_entries={}",
    (B[m[32m+                "ℹ".blue(),
    (B[m[32m+                graph_stats.total_tasks,
    (B[m[32m+                graph_stats.total_dependencies,
    (B[m[32m+                graph_stats.cache_size
    (B[m[32m+            );
    (B[m         }
         }
         Ok(())
    Diff in /workspace/crates/cli/src/commands/tasks.rs:84:
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/commands/tools.rs:1:
     use anyhow::Result;
     use clap::{Args, Subcommand};
     use colored::*;
    [31m-use tools::ToolRegistry;
    (B[m[32m+use common::policy::{
    (B[m[32m+    load_effective_policy, PolicyAction, PolicyDocument, PolicyEngine, PolicyRule,
    (B[m[32m+    PolicySubjectKind,
    (B[m[32m+};
    (B[m[32m+use common::{events, topics};
    (B[m use serde::{Deserialize, Serialize};
     use std::fs;
    [31m-use common::{events, topics};
    (B[m[31m-use common::policy::{PolicyDocument, PolicyEngine, PolicyRule, PolicySubjectKind, PolicyAction, load_effective_policy};
    (B[m[31m-use tools::intelligent_selector::{IntelligentToolSelector, SelectorConfig, ToolSelectionContext, TaskComplexity, UrgencyLevel, UserExpertise};
    (B[m[32m+use tools::intelligent_selector::{
    (B[m[32m+    IntelligentToolSelector, SelectorConfig, TaskComplexity, ToolSelectionContext, UrgencyLevel,
    (B[m[32m+    UserExpertise,
    (B[m[32m+};
    (B[m[32m+use tools::ToolRegistry;
    (B[m 
     #[derive(Debug, Serialize, Deserialize, Clone)]
     struct McpToolConfig {
    Diff in /workspace/crates/cli/src/commands/tools.rs:50:
     
     fn preload_persisted_into_registry(registry: &mut ToolRegistry) {
         for cfg in load_persisted_mcp() {
    [31m-        registry.register_mcp_tool(&cfg.name, cfg.cmd.clone(), cfg.args.clone(), cfg.remote_tool.clone(), cfg.description.clone());
    (B[m[32m+        registry.register_mcp_tool(
    (B[m[32m+            &cfg.name,
    (B[m[32m+            cfg.cmd.clone(),
    (B[m[32m+            cfg.args.clone(),
    (B[m[32m+            cfg.remote_tool.clone(),
    (B[m[32m+            cfg.description.clone(),
    (B[m[32m+        );
    (B[m     }
     }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:61:
             if let Ok(content) = fs::read_to_string(path) {
                 if let Ok(json) = serde_json::from_str::<serde_json::Value>(&content) {
                     if let Some(obj) = json.as_object() {
    [31m-                    for (k, v) in obj { map.insert(k.clone(), v.clone()); }
    (B[m[32m+                    for (k, v) in obj {
    (B[m[32m+                        map.insert(k.clone(), v.clone());
    (B[m[32m+                    }
    (B[m                 }
                 }
             }
    Diff in /workspace/crates/cli/src/commands/tools.rs:70:
             if !json_str.trim().is_empty() {
                 if let Ok(json) = serde_json::from_str::<serde_json::Value>(&json_str) {
                     if let Some(obj) = json.as_object() {
    [31m-                    for (k, v) in obj { map.insert(k.clone(), v.clone()); }
    (B[m[32m+                    for (k, v) in obj {
    (B[m[32m+                        map.insert(k.clone(), v.clone());
    (B[m[32m+                    }
    (B[m                 }
                 }
             }
    Diff in /workspace/crates/cli/src/commands/tools.rs:80:
     
     fn apply_usage_guide_override(spec: &mut tools::ToolSpec, override_v: &serde_json::Value) {
         // Merge only known fields; create UsageGuide if absent
    [31m-    let mut guide = spec.usage_guide.clone().unwrap_or_else(|| tools::generate_usage_guide(spec));
    (B[m[32m+    let mut guide = spec
    (B[m[32m+        .usage_guide
    (B[m[32m+        .clone()
    (B[m[32m+        .unwrap_or_else(|| tools::generate_usage_guide(spec));
    (B[m     if let Some(obj) = override_v.as_object() {
    [31m-        if let Some(v) = obj.get("usage_title").and_then(|v| v.as_str()) { guide.usage_title = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("usage_summary").and_then(|v| v.as_str()) { guide.usage_summary = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("preconditions").and_then(|v| v.as_array()) { guide.preconditions = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[32m+        if let Some(v) = obj.get("usage_title").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.usage_title = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("usage_summary").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.usage_summary = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("preconditions").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.preconditions = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m         if let Some(v) = obj.get("arguments_brief").and_then(|v| v.as_object()) {
                 let mut ab = std::collections::HashMap::new();
    [31m-            for (k, val) in v { if let Some(s) = val.as_str() { ab.insert(k.clone(), s.to_string()); } }
    (B[m[32m+            for (k, val) in v {
    (B[m[32m+                if let Some(s) = val.as_str() {
    (B[m[32m+                    ab.insert(k.clone(), s.to_string());
    (B[m[32m+                }
    (B[m[32m+            }
    (B[m             guide.arguments_brief = ab;
             }
    [31m-        if let Some(v) = obj.get("good_for").and_then(|v| v.as_array()) { guide.good_for = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("not_for").and_then(|v| v.as_array()) { guide.not_for = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("constraints").and_then(|v| v.as_array()) { guide.constraints = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("examples").and_then(|v| v.as_array()) { guide.examples = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("platforms").and_then(|v| v.as_array()) { guide.platforms = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("cost_class").and_then(|v| v.as_str()) { guide.cost_class = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("latency_class").and_then(|v| v.as_str()) { guide.latency_class = v.into(); }
    (B[m[31m-        if let Some(v) = obj.get("side_effects").and_then(|v| v.as_array()) { guide.side_effects = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("risk_score").and_then(|v| v.as_u64()) { guide.risk_score = v as u8; }
    (B[m[31m-        if let Some(v) = obj.get("capabilities").and_then(|v| v.as_array()) { guide.capabilities = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[31m-        if let Some(v) = obj.get("tags").and_then(|v| v.as_array()) { guide.tags = v.iter().filter_map(|x| x.as_str().map(|s| s.to_string())).collect(); }
    (B[m[32m+        if let Some(v) = obj.get("good_for").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.good_for = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("not_for").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.not_for = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("constraints").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.constraints = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("examples").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.examples = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("platforms").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.platforms = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("cost_class").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.cost_class = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("latency_class").and_then(|v| v.as_str()) {
    (B[m[32m+            guide.latency_class = v.into();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("side_effects").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.side_effects = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("risk_score").and_then(|v| v.as_u64()) {
    (B[m[32m+            guide.risk_score = v as u8;
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("capabilities").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.capabilities = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m[32m+        if let Some(v) = obj.get("tags").and_then(|v| v.as_array()) {
    (B[m[32m+            guide.tags = v
    (B[m[32m+                .iter()
    (B[m[32m+                .filter_map(|x| x.as_str().map(|s| s.to_string()))
    (B[m[32m+                .collect();
    (B[m[32m+        }
    (B[m     }
         spec.usage_guide = Some(guide);
     }
    Diff in /workspace/crates/cli/src/commands/tools.rs:107:
     
    [31m-fn map_plugin_perms_to_tools_permissions(p: &tools::registry::ToolPermissions) -> Option<tools::ToolPermissions> {
    (B[m[32m+fn map_plugin_perms_to_tools_permissions(
    (B[m[32m+    p: &tools::registry::ToolPermissions,
    (B[m[32m+) -> Option<tools::ToolPermissions> {
    (B[m     use tools::registry::{FileSystemPermissions, NetworkPermissions};
         let mut fs_read = Vec::new();
         let mut fs_write = Vec::new();
    Diff in /workspace/crates/cli/src/commands/tools.rs:112:
         match &p.file_system {
             FileSystemPermissions::None => {}
    [31m-        FileSystemPermissions::ReadOnly => { fs_read.push("/".into()); }
    (B[m[31m-        FileSystemPermissions::ReadWrite | FileSystemPermissions::FullAccess => { fs_read.push("/".into()); fs_write.push("/".into()); }
    (B[m[32m+        FileSystemPermissions::ReadOnly => {
    (B[m[32m+            fs_read.push("/".into());
    (B[m[32m+        }
    (B[m[32m+        FileSystemPermissions::ReadWrite | FileSystemPermissions::FullAccess => {
    (B[m[32m+            fs_read.push("/".into());
    (B[m[32m+            fs_write.push("/".into());
    (B[m[32m+        }
    (B[m         FileSystemPermissions::Restricted { allowed_paths } => {
    [31m-            for ap in allowed_paths { fs_read.push(ap.clone()); fs_write.push(ap.clone()); }
    (B[m[32m+            for ap in allowed_paths {
    (B[m[32m+                fs_read.push(ap.clone());
    (B[m[32m+                fs_write.push(ap.clone());
    (B[m[32m+            }
    (B[m         }
         }
         let mut net = Vec::new();
    Diff in /workspace/crates/cli/src/commands/tools.rs:121:
         match &p.network {
             NetworkPermissions::None => {}
    [31m-        NetworkPermissions::LocalHost => { net.push("localhost".into()); net.push("127.0.0.1".into()); }
    (B[m[32m+        NetworkPermissions::LocalHost => {
    (B[m[32m+            net.push("localhost".into());
    (B[m[32m+            net.push("127.0.0.1".into());
    (B[m[32m+        }
    (B[m         NetworkPermissions::InternalNetworks => { /* keep empty to enforce env allowlist */ }
             NetworkPermissions::Internet => { /* empty -> allow by env */ }
    [31m-        NetworkPermissions::Restricted { allowed_hosts } => { for h in allowed_hosts { net.push(h.clone()); } }
    (B[m[32m+        NetworkPermissions::Restricted { allowed_hosts } => {
    (B[m[32m+            for h in allowed_hosts {
    (B[m[32m+                net.push(h.clone());
    (B[m[32m+            }
    (B[m[32m+        }
    (B[m     }
    [31m-    Some(tools::ToolPermissions { fs_read_roots: fs_read, fs_write_roots: fs_write, net_allowlist: net, allow_shell: false })
    (B[m[32m+    Some(tools::ToolPermissions {
    (B[m[32m+        fs_read_roots: fs_read,
    (B[m[32m+        fs_write_roots: fs_write,
    (B[m[32m+        net_allowlist: net,
    (B[m[32m+        allow_shell: false,
    (B[m[32m+    })
    (B[m }
     
     #[derive(Debug, Args)]
    Diff in /workspace/crates/cli/src/commands/tools.rs:248:
     }
     
     impl ToolsCommand {
    [31m-    pub async fn execute(self) -> Result<()> { handle_tools_command(self.command).await }
    (B[m[32m+    pub async fn execute(self) -> Result<()> {
    (B[m[32m+        handle_tools_command(self.command).await
    (B[m[32m+    }
    (B[m }
     
     fn parse_kv(s: &str) -> Result<(String, String), String> {
    Diff in /workspace/crates/cli/src/commands/tools.rs:255:
    [31m-    let (k, v) = s.split_once('=').ok_or_else(|| "arg must be in key=value format".to_string())?;
    (B[m[32m+    let (k, v) = s
    (B[m[32m+        .split_once('=')
    (B[m[32m+        .ok_or_else(|| "arg must be in key=value format".to_string())?;
    (B[m     Ok((k.to_string(), v.to_string()))
     }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:263:
     
         // Helper: export plugins into registry (quiet; best-effort)
         async fn export_plugins_into_registry(registry: &mut ToolRegistry) {
    [31m-        if std::env::var("MAGRAY_EXPORT_PLUGINS_AS_TOOLS").ok().map(|s| s=="1" || s.to_lowercase()=="true").unwrap_or(true) {
    (B[m[32m+        if std::env::var("MAGRAY_EXPORT_PLUGINS_AS_TOOLS")
    (B[m[32m+            .ok()
    (B[m[32m+            .map(|s| s == "1" || s.to_lowercase() == "true")
    (B[m[32m+            .unwrap_or(true)
    (B[m[32m+        {
    (B[m             let mut home = crate::util::magray_home();
    [31m-            let mut plugins_dir = home.clone(); plugins_dir.push("plugins");
    (B[m[31m-            let mut cfg_dir = home.clone(); cfg_dir.push("plugin-configs");
    (B[m[32m+            let mut plugins_dir = home.clone();
    (B[m[32m+            plugins_dir.push("plugins");
    (B[m[32m+            let mut cfg_dir = home.clone();
    (B[m[32m+            cfg_dir.push("plugin-configs");
    (B[m             let _ = tokio::fs::create_dir_all(&plugins_dir).await;
                 let _ = tokio::fs::create_dir_all(&cfg_dir).await;
    [31m-            let pregistry = tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m[32m+            let pregistry =
    (B[m[32m+                tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m             let _ = pregistry.load_manifests_from_directory().await;
                 let _ = pregistry.load_from_filesystem().await;
                 let plugins = pregistry.list_plugins(None).await;
    Diff in /workspace/crates/cli/src/commands/tools.rs:276:
                 for p in plugins {
    [31m-                if matches!(p.plugin_type, tools::plugins::plugin_manager::PluginType::Wasm | tools::plugins::plugin_manager::PluginType::ExternalProcess) {
    (B[m[32m+                if matches!(
    (B[m[32m+                    p.plugin_type,
    (B[m[32m+                    tools::plugins::plugin_manager::PluginType::Wasm
    (B[m[32m+                        | tools::plugins::plugin_manager::PluginType::ExternalProcess
    (B[m[32m+                ) {
    (B[m                     if let Ok(tool_box) = pregistry.materialize_as_tool(&p.id).await {
                             registry.register(&p.id, tool_box);
                         }
    Diff in /workspace/crates/cli/src/commands/tools.rs:292:
                 let mut specs = registry.list_tools();
                 // Apply overrides
                 for spec in &mut specs {
    [31m-                if let Some(ov) = guide_overrides.get(&spec.name) { apply_usage_guide_override(spec, ov); }
    (B[m[32m+                if let Some(ov) = guide_overrides.get(&spec.name) {
    (B[m[32m+                    apply_usage_guide_override(spec, ov);
    (B[m[32m+                }
    (B[m             }
                 if json {
                     println!("{}", serde_json::to_string_pretty(&specs)?);
    Diff in /workspace/crates/cli/src/commands/tools.rs:302:
                 if details {
                     // Effective sandbox summary from env (centralized)
                     let cfg = common::sandbox_config::SandboxConfig::from_env();
    [31m-                println!("  FS sandbox: {}  roots: {}", if cfg.fs.enabled { "on" } else { "off" }, if cfg.fs.roots.is_empty() { "<none>" } else { &cfg.fs.roots.join(":") });
    (B[m[31m-                let net = if cfg.net.allowlist.is_empty() { "<none>".to_string() } else { cfg.net.allowlist.join(",") };
    (B[m[32m+                println!(
    (B[m[32m+                    "  FS sandbox: {}  roots: {}",
    (B[m[32m+                    if cfg.fs.enabled { "on" } else { "off" },
    (B[m[32m+                    if cfg.fs.roots.is_empty() {
    (B[m[32m+                        "<none>"
    (B[m[32m+                    } else {
    (B[m[32m+                        &cfg.fs.roots.join(":")
    (B[m[32m+                    }
    (B[m[32m+                );
    (B[m[32m+                let net = if cfg.net.allowlist.is_empty() {
    (B[m[32m+                    "<none>".to_string()
    (B[m[32m+                } else {
    (B[m[32m+                    cfg.net.allowlist.join(",")
    (B[m[32m+                };
    (B[m                 println!("  NET allow: {}", net);
    [31m-                println!("  SHELL allow: {}", if cfg.shell.allow_shell { "yes" } else { "no" });
    (B[m[32m+                println!(
    (B[m[32m+                    "  SHELL allow: {}",
    (B[m[32m+                    if cfg.shell.allow_shell { "yes" } else { "no" }
    (B[m[32m+                );
    (B[m             }
                 for spec in specs {
                     println!("- {}: {}", spec.name.bold(), spec.description);
    Diff in /workspace/crates/cli/src/commands/tools.rs:312:
                     if details {
                         println!("  usage: {}", spec.usage);
    [31m-                    println!("  supports_dry_run: {}", if spec.supports_dry_run { "true" } else { "false" });
    (B[m[32m+                    println!(
    (B[m[32m+                        "  supports_dry_run: {}",
    (B[m[32m+                        if spec.supports_dry_run {
    (B[m[32m+                            "true"
    (B[m[32m+                        } else {
    (B[m[32m+                            "false"
    (B[m[32m+                        }
    (B[m[32m+                    );
    (B[m                     if let Some(perms) = &spec.permissions {
    [31m-                        if !perms.fs_read_roots.is_empty() { println!("  perm.fs_read: {}", perms.fs_read_roots.join(":")); }
    (B[m[31m-                        if !perms.fs_write_roots.is_empty() { println!("  perm.fs_write: {}", perms.fs_write_roots.join(":")); }
    (B[m[31m-                        if !perms.net_allowlist.is_empty() { println!("  perm.net_allow: {}", perms.net_allowlist.join(",")); }
    (B[m[31m-                        if perms.allow_shell { println!("  perm.shell: allow"); }
    (B[m[32m+                        if !perms.fs_read_roots.is_empty() {
    (B[m[32m+                            println!("  perm.fs_read: {}", perms.fs_read_roots.join(":"));
    (B[m[32m+                        }
    (B[m[32m+                        if !perms.fs_write_roots.is_empty() {
    (B[m[32m+                            println!("  perm.fs_write: {}", perms.fs_write_roots.join(":"));
    (B[m[32m+                        }
    (B[m[32m+                        if !perms.net_allowlist.is_empty() {
    (B[m[32m+                            println!("  perm.net_allow: {}", perms.net_allowlist.join(","));
    (B[m[32m+                        }
    (B[m[32m+                        if perms.allow_shell {
    (B[m[32m+                            println!("  perm.shell: allow");
    (B[m[32m+                        }
    (B[m                     }
                         if let Some(guide) = &spec.usage_guide {
    [31m-                        if !guide.good_for.is_empty() { println!("  good_for: {}", guide.good_for.join(", ")); }
    (B[m[31m-                        if !guide.tags.is_empty() { println!("  tags: {}", guide.tags.join(", ")); }
    (B[m[31m-                        if !guide.capabilities.is_empty() { println!("  capabilities: {}", guide.capabilities.join(", ")); }
    (B[m[31m-                        println!("  latency: {}  risk: {}", guide.latency_class, guide.risk_score);
    (B[m[32m+                        if !guide.good_for.is_empty() {
    (B[m[32m+                            println!("  good_for: {}", guide.good_for.join(", "));
    (B[m[32m+                        }
    (B[m[32m+                        if !guide.tags.is_empty() {
    (B[m[32m+                            println!("  tags: {}", guide.tags.join(", "));
    (B[m[32m+                        }
    (B[m[32m+                        if !guide.capabilities.is_empty() {
    (B[m[32m+                            println!("  capabilities: {}", guide.capabilities.join(", "));
    (B[m[32m+                        }
    (B[m[32m+                        println!(
    (B[m[32m+                            "  latency: {}  risk: {}",
    (B[m[32m+                            guide.latency_class, guide.risk_score
    (B[m[32m+                        );
    (B[m                     }
                     }
                 }
    Diff in /workspace/crates/cli/src/commands/tools.rs:340:
                             let ok = v.get("successes").and_then(|x| x.as_u64()).unwrap_or(0);
                             let ask = v.get("asks").and_then(|x| x.as_u64()).unwrap_or(0);
                             let deny = v.get("denies").and_then(|x| x.as_u64()).unwrap_or(0);
    [31m-                        println!("- {}: invocations={}, successes={}, asks={}, denies={}", tool.bold(), inv, ok, ask, deny);
    (B[m[32m+                        println!(
    (B[m[32m+                            "- {}: invocations={}, successes={}, asks={}, denies={}",
    (B[m[32m+                            tool.bold(),
    (B[m[32m+                            inv,
    (B[m[32m+                            ok,
    (B[m[32m+                            ask,
    (B[m[32m+                            deny
    (B[m[32m+                        );
    (B[m                     }
                     } else {
                         println!("(нет данных)");
    Diff in /workspace/crates/cli/src/commands/tools.rs:348:
                 }
                 Ok(())
             }
    [31m-        ToolsSubcommand::Select { query, urgency, json } => {
    (B[m[31m-            if !json { export_plugins_into_registry(&mut registry).await; }
    (B[m[32m+        ToolsSubcommand::Select {
    (B[m[32m+            query,
    (B[m[32m+            urgency,
    (B[m[32m+            json,
    (B[m[32m+        } => {
    (B[m[32m+            if !json {
    (B[m[32m+                export_plugins_into_registry(&mut registry).await;
    (B[m[32m+            }
    (B[m             // Build selector and register all tools from registry's specs
                 let mut specs = registry.list_tools();
                 for spec in &mut specs {
    Diff in /workspace/crates/cli/src/commands/tools.rs:356:
    [31m-                if let Some(ov) = guide_overrides.get(&spec.name) { apply_usage_guide_override(spec, ov); }
    (B[m[32m+                if let Some(ov) = guide_overrides.get(&spec.name) {
    (B[m[32m+                    apply_usage_guide_override(spec, ov);
    (B[m[32m+                }
    (B[m             }
                 let selector = IntelligentToolSelector::new(SelectorConfig::default());
                 for spec in specs.clone() {
    Diff in /workspace/crates/cli/src/commands/tools.rs:379:
                 } else {
                     println!("{}", "=== Tool Selection ===".bold().cyan());
                     for e in explained {
    [31m-                    println!("- {}: score={:.2} (ctx {:.2}, cap {:.2}, perf {:.2})",
    (B[m[31m-                        e.tool_name.bold(), e.confidence_score, e.context_match, e.capability_match, e.performance_factor);
    (B[m[31m-                    if !e.matched.tags.is_empty() { println!("  tags: {}", e.matched.tags.join(", ")); }
    (B[m[31m-                    if !e.matched.capabilities.is_empty() { println!("  caps: {}", e.matched.capabilities.join(", ")); }
    (B[m[31m-                    if !e.matched.good_for.is_empty() { println!("  good_for: {}", e.matched.good_for.join(", ")); }
    (B[m[32m+                    println!(
    (B[m[32m+                        "- {}: score={:.2} (ctx {:.2}, cap {:.2}, perf {:.2})",
    (B[m[32m+                        e.tool_name.bold(),
    (B[m[32m+                        e.confidence_score,
    (B[m[32m+                        e.context_match,
    (B[m[32m+                        e.capability_match,
    (B[m[32m+                        e.performance_factor
    (B[m[32m+                    );
    (B[m[32m+                    if !e.matched.tags.is_empty() {
    (B[m[32m+                        println!("  tags: {}", e.matched.tags.join(", "));
    (B[m[32m+                    }
    (B[m[32m+                    if !e.matched.capabilities.is_empty() {
    (B[m[32m+                        println!("  caps: {}", e.matched.capabilities.join(", "));
    (B[m[32m+                    }
    (B[m[32m+                    if !e.matched.good_for.is_empty() {
    (B[m[32m+                        println!("  good_for: {}", e.matched.good_for.join(", "));
    (B[m[32m+                    }
    (B[m                     // Show safety-related breakdown
                         println!(
                             "  breakdown: latency_bonus={:.2} low_risk={:.2} perms_adj={:.2} dry_run={:.2}",
    Diff in /workspace/crates/cli/src/commands/tools.rs:412:
                     return Ok(());
                 }
                 // If neither flag provided, show help-like hint
    [31m-            println!("Использование: magray tools sandbox --show | --save --json '<SandboxConfig JSON>'");
    (B[m[32m+            println!(
    (B[m[32m+                "Использование: magray tools sandbox --show | --save --json '<SandboxConfig JSON>'"
    (B[m[32m+            );
    (B[m             Ok(())
             }
    [31m-        ToolsSubcommand::Plugins { list, load_manifests, dir, json, export_tools } => {
    (B[m[32m+        ToolsSubcommand::Plugins {
    (B[m[32m+            list,
    (B[m[32m+            load_manifests,
    (B[m[32m+            dir,
    (B[m[32m+            json,
    (B[m[32m+            export_tools,
    (B[m[32m+        } => {
    (B[m             // Resolve plugin dir and config dir under ~/.magray
                 let mut home = crate::util::magray_home();
    [31m-            let plugins_dir = if let Some(d) = dir { std::path::PathBuf::from(d) } else { let mut p = home.clone(); p.push("plugins"); p };
    (B[m[31m-            let mut cfg_dir = home.clone(); cfg_dir.push("plugin-configs");
    (B[m[32m+            let plugins_dir = if let Some(d) = dir {
    (B[m[32m+                std::path::PathBuf::from(d)
    (B[m[32m+            } else {
    (B[m[32m+                let mut p = home.clone();
    (B[m[32m+                p.push("plugins");
    (B[m[32m+                p
    (B[m[32m+            };
    (B[m[32m+            let mut cfg_dir = home.clone();
    (B[m[32m+            cfg_dir.push("plugin-configs");
    (B[m             tokio::fs::create_dir_all(&plugins_dir).await.ok();
                 tokio::fs::create_dir_all(&cfg_dir).await.ok();
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:426:
    [31m-            let registry = tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m[32m+            let registry =
    (B[m[32m+                tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    (B[m             if load_manifests {
                     let n = registry.load_manifests_from_directory().await?;
                     println!("{} Загрузлено манифестов: {}", "✓".green(), n);
    Diff in /workspace/crates/cli/src/commands/tools.rs:437:
                         for p in &items {
                             println!("- {} v{} — {}", p.name.bold(), p.version, p.description);
                             println!("  type: {:?}  entry: {}", p.plugin_type, p.entry_point);
    [31m-                        println!("  perms: fs={:?} net={:?} sys={:?}", p.required_permissions.file_system, p.required_permissions.network, p.required_permissions.system);
    (B[m[32m+                        println!(
    (B[m[32m+                            "  perms: fs={:?} net={:?} sys={:?}",
    (B[m[32m+                            p.required_permissions.file_system,
    (B[m[32m+                            p.required_permissions.network,
    (B[m[32m+                            p.required_permissions.system
    (B[m[32m+                        );
    (B[m                     }
                     }
                     if export_tools {
    Diff in /workspace/crates/cli/src/commands/tools.rs:444:
                         // Adapt to ToolSpec for visibility (not persisting to registry in this command)
                         let mut specs: Vec<tools::ToolSpec> = Vec::new();
                         for p in items {
    [31m-                        let perms_opt = map_plugin_perms_to_tools_permissions(&p.required_permissions);
    (B[m[32m+                        let perms_opt =
    (B[m[32m+                            map_plugin_perms_to_tools_permissions(&p.required_permissions);
    (B[m                         let spec = tools::ToolSpec {
                                 name: p.id.clone(),
                                 description: format!("[plugin:{:?}] {}", p.plugin_type, p.description),
    Diff in /workspace/crates/cli/src/commands/tools.rs:460:
                         if json {
                             println!("{}", serde_json::to_string_pretty(&specs)?);
                         } else {
    [31m-                        println!("{}", "=== Exported Plugin Tools (preview) ===".bold().cyan());
    (B[m[32m+                        println!(
    (B[m[32m+                            "{}",
    (B[m[32m+                            "=== Exported Plugin Tools (preview) ===".bold().cyan()
    (B[m[32m+                        );
    (B[m                         for s in specs {
                                 println!("- {}: {}", s.name.bold(), s.description);
                                 if let Some(perms) = &s.permissions {
    Diff in /workspace/crates/cli/src/commands/tools.rs:467:
    [31m-                                println!("  perm.fs_read: {}", if perms.fs_read_roots.is_empty() { "-".into() } else { perms.fs_read_roots.join(":") });
    (B[m[31m-                                println!("  perm.fs_write: {}", if perms.fs_write_roots.is_empty() { "-".into() } else { perms.fs_write_roots.join(":") });
    (B[m[31m-                                println!("  perm.net_allow: {}", if perms.net_allowlist.is_empty() { "-".into() } else { perms.net_allowlist.join(",") });
    (B[m[31m-                                println!("  perm.shell: {}", if perms.allow_shell { "allow" } else { "deny" });
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.fs_read: {}",
    (B[m[32m+                                    if perms.fs_read_roots.is_empty() {
    (B[m[32m+                                        "-".into()
    (B[m[32m+                                    } else {
    (B[m[32m+                                        perms.fs_read_roots.join(":")
    (B[m[32m+                                    }
    (B[m[32m+                                );
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.fs_write: {}",
    (B[m[32m+                                    if perms.fs_write_roots.is_empty() {
    (B[m[32m+                                        "-".into()
    (B[m[32m+                                    } else {
    (B[m[32m+                                        perms.fs_write_roots.join(":")
    (B[m[32m+                                    }
    (B[m[32m+                                );
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.net_allow: {}",
    (B[m[32m+                                    if perms.net_allowlist.is_empty() {
    (B[m[32m+                                        "-".into()
    (B[m[32m+                                    } else {
    (B[m[32m+                                        perms.net_allowlist.join(",")
    (B[m[32m+                                    }
    (B[m[32m+                                );
    (B[m[32m+                                println!(
    (B[m[32m+                                    "  perm.shell: {}",
    (B[m[32m+                                    if perms.allow_shell { "allow" } else { "deny" }
    (B[m[32m+                                );
    (B[m                             }
                             }
                         }
    Diff in /workspace/crates/cli/src/commands/tools.rs:475:
                 }
                 Ok(())
             }
    [31m-        ToolsSubcommand::AddMcp { name, cmd, args, remote_tool, description } => {
    (B[m[31m-            let args_vec: Vec<String> = if args.trim().is_empty() { Vec::new() } else { args.split_whitespace().map(|s| s.to_string()).collect() };
    (B[m[31m-            registry.register_mcp_tool(&name, cmd.clone(), args_vec.clone(), remote_tool.clone(), description.clone());
    (B[m[31m-            upsert_mcp_config(McpToolConfig { name: name.clone(), cmd, args: args_vec, remote_tool, description })?;
    (B[m[31m-            println!("{} Зарегистрирован MCP инструмент: {}", "✓".green(), name.bold());
    (B[m[32m+        ToolsSubcommand::AddMcp {
    (B[m[32m+            name,
    (B[m[32m+            cmd,
    (B[m[32m+            args,
    (B[m[32m+            remote_tool,
    (B[m[32m+            description,
    (B[m[32m+        } => {
    (B[m[32m+            let args_vec: Vec<String> = if args.trim().is_empty() {
    (B[m[32m+                Vec::new()
    (B[m[32m+            } else {
    (B[m[32m+                args.split_whitespace().map(|s| s.to_string()).collect()
    (B[m[32m+            };
    (B[m[32m+            registry.register_mcp_tool(
    (B[m[32m+                &name,
    (B[m[32m+                cmd.clone(),
    (B[m[32m+                args_vec.clone(),
    (B[m[32m+                remote_tool.clone(),
    (B[m[32m+                description.clone(),
    (B[m[32m+            );
    (B[m[32m+            upsert_mcp_config(McpToolConfig {
    (B[m[32m+                name: name.clone(),
    (B[m[32m+                cmd,
    (B[m[32m+                args: args_vec,
    (B[m[32m+                remote_tool,
    (B[m[32m+                description,
    (B[m[32m+            })?;
    (B[m[32m+            println!(
    (B[m[32m+                "{} Зарегистрирован MCP инструмент: {}",
    (B[m[32m+                "✓".green(),
    (B[m[32m+                name.bold()
    (B[m[32m+            );
    (B[m             Ok(())
             }
    [31m-        ToolsSubcommand::Run { name, command, arg, context, dry_run, timeout_ms } => {
    (B[m[32m+        ToolsSubcommand::Run {
    (B[m[32m+            name,
    (B[m[32m+            command,
    (B[m[32m+            arg,
    (B[m[32m+            context,
    (B[m[32m+            dry_run,
    (B[m[32m+            timeout_ms,
    (B[m[32m+        } => {
    (B[m             export_plugins_into_registry(&mut registry).await;
    [31m-            let tool = registry.get(&name).ok_or_else(|| anyhow::anyhow!("Tool not found: {}", name))?;
    (B[m[32m+            let tool = registry
    (B[m[32m+                .get(&name)
    (B[m[32m+                .ok_or_else(|| anyhow::anyhow!("Tool not found: {}", name))?;
    (B[m             let mut args_map = std::collections::HashMap::new();
    [31m-            for (k, v) in arg { args_map.insert(k, v); }
    (B[m[32m+            for (k, v) in arg {
    (B[m[32m+                args_map.insert(k, v);
    (B[m[32m+            }
    (B[m             // Load effective policy
                 let mut home = crate::util::magray_home();
                 home.push("policy.json");
    Diff in /workspace/crates/cli/src/commands/tools.rs:495:
                 // Enrich policy args
                 if name == "web_fetch" {
                     if let Some(url) = args_map.get("url").cloned() {
    [31m-                    let domain = url.split('/').nth(2).unwrap_or("").split(':').next().unwrap_or("").to_string();
    (B[m[31m-                    if !domain.is_empty() { args_map.insert("domain".into(), domain); }
    (B[m[32m+                    let domain = url
    (B[m[32m+                        .split('/')
    (B[m[32m+                        .nth(2)
    (B[m[32m+                        .unwrap_or("")
    (B[m[32m+                        .split(':')
    (B[m[32m+                        .next()
    (B[m[32m+                        .unwrap_or("")
    (B[m[32m+                        .to_string();
    (B[m[32m+                    if !domain.is_empty() {
    (B[m[32m+                        args_map.insert("domain".into(), domain);
    (B[m[32m+                    }
    (B[m                 }
                 } else if name == "web_search" {
                     if let Some(q) = args_map.get("query").cloned() {
    Diff in /workspace/crates/cli/src/commands/tools.rs:503:
                         let lowered = q.to_lowercase();
    [31m-                    if lowered.contains("internal") { args_map.insert("keyword".into(), "internal".into()); }
    (B[m[31m-                    if lowered.contains("secret") { args_map.insert("keyword".into(), "secret".into()); }
    (B[m[32m+                    if lowered.contains("internal") {
    (B[m[32m+                        args_map.insert("keyword".into(), "internal".into());
    (B[m[32m+                    }
    (B[m[32m+                    if lowered.contains("secret") {
    (B[m[32m+                        args_map.insert("keyword".into(), "secret".into());
    (B[m[32m+                    }
    (B[m                 }
                 }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:516:
                         net_allowlist: perms.net_allowlist.clone(),
                         allow_shell: perms.allow_shell,
                     };
    [31m-                if let Some(pre) = common::policy::precheck_permissions(&name, &simple, &sandbox_cfg) {
    (B[m[32m+                if let Some(pre) =
    (B[m[32m+                    common::policy::precheck_permissions(&name, &simple, &sandbox_cfg)
    (B[m[32m+                {
    (B[m                     match pre.action {
                             common::policy::PolicyAction::Deny => {
    [31m-                            anyhow::bail!("Инструмент '{}' заблокирован политикой (precheck)", name);
    (B[m[32m+                            anyhow::bail!(
    (B[m[32m+                                "Инструмент '{}' заблокирован политикой (precheck)",
    (B[m[32m+                                name
    (B[m[32m+                            );
    (B[m                         }
                             common::policy::PolicyAction::Ask => {
    [31m-                            let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[31m-                            if non_interactive { anyhow::bail!("Инструмент '{}' требует подтверждения (precheck), но режим non-interactive", name); }
    (B[m[32m+                            let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE")
    (B[m[32m+                                .unwrap_or_default()
    (B[m[32m+                                == "true";
    (B[m[32m+                            if non_interactive {
    (B[m[32m+                                anyhow::bail!("Инструмент '{}' требует подтверждения (precheck), но режим non-interactive", name);
    (B[m[32m+                            }
    (B[m                         }
                             common::policy::PolicyAction::Allow => { /* continue */ }
                         }
    Diff in /workspace/crates/cli/src/commands/tools.rs:535:
                 // Dynamic guard based on UsageGuide overrides/spec
                 let mut require_ask_due_to_guide = false;
                 let mut spec = tool.spec();
    [31m-            if let Some(ov) = guide_overrides.get(&name) { apply_usage_guide_override(&mut spec, ov); }
    (B[m[31m-            if matches!(decision.action, common::policy::PolicyAction::Allow) && decision.matched_rule.is_none() {
    (B[m[32m+            if let Some(ov) = guide_overrides.get(&name) {
    (B[m[32m+                apply_usage_guide_override(&mut spec, ov);
    (B[m[32m+            }
    (B[m[32m+            if matches!(decision.action, common::policy::PolicyAction::Allow)
    (B[m[32m+                && decision.matched_rule.is_none()
    (B[m[32m+            {
    (B[m                 if let Some(guide) = &spec.usage_guide {
                         let high_risk = guide.risk_score >= 4;
                         let has_side_effects = !guide.side_effects.is_empty();
    Diff in /workspace/crates/cli/src/commands/tools.rs:543:
    [31m-                    if high_risk || has_side_effects { require_ask_due_to_guide = true; }
    (B[m[32m+                    if high_risk || has_side_effects {
    (B[m[32m+                        require_ask_due_to_guide = true;
    (B[m[32m+                    }
    (B[m                 }
                 }
     
    Diff in /workspace/crates/cli/src/commands/tools.rs:547:
                 if matches!(decision.action, common::policy::PolicyAction::Deny) {
    [31m-                let reason = decision.matched_rule.and_then(|r| r.reason).unwrap_or_else(|| "blocked".into());
    (B[m[32m+                let reason = decision
    (B[m[32m+                    .matched_rule
    (B[m[32m+                    .and_then(|r| r.reason)
    (B[m[32m+                    .unwrap_or_else(|| "blocked".into());
    (B[m                 let evt = serde_json::json!({"tool": name, "reason": reason});
                     tokio::spawn(events::publish(topics::TOPIC_POLICY_BLOCK, evt));
                     anyhow::bail!("Tool '{}' blocked by policy", name);
    Diff in /workspace/crates/cli/src/commands/tools.rs:552:
                 }
    [31m-            if matches!(decision.action, common::policy::PolicyAction::Ask) || require_ask_due_to_guide {
    (B[m[31m-                let non_interactive = std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[31m-                if non_interactive { anyhow::bail!("Tool '{}' requires confirmation (ask), but running non-interactive", name); }
    (B[m[31m-                let auto_approve = std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m[32m+            if matches!(decision.action, common::policy::PolicyAction::Ask)
    (B[m[32m+                || require_ask_due_to_guide
    (B[m[32m+            {
    (B[m[32m+                let non_interactive =
    (B[m[32m+                    std::env::var("MAGRAY_NONINTERACTIVE").unwrap_or_default() == "true";
    (B[m[32m+                if non_interactive {
    (B[m[32m+                    anyhow::bail!(
    (B[m[32m+                        "Tool '{}' requires confirmation (ask), but running non-interactive",
    (B[m[32m+                        name
    (B[m[32m+                    );
    (B[m[32m+                }
    (B[m[32m+                let auto_approve =
    (B[m[32m+                    std::env::var("MAGRAY_AUTO_APPROVE_ASK").unwrap_or_default() == "true";
    (B[m                 if !auto_approve {
    [31m-                    let preview_input = tools::ToolInput { command: command.clone(), args: args_map.clone(), context: context.clone(), dry_run: true, timeout_ms };
    (B[m[31m-                    let preview = tool.execute(preview_input).await.unwrap_or_else(|e| tools::ToolOutput { success: false, result: format!("preview error: {}", e), formatted_output: None, metadata: std::collections::HashMap::new() });
    (B[m[32m+                    let preview_input = tools::ToolInput {
    (B[m[32m+                        command: command.clone(),
    (B[m[32m+                        args: args_map.clone(),
    (B[m[32m+                        context: context.clone(),
    (B[m[32m+                        dry_run: true,
    (B[m[32m+                        timeout_ms,
    (B[m[32m+                    };
    (B[m[32m+                    let preview =
    (B[m[32m+                        tool.execute(preview_input)
    (B[m[32m+                            .await
    (B[m[32m+                            .unwrap_or_else(|e| tools::ToolOutput {
    (B[m[32m+                                success: false,
    (B[m[32m+                                result: format!("preview error: {}", e),
    (B[m[32m+                                formatted_output: None,
    (B[m[32m+                                metadata: std::collections::HashMap::new(),
    (B[m[32m+                            });
    (B[m                     println!("\n=== Предпросмотр (dry-run) {} ===", name.bold());
    [31m-                    if let Some(fmt) = preview.formatted_output { println!("{}", fmt); } else { println!("{}", preview.result); }
    (B[m[31m-                    if require_ask_due_to_guide { println!("Требуется подтверждение по UsageGuide (risk/side_effects)"); }
    (B[m[32m+                    if let Some(fmt) = preview.formatted_output {
    (B[m[32m+                        println!("{}", fmt);
    (B[m[32m+                    } else {
    (B[m[32m+                        println!("{}", preview.result);
    (B[m[32m+                    }
    (B[m[32m+                    if require_ask_due_to_guide {
    (B[m[32m+                        println!("Требуется подтверждение по UsageGuide (risk/side_effects)");
    (B[m[32m+                    }
    (B[m                     use std::io::{self, Write};
                         print!("Продолжить выполнение? [y/N]: ");
                         let _ = io::stdout().flush();
    Diff in /workspace/crates/cli/src/commands/tools.rs:566:
                         let mut answer = String::new();
    [31m-                    if io::stdin().read_line(&mut answer).is_err() { anyhow::bail!("confirmation failed"); }
    (B[m[32m+                    if io::stdin().read_line(&mut answer).is_err() {
    (B[m[32m+                        anyhow::bail!("confirmation failed");
    (B[m[32m+                    }
    (B[m                     let ans = answer.trim().to_lowercase();
    [31m-                    if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") { anyhow::bail!("Отменено пользователем"); }
    (B[m[32m+                    if !(ans == "y" || ans == "yes" || ans == "д" || ans == "да") {
    (B[m[32m+                        anyhow::bail!("Отменено пользователем");
    (B[m[32m+                    }
    (B[m                 }
                 }
    [31m-            let input = tools::ToolInput { command, args: args_map, context, dry_run, timeout_ms };
    (B[m[32m+            let input = tools::ToolInput {
    (B[m[32m+                command,
    (B[m[32m+                args: args_map,
    (B[m[32m+                context,
    (B[m[32m+                dry_run,
    (B[m[32m+                timeout_ms,
    (B[m[32m+            };
    (B[m             let output = tool.execute(input).await?;
    [31m-            if output.success { println!("{} {}", "✓".green(), output.result); } else { println!("{} {}", "✗".red(), output.result); }
    (B[m[32m+            if output.success {
    (B[m[32m+                println!("{} {}", "✓".green(), output.result);
    (B[m[32m+            } else {
    (B[m[32m+                println!("{} {}", "✗".red(), output.result);
    (B[m[32m+            }
    (B[m             let evt = serde_json::json!({"tool": name, "success": output.success});
                 tokio::spawn(events::publish(topics::TOPIC_TOOL_INVOKED, evt));
                 Ok(())
    Diff in /workspace/crates/cli/src/commands/tools.rs:578:
             }
         }
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/src/health_checks.rs:1:
     use anyhow::Result;
     use chrono::{DateTime, Utc};
     use colored::Colorize;
    [32m+use common::policy::{default_document, load_effective_policy};
    (B[m use common::OperationTimer;
     use serde::{Deserialize, Serialize};
     use std::collections::HashMap;
    Diff in /workspace/crates/cli/src/health_checks.rs:7:
     use std::sync::Arc;
     use tracing::{debug, error, info, warn};
    [31m-use common::policy::{default_document, load_effective_policy};
    (B[m 
     /// Результат проверки здоровья компонента
     #[derive(Debug, Clone, Serialize, Deserialize)]
    Diff in /workspace/crates/cli/src/main.rs:1:
     use anyhow::Result;
    [31m-use clap::{Parser, Subcommand, CommandFactory};
    (B[m[32m+use clap::{CommandFactory, Parser, Subcommand};
    (B[m use common::init_structured_logging;
    [32m+use common::{events, topics};
    (B[m use console::{style, Term};
     use indicatif::ProgressStyle;
     use llm::LlmClient;
    Diff in /workspace/crates/cli/src/main.rs:7:
    [32m+use serde_json::json;
    (B[m use std::io::{self, Write};
     use std::sync::Arc;
     use std::time::Duration;
    Diff in /workspace/crates/cli/src/main.rs:10:
     use tokio::time::sleep;
    [31m-use common::{events, topics};
    (B[m[31m-use serde_json::json;
    (B[m 
     use ai::{ModelType, MODEL_REGISTRY};
     
    Diff in /workspace/crates/cli/src/main.rs:24:
     use cli::agent_traits::AgentResponse;
     use cli::agent_traits::{RequestContext, RequestProcessorTrait};
     use cli::unified_agent_v2::UnifiedAgentV2;
    [31m-use commands::{GpuCommand, MemoryCommand, ModelsCommand, ToolsCommand, SmartCommand, TasksCommand};
    (B[m[32m+use commands::{
    (B[m[32m+    GpuCommand, MemoryCommand, ModelsCommand, SmartCommand, TasksCommand, ToolsCommand,
    (B[m[32m+};
    (B[m 
     // Иконки для CLI интерфейса
     static ROBOT_ICON: AnimatedIcon = AnimatedIcon::new(&["[AI]", "[▲I]", "[●I]", "[♦I]"]);
    Diff in /workspace/crates/cli/src/main.rs:139:
         }
     
         // Автозагрузка манифестов плагинов по флагу окружения
    [31m-    if std::env::var("MAGRAY_LOAD_PLUGIN_MANIFESTS").ok().map(|s| s=="1"||s.to_lowercase()=="true").unwrap_or(false) {
    (B[m[32m+    if std::env::var("MAGRAY_LOAD_PLUGIN_MANIFESTS")
    (B[m[32m+        .ok()
    (B[m[32m+        .map(|s| s == "1" || s.to_lowercase() == "true")
    (B[m[32m+        .unwrap_or(false)
    (B[m[32m+    {
    (B[m         let mut home = util::magray_home();
    [31m-        let mut plugins_dir = home.clone(); plugins_dir.push("plugins");
    (B[m[31m-        let mut cfg_dir = home.clone(); cfg_dir.push("plugin-configs");
    (B[m[32m+        let mut plugins_dir = home.clone();
    (B[m[32m+        plugins_dir.push("plugins");
    (B[m[32m+        let mut cfg_dir = home.clone();
    (B[m[32m+        cfg_dir.push("plugin-configs");
    (B[m         tokio::fs::create_dir_all(&plugins_dir).await.ok();
             tokio::fs::create_dir_all(&cfg_dir).await.ok();
             let registry = tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
    Diff in /workspace/crates/cli/src/main.rs:178:
                 Some(Commands::Tools(_)) => "tools",
                 None => "help",
             };
    [31m-        tokio::spawn(events::publish(topics::TOPIC_INTENT, json!({"command": cmd_name})));
    (B[m[32m+        tokio::spawn(events::publish(
    (B[m[32m+            topics::TOPIC_INTENT,
    (B[m[32m+            json!({"command": cmd_name}),
    (B[m[32m+        ));
    (B[m 
             match cli.command {
    [31m-            Some(Commands::Chat { message }) => {
    (B[m[31m-                handle_chat(message).await?
    (B[m[31m-            }
    (B[m[32m+            Some(Commands::Chat { message }) => handle_chat(message).await?,
    (B[m             Some(Commands::Read { path }) => {
                     let agent = create_unified_agent_v2().await?;
                     let message = format!("прочитай файл {path}");
    Diff in /workspace/crates/cli/src/main.rs:212:
                 }
                 Some(Commands::Gpu(gpu_command)) => {
                     // Локальный таймаут 300с
    [31m-                timeout(Duration::from_secs(300), gpu_command.execute()).await.map_err(|_| anyhow::anyhow!("GPU command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(300), gpu_command.execute())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("GPU command timeout"))??;
    (B[m             }
                 Some(Commands::Memory(cmd)) => {
    [31m-                timeout(Duration::from_secs(180), cmd.execute()).await.map_err(|_| anyhow::anyhow!("Memory command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(180), cmd.execute())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("Memory command timeout"))??;
    (B[m             }
                 Some(Commands::Models(cmd)) => {
    [31m-                timeout(Duration::from_secs(120), cmd.execute()).await.map_err(|_| anyhow::anyhow!("Models command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(120), cmd.execute())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("Models command timeout"))??;
    (B[m             }
                 Some(Commands::Tasks(cmd)) => {
    [31m-                timeout(Duration::from_secs(180), cmd.execute()).await.map_err(|_| anyhow::anyhow!("Tasks command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(180), cmd.execute())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("Tasks command timeout"))??;
    (B[m             }
                 Some(Commands::Health) => {
                     // Инициализируем сервисы для health check
    Diff in /workspace/crates/cli/src/main.rs:228:
                     let llm_client = LlmClient::from_env().ok().map(Arc::new);
                     let memory_service: Option<Arc<memory::di::UnifiedContainer>> = None;
     
    [31m-                timeout(Duration::from_secs(60), health_checks::run_health_checks(llm_client, memory_service))
    (B[m[31m-                    .await
    (B[m[31m-                    .map_err(|_| anyhow::anyhow!("Health checks timeout"))??;
    (B[m[32m+                timeout(
    (B[m[32m+                    Duration::from_secs(60),
    (B[m[32m+                    health_checks::run_health_checks(llm_client, memory_service),
    (B[m[32m+                )
    (B[m[32m+                .await
    (B[m[32m+                .map_err(|_| anyhow::anyhow!("Health checks timeout"))??;
    (B[m             }
                 Some(Commands::Status) => {
    [31m-                timeout(Duration::from_secs(60), show_system_status()).await.map_err(|_| anyhow::anyhow!("Status command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(60), show_system_status())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("Status command timeout"))??;
    (B[m             }
                 Some(Commands::LlmStatus) => {
    [31m-                timeout(Duration::from_secs(60), show_llm_status()).await.map_err(|_| anyhow::anyhow!("LLM status timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(60), show_llm_status())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("LLM status timeout"))??;
    (B[m             }
                 Some(Commands::Performance) => {
    [31m-                timeout(Duration::from_secs(120), show_performance_metrics()).await.map_err(|_| anyhow::anyhow!("Performance command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(120), show_performance_metrics())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("Performance command timeout"))??;
    (B[m             }
                 Some(Commands::Policy { list, allow_shell }) => {
    [31m-                use common::policy::{load_effective_policy, PolicyDocument, PolicyRule, PolicyAction, PolicySubjectKind};
    (B[m[31m-                let mut home = util::magray_home(); home.push("policy.json");
    (B[m[32m+                use common::policy::{
    (B[m[32m+                    load_effective_policy, PolicyAction, PolicyDocument, PolicyRule,
    (B[m[32m+                    PolicySubjectKind,
    (B[m[32m+                };
    (B[m[32m+                let mut home = util::magray_home();
    (B[m[32m+                home.push("policy.json");
    (B[m                 if list {
    [31m-                    let effective = load_effective_policy(if home.exists() { Some(&home) } else { None });
    (B[m[31m-                    println!("=== Effective Policy ===\n{}", serde_json::to_string_pretty(&effective).unwrap_or_else(|_| "{}".into()));
    (B[m[32m+                    let effective =
    (B[m[32m+                        load_effective_policy(if home.exists() { Some(&home) } else { None });
    (B[m[32m+                    println!(
    (B[m[32m+                        "=== Effective Policy ===\n{}",
    (B[m[32m+                        serde_json::to_string_pretty(&effective).unwrap_or_else(|_| "{}".into())
    (B[m[32m+                    );
    (B[m                 }
                     if allow_shell {
                         // Merge small override into MAGRAY_POLICY_JSON
    Diff in /workspace/crates/cli/src/main.rs:253:
    [31m-                    let override_doc = PolicyDocument { rules: vec![PolicyRule { subject_kind: PolicySubjectKind::Tool, subject_name: "shell_exec".into(), when_contains_args: None, action: PolicyAction::Allow, reason: Some("cli override".into()) }] };
    (B[m[32m+                    let override_doc = PolicyDocument {
    (B[m[32m+                        rules: vec![PolicyRule {
    (B[m[32m+                            subject_kind: PolicySubjectKind::Tool,
    (B[m[32m+                            subject_name: "shell_exec".into(),
    (B[m[32m+                            when_contains_args: None,
    (B[m[32m+                            action: PolicyAction::Allow,
    (B[m[32m+                            reason: Some("cli override".into()),
    (B[m[32m+                        }],
    (B[m[32m+                    };
    (B[m                     let json = serde_json::to_string(&override_doc)?;
                         std::env::set_var("MAGRAY_POLICY_JSON", json);
                         println!("Applied in-memory override: Allow shell_exec (MAGRAY_POLICY_JSON)\nNote: persist by writing ~/.magray/policy.json");
    Diff in /workspace/crates/cli/src/main.rs:257:
                     }
                 }
                 Some(Commands::Tools(cmd)) => {
    [31m-                timeout(Duration::from_secs(300), cmd.execute()).await.map_err(|_| anyhow::anyhow!("Tools command timeout"))??;
    (B[m[32m+                timeout(Duration::from_secs(300), cmd.execute())
    (B[m[32m+                    .await
    (B[m[32m+                    .map_err(|_| anyhow::anyhow!("Tools command timeout"))??;
    (B[m             }
                 None => {
                     // По умолчанию показываем помощь
    Diff in /workspace/crates/cli/src/main.rs:265:
                 }
             }
             // Publish job completion progress
    [31m-        tokio::spawn(events::publish(topics::TOPIC_JOB_PROGRESS, json!({"command": cmd_name, "stage": "done"})));
    (B[m[32m+        tokio::spawn(events::publish(
    (B[m[32m+            topics::TOPIC_JOB_PROGRESS,
    (B[m[32m+            json!({"command": cmd_name, "stage": "done"}),
    (B[m[32m+        ));
    (B[m         Ok::<(), anyhow::Error>(())
         };
     
    Diff in /workspace/crates/cli/src/main.rs:272:
         match timeout(Duration::from_secs(top_timeout_secs), exec_fut).await {
             Ok(res) => {
                 if let Err(e) = res {
    [31m-                tokio::spawn(events::publish(topics::TOPIC_ERROR, json!({"error": e.to_string()})));
    (B[m[32m+                tokio::spawn(events::publish(
    (B[m[32m+                    topics::TOPIC_ERROR,
    (B[m[32m+                    json!({"error": e.to_string()}),
    (B[m[32m+                ));
    (B[m                 return Err(e);
                 }
             }
    Diff in /workspace/crates/cli/src/main.rs:279:
             Err(_) => {
                 eprintln!("[✗] Команда превысила общий таймаут {}с", top_timeout_secs);
    [31m-            tokio::spawn(events::publish(topics::TOPIC_ERROR, json!({"error": "global_timeout", "timeout_secs": top_timeout_secs})));
    (B[m[32m+            tokio::spawn(events::publish(
    (B[m[32m+                topics::TOPIC_ERROR,
    (B[m[32m+                json!({"error": "global_timeout", "timeout_secs": top_timeout_secs}),
    (B[m[32m+            ));
    (B[m             return Err(anyhow::anyhow!("Global command timeout"));
             }
         }
    Diff in /workspace/crates/cli/src/main.rs:781:
         println!("{} {}: {}", "ℹ".blue(), "Log Level".bold(), log_level);
     
         // Policy audit
    [31m-    use common::policy::{load_effective_policy};
    (B[m[32m+    use common::policy::load_effective_policy;
    (B[m     let mut home = crate::util::magray_home();
         home.push("policy.json");
         let has_file = home.exists();
    Diff in /workspace/crates/cli/src/main.rs:788:
         let effective = load_effective_policy(if has_file { Some(&home) } else { None });
         let rules_count = effective.rules.len();
    [31m-    let src = if std::env::var("MAGRAY_POLICY_JSON").ok().filter(|s| !s.trim().is_empty()).is_some() {
    (B[m[32m+    let src = if std::env::var("MAGRAY_POLICY_JSON")
    (B[m[32m+        .ok()
    (B[m[32m+        .filter(|s| !s.trim().is_empty())
    (B[m[32m+        .is_some()
    (B[m[32m+    {
    (B[m         "env-json"
         } else if std::env::var("MAGRAY_POLICY_PATH").is_ok() || has_file {
             "file"
    Diff in /workspace/crates/cli/src/main.rs:796:
         };
         println!("{} {}: {} (rules: {})", "🔒", "Policy", src, rules_count);
         // Risk aggregation
    [31m-    let mut low = 0usize; let mut med = 0usize; let mut high = 0usize;
    (B[m[32m+    let mut low = 0usize;
    (B[m[32m+    let mut med = 0usize;
    (B[m[32m+    let mut high = 0usize;
    (B[m     for r in &effective.rules {
             let risk = {
                 // mirror logic from infer_risk_from_reason
    Diff in /workspace/crates/cli/src/main.rs:803:
                 let reason = r.reason.as_deref();
    [31m-            if let Some(rr) = reason { let l = rr.to_lowercase();
    (B[m[31m-                if l.contains("high") || l.contains("critical") || l.contains("danger") { common::policy::RiskLevel::High }
    (B[m[31m-                else if l.contains("medium") || l.contains("moderate") { common::policy::RiskLevel::Medium }
    (B[m[31m-                else { common::policy::RiskLevel::Low }
    (B[m[31m-            } else { common::policy::RiskLevel::Low }
    (B[m[32m+            if let Some(rr) = reason {
    (B[m[32m+                let l = rr.to_lowercase();
    (B[m[32m+                if l.contains("high") || l.contains("critical") || l.contains("danger") {
    (B[m[32m+                    common::policy::RiskLevel::High
    (B[m[32m+                } else if l.contains("medium") || l.contains("moderate") {
    (B[m[32m+                    common::policy::RiskLevel::Medium
    (B[m[32m+                } else {
    (B[m[32m+                    common::policy::RiskLevel::Low
    (B[m[32m+                }
    (B[m[32m+            } else {
    (B[m[32m+                common::policy::RiskLevel::Low
    (B[m[32m+            }
    (B[m         };
    [31m-        match risk { common::policy::RiskLevel::High => high+=1, common::policy::RiskLevel::Medium => med+=1, common::policy::RiskLevel::Low => low+=1 }
    (B[m[32m+        match risk {
    (B[m[32m+            common::policy::RiskLevel::High => high += 1,
    (B[m[32m+            common::policy::RiskLevel::Medium => med += 1,
    (B[m[32m+            common::policy::RiskLevel::Low => low += 1,
    (B[m[32m+        }
    (B[m     }
         println!("  risks: low={} medium={} high={}", low, med, high);
         // Brief audit: list up to 5 rules
    Diff in /workspace/crates/cli/src/main.rs:819:
                     .when_contains_args
                     .as_ref()
                     .map(|m| {
    [31m-                    if m.is_empty() { String::new() } else { format!(" when={:?}", m) }
    (B[m[32m+                    if m.is_empty() {
    (B[m[32m+                        String::new()
    (B[m[32m+                    } else {
    (B[m[32m+                        format!(" when={:?}", m)
    (B[m[32m+                    }
    (B[m                 })
                     .unwrap_or_default();
                 println!(
    Diff in /workspace/crates/cli/src/main.rs:827:
                     rule.subject_kind, rule.subject_name, rule.action, when
                 );
             }
    [31m-        if rules_count > preview_len { println!("  ... and {} more", rules_count - preview_len); }
    (B[m[32m+        if rules_count > preview_len {
    (B[m[32m+            println!("  ... and {} more", rules_count - preview_len);
    (B[m[32m+        }
    (B[m     }
     
         // Publish health summary event
    Diff in /workspace/crates/cli/src/main.rs:834:
    [31m-    tokio::spawn(events::publish(topics::TOPIC_HEALTH, serde_json::json!({
    (B[m[31m-        "llm": llm_status,
    (B[m[31m-        "policy_rules": rules_count,
    (B[m[31m-        "risk": {"low": low, "medium": med, "high": high}
    (B[m[31m-    })));
    (B[m[32m+    tokio::spawn(events::publish(
    (B[m[32m+        topics::TOPIC_HEALTH,
    (B[m[32m+        serde_json::json!({
    (B[m[32m+            "llm": llm_status,
    (B[m[32m+            "policy_rules": rules_count,
    (B[m[32m+            "risk": {"low": low, "medium": med, "high": high}
    (B[m[32m+        }),
    (B[m[32m+    ));
    (B[m 
         println!();
     
    Diff in /workspace/crates/cli/src/main.rs:953:
     }
     
     fn ensure_default_models_installed_interactive() -> Result<()> {
    [31m-    use std::io::{stdin, stdout, Write};
    (B[m     use colored::Colorize;
    [32m+    use std::io::{stdin, stdout, Write};
    (B[m 
         // Если в CI - не спрашиваем, ставим по умолчанию (или пропускаем если FORCE_NO_ORT)
         let non_interactive = std::env::var("CI").is_ok() || std::env::var("MAGRAY_AUTO_YES").is_ok();
    Diff in /workspace/crates/cli/src/main.rs:964:
         let needs_emb = !models_dir.join("qwen3emb").exists();
         let needs_rerank = !models_dir.join("qwen3_reranker").exists();
     
    [31m-    if !(needs_emb || needs_rerank) { return Ok(()); }
    (B[m[32m+    if !(needs_emb || needs_rerank) {
    (B[m[32m+        return Ok(());
    (B[m[32m+    }
    (B[m 
         if non_interactive {
    [31m-        println!("{} Устанавливаю отсутствующие модели Qwen3 (non-interactive)", "📥".blue());
    (B[m[32m+        println!(
    (B[m[32m+            "{} Устанавливаю отсутствующие модели Qwen3 (non-interactive)",
    (B[m[32m+            "📥".blue()
    (B[m[32m+        );
    (B[m         run_model_install_scripts(needs_emb, needs_rerank)?;
             return Ok(());
         }
    Diff in /workspace/crates/cli/src/main.rs:974:
     
         println!("{} Обнаружены отсутствующие модели Qwen3.", "ℹ".cyan());
    [31m-    println!("  - embedding: {}", if needs_emb { "missing".red() } else { "ok".green() });
    (B[m[31m-    println!("  - reranker: {}", if needs_rerank { "missing".red() } else { "ok".green() });
    (B[m[31m-    print!("Установить сейчас? [Y/n]: "); stdout().flush().ok();
    (B[m[32m+    println!(
    (B[m[32m+        "  - embedding: {}",
    (B[m[32m+        if needs_emb {
    (B[m[32m+            "missing".red()
    (B[m[32m+        } else {
    (B[m[32m+            "ok".green()
    (B[m[32m+        }
    (B[m[32m+    );
    (B[m[32m+    println!(
    (B[m[32m+        "  - reranker: {}",
    (B[m[32m+        if needs_rerank {
    (B[m[32m+            "missing".red()
    (B[m[32m+        } else {
    (B[m[32m+            "ok".green()
    (B[m[32m+        }
    (B[m[32m+    );
    (B[m[32m+    print!("Установить сейчас? [Y/n]: ");
    (B[m[32m+    stdout().flush().ok();
    (B[m 
         let mut answer = String::new();
         let _ = stdin().read_line(&mut answer);
    Diff in /workspace/crates/cli/src/main.rs:982:
    [31m-    let yes = answer.trim().is_empty() || matches!(answer.trim().to_lowercase().as_str(), "y"|"yes");
    (B[m[31m-    if yes { run_model_install_scripts(needs_emb, needs_rerank)?; }
    (B[m[32m+    let yes =
    (B[m[32m+        answer.trim().is_empty() || matches!(answer.trim().to_lowercase().as_str(), "y" | "yes");
    (B[m[32m+    if yes {
    (B[m[32m+        run_model_install_scripts(needs_emb, needs_rerank)?;
    (B[m[32m+    }
    (B[m     Ok(())
     }
     
    Diff in /workspace/crates/cli/src/main.rs:988:
         use std::process::Command;
         // prefer python installers for precise layout
         if emb {
    [31m-        let _ = Command::new("python3").args(["scripts/install_qwen3_onnx.py", "--component", "embedding"]).status();
    (B[m[32m+        let _ = Command::new("python3")
    (B[m[32m+            .args(["scripts/install_qwen3_onnx.py", "--component", "embedding"])
    (B[m[32m+            .status();
    (B[m     }
         if rerank {
    [31m-        let _ = Command::new("python3").args(["scripts/install_qwen3_onnx.py", "--component", "reranker"]).status();
    (B[m[32m+        let _ = Command::new("python3")
    (B[m[32m+            .args(["scripts/install_qwen3_onnx.py", "--component", "reranker"])
    (B[m[32m+            .status();
    (B[m     }
         Ok(())
     }
    Diff in /workspace/crates/cli/src/main.rs:998:
     
     fn ensure_ort_installed_interactive() -> Result<()> {
    [31m-    use std::io::{stdin, stdout, Write};
    (B[m     use colored::Colorize;
    [32m+    use std::io::{stdin, stdout, Write};
    (B[m 
    [31m-    if std::env::var("MAGRAY_FORCE_NO_ORT").ok().map(|s| s=="1"||s.to_lowercase()=="true").unwrap_or(false) { return Ok(()); }
    (B[m[32m+    if std::env::var("MAGRAY_FORCE_NO_ORT")
    (B[m[32m+        .ok()
    (B[m[32m+        .map(|s| s == "1" || s.to_lowercase() == "true")
    (B[m[32m+        .unwrap_or(false)
    (B[m[32m+    {
    (B[m[32m+        return Ok(());
    (B[m[32m+    }
    (B[m 
         // Если есть ORT_DYLIB_PATH или стандартная либра — выходим
    [31m-    if std::env::var("ORT_DYLIB_PATH").is_ok() { return Ok(()); }
    (B[m[32m+    if std::env::var("ORT_DYLIB_PATH").is_ok() {
    (B[m[32m+        return Ok(());
    (B[m[32m+    }
    (B[m     let candidate = std::path::Path::new("scripts/onnxruntime/lib/libonnxruntime.so");
    [31m-    if candidate.exists() { std::env::set_var("ORT_DYLIB_PATH", candidate.display().to_string()); return Ok(()); }
    (B[m[32m+    if candidate.exists() {
    (B[m[32m+        std::env::set_var("ORT_DYLIB_PATH", candidate.display().to_string());
    (B[m[32m+        return Ok(());
    (B[m[32m+    }
    (B[m 
         let non_interactive = std::env::var("CI").is_ok() || std::env::var("MAGRAY_AUTO_YES").is_ok();
         if non_interactive {
    Diff in /workspace/crates/cli/src/main.rs:1012:
    [31m-        println!("{} Устанавливаю ONNX Runtime (non-interactive)", "📥".blue());
    (B[m[31m-        run_ort_install_script()?; return Ok(());
    (B[m[32m+        println!(
    (B[m[32m+            "{} Устанавливаю ONNX Runtime (non-interactive)",
    (B[m[32m+            "📥".blue()
    (B[m[32m+        );
    (B[m[32m+        run_ort_install_script()?;
    (B[m[32m+        return Ok(());
    (B[m     }
     
         println!("{} ONNX Runtime не найден.", "ℹ".cyan());
    Diff in /workspace/crates/cli/src/main.rs:1017:
    [31m-    print!("Установить сейчас? [Y/n]: "); stdout().flush().ok();
    (B[m[31m-    let mut answer = String::new(); let _ = stdin().read_line(&mut answer);
    (B[m[31m-    let yes = answer.trim().is_empty() || matches!(answer.trim().to_lowercase().as_str(), "y"|"yes");
    (B[m[31m-    if yes { run_ort_install_script()?; }
    (B[m[32m+    print!("Установить сейчас? [Y/n]: ");
    (B[m[32m+    stdout().flush().ok();
    (B[m[32m+    let mut answer = String::new();
    (B[m[32m+    let _ = stdin().read_line(&mut answer);
    (B[m[32m+    let yes =
    (B[m[32m+        answer.trim().is_empty() || matches!(answer.trim().to_lowercase().as_str(), "y" | "yes");
    (B[m[32m+    if yes {
    (B[m[32m+        run_ort_install_script()?;
    (B[m[32m+    }
    (B[m     Ok(())
     }
     
    Diff in /workspace/crates/cli/src/main.rs:1024:
     fn run_ort_install_script() -> Result<()> {
         use std::process::Command;
    [31m-    let status = Command::new("bash").args(["scripts/install_onnxruntime.sh"]).status()?;
    (B[m[32m+    let status = Command::new("bash")
    (B[m[32m+        .args(["scripts/install_onnxruntime.sh"])
    (B[m[32m+        .status()?;
    (B[m     if status.success() {
             // Try to set default path
             let p = std::path::Path::new("scripts/onnxruntime/lib/libonnxruntime.so");
    Diff in /workspace/crates/cli/src/main.rs:1030:
    [31m-        if p.exists() { std::env::set_var("ORT_DYLIB_PATH", p.display().to_string()); }
    (B[m[32m+        if p.exists() {
    (B[m[32m+            std::env::set_var("ORT_DYLIB_PATH", p.display().to_string());
    (B[m[32m+        }
    (B[m     }
         Ok(())
     }
    Diff in /workspace/crates/cli/src/status_tests.rs:92:
         async fn test_status_command_performance() {
             use std::time::Instant;
             let start = Instant::now();
    [31m-        let timeout = tokio::time::timeout(std::time::Duration::from_secs(10), show_system_status()).await;
    (B[m[32m+        let timeout =
    (B[m[32m+            tokio::time::timeout(std::time::Duration::from_secs(10), show_system_status()).await;
    (B[m         let duration = start.elapsed();
             assert!(timeout.is_ok(), "Status command timed out");
    [31m-        assert!(duration.as_secs() < 10, "Status command took too long: {:?}", duration);
    (B[m[32m+        assert!(
    (B[m[32m+            duration.as_secs() < 10,
    (B[m[32m+            "Status command took too long: {:?}",
    (B[m[32m+            duration
    (B[m[32m+        );
    (B[m     }
     }
     
    Diff in /workspace/crates/cli/src/util.rs:24:
         std::fs::create_dir_all(&dir).ok();
         dir
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/cli_auto_setup.rs:17:
         let status = cmd.status().expect("run ok");
         assert!(status.success());
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/cli_models.rs:13:
         let status = cmd.status().expect("run ok");
         assert!(status.success(), "cli models check should succeed");
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/cli_models_install_smoke.rs:25:
         });
         assert!(status.success());
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_commands_memory.rs:6:
     #[test]
     fn memory_help_runs() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["memory", "--help"]).env("MAGRAY_CMD_TIMEOUT", "30");
    (B[m[32m+    cmd.args(["memory", "--help"])
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "30");
    (B[m     assert!(cmd.status().unwrap().success());
     }
     
    Diff in /workspace/crates/cli/tests/test_commands_models.rs:1:
    [31m-#![cfg(all(not(feature = "minimal"), feature = "extended-tests", feature = "legacy-tests"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    not(feature = "minimal"),
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m use clap::Parser;
     use cli::commands::ModelsCommand;
     
    Diff in /workspace/crates/cli/tests/test_events_cli.rs:7:
     fn events_emitted_for_memory_and_tools() {
         // memory stats should emit intent
         let mut cmd = Command::cargo_bin("magray").expect("built");
    [31m-    let out = cmd.args(["memory","stats"]) // prints stats
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_CMD_TIMEOUT","15")
    (B[m[31m-        .output().expect("run ok");
    (B[m[32m+    let out = cmd
    (B[m[32m+        .args(["memory", "stats"]) // prints stats
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "15")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out.status.success());
     
         // tools run with deny should emit policy.block and error lines in output
    Diff in /workspace/crates/cli/tests/test_events_cli.rs:16:
         let mut cmd2 = Command::cargo_bin("magray").expect("built");
    [31m-    let status = cmd2.args(["tools","run","--name","shell_exec","--command","run","--arg","cmd=echo hi"]) // blocked by default policy
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_CMD_TIMEOUT","15")
    (B[m[31m-        .status().expect("run ok");
    (B[m[32m+    let status = cmd2
    (B[m[32m+        .args([
    (B[m[32m+            "tools",
    (B[m[32m+            "run",
    (B[m[32m+            "--name",
    (B[m[32m+            "shell_exec",
    (B[m[32m+            "--command",
    (B[m[32m+            "run",
    (B[m[32m+            "--arg",
    (B[m[32m+            "cmd=echo hi",
    (B[m[32m+        ]) // blocked by default policy
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "15")
    (B[m[32m+        .status()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(!status.success());
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_memory_backup_restore.rs:1:
     #![cfg(feature = "extended-tests")]
     
     use assert_cmd::prelude::*;
    [32m+use std::fs;
    (B[m use std::process::Command;
     use tempfile::TempDir;
    [31m-use std::fs;
    (B[m 
     #[test]
     fn cli_memory_backup_creates_file() {
    Diff in /workspace/crates/cli/tests/test_memory_backup_restore.rs:13:
     
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
         cmd.current_dir(&temp)
    [31m-        .args(["memory","backup"]) // default name
    (B[m[31m-        .env("CI","1")
    (B[m[31m-        .env("MAGRAY_SKIP_AUTO_INSTALL","1")
    (B[m[31m-        .env("ORT_DYLIB_PATH","scripts/onnxruntime/lib/libonnxruntime.so")
    (B[m[31m-        .env("MAGRAY_FORCE_NO_ORT","1")
    (B[m[31m-        .env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+        .args(["memory", "backup"]) // default name
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env(
    (B[m[32m+            "ORT_DYLIB_PATH",
    (B[m[32m+            "scripts/onnxruntime/lib/libonnxruntime.so",
    (B[m[32m+        )
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     let assert = cmd.assert();
         assert.success();
     
    Diff in /workspace/crates/cli/tests/test_memory_backup_restore.rs:25:
         let entries = fs::read_dir(&backups_dir).unwrap();
         let mut any = false;
    [31m-    for e in entries.flatten() { if e.file_type().unwrap().is_file() { any = true; break; } }
    (B[m[32m+    for e in entries.flatten() {
    (B[m[32m+        if e.file_type().unwrap().is_file() {
    (B[m[32m+            any = true;
    (B[m[32m+            break;
    (B[m[32m+        }
    (B[m[32m+    }
    (B[m     assert!(any, "backup file should be created");
     }
     
    Diff in /workspace/crates/cli/tests/test_memory_backup_restore.rs:31:
     #[tokio::test]
     async fn api_backup_and_restore_roundtrip() {
    [31m-    use memory::api::{UnifiedMemoryAPI, MemoryServiceTrait};
    (B[m[32m+    use memory::api::{MemoryServiceTrait, UnifiedMemoryAPI};
    (B[m     use memory::di::UnifiedContainer;
         use memory::Layer;
     
    Diff in /workspace/crates/cli/tests/test_memory_backup_restore.rs:37:
         let svc = UnifiedContainer::new();
         let api = UnifiedMemoryAPI::new(std::sync::Arc::new(svc));
     
    [31m-    let _ = api.remember("hello world".to_string(), memory::api::MemoryContext::new("test").with_layer(Layer::Interact));
    (B[m[31m-    let _ = api.remember("rust language".to_string(), memory::api::MemoryContext::new("test").with_layer(Layer::Insights));
    (B[m[32m+    let _ = api.remember(
    (B[m[32m+        "hello world".to_string(),
    (B[m[32m+        memory::api::MemoryContext::new("test").with_layer(Layer::Interact),
    (B[m[32m+    );
    (B[m[32m+    let _ = api.remember(
    (B[m[32m+        "rust language".to_string(),
    (B[m[32m+        memory::api::MemoryContext::new("test").with_layer(Layer::Insights),
    (B[m[32m+    );
    (B[m 
         let dir = TempDir::new().unwrap();
         let path = dir.path().join("back.json");
    Diff in /workspace/crates/cli/tests/test_memory_backup_restore.rs:48:
         let restored = api.restore_from_path(&path).await.expect("restore ok");
         assert!(restored >= 0);
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_memory_hybrid_cli.rs:16:
         ] {
             let mut add = Command::cargo_bin("magray").expect("built");
             add.current_dir(&temp)
    [31m-            .args(["memory","add",text,"--layer","interact"]) 
    (B[m[31m-            .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_SKIP_AUTO_INSTALL","1").env("MAGRAY_FORCE_NO_ORT","1").env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+            .args(["memory", "add", text, "--layer", "interact"])
    (B[m[32m+            .env("CI", "1")
    (B[m[32m+            .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+            .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+            .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+            .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m         add.assert().success();
         }
     
    Diff in /workspace/crates/cli/tests/test_memory_hybrid_cli.rs:24:
         // hybrid search should work like normal search if vector omitted
         let mut search = Command::cargo_bin("magray").expect("built");
    [31m-    let assert = search.current_dir(&temp)
    (B[m[31m-        .args(["memory","search","rust lifetimes","--layer","interact","--hybrid","-k","3"]) 
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_SKIP_AUTO_INSTALL","1").env("MAGRAY_FORCE_NO_ORT","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[32m+    let assert = search
    (B[m[32m+        .current_dir(&temp)
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "search",
    (B[m[32m+            "rust lifetimes",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+            "--hybrid",
    (B[m[32m+            "-k",
    (B[m[32m+            "3",
    (B[m[32m+        ])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m         .assert();
         let out = String::from_utf8_lossy(&assert.get_output().stdout).to_string();
    [31m-    assert!(out.contains("rust ownership lifetimes"), "hybrid search output: {}", out);
    (B[m[32m+    assert!(
    (B[m[32m+        out.contains("rust ownership lifetimes"),
    (B[m[32m+        "hybrid search output: {}",
    (B[m[32m+        out
    (B[m[32m+    );
    (B[m }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_memory_orchestrated_cli.rs:11:
         // add records
         let mut add1 = Command::cargo_bin("magray").expect("built");
         add1.current_dir(&temp)
    [31m-        .args(["memory","add","rust ownership borrowing lifetimes","--layer","interact"]) 
    (B[m[31m-        .env("CI","1").env("MAGRAY_SKIP_AUTO_INSTALL","1").env("MAGRAY_FORCE_NO_ORT","1").env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "add",
    (B[m[32m+            "rust ownership borrowing lifetimes",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+        ])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     add1.assert().success();
     
         let mut add2 = Command::cargo_bin("magray").expect("built");
    Diff in /workspace/crates/cli/tests/test_memory_orchestrated_cli.rs:19:
         add2.current_dir(&temp)
    [31m-        .args(["memory","add","python asyncio event loop","--layer","interact"]) 
    (B[m[31m-        .env("CI","1").env("MAGRAY_SKIP_AUTO_INSTALL","1").env("MAGRAY_FORCE_NO_ORT","1").env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "add",
    (B[m[32m+            "python asyncio event loop",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+        ])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     add2.assert().success();
     
         // search with rerank
    Diff in /workspace/crates/cli/tests/test_memory_orchestrated_cli.rs:25:
         let mut search = Command::cargo_bin("magray").expect("built");
    [31m-    let assert = search.current_dir(&temp)
    (B[m[31m-        .args(["memory","search","rust lifetimes borrowing","--layer","interact","--rerank","-k","2"]) 
    (B[m[31m-        .env("CI","1").env("MAGRAY_SKIP_AUTO_INSTALL","1").env("MAGRAY_FORCE_NO_ORT","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[32m+    let assert = search
    (B[m[32m+        .current_dir(&temp)
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "search",
    (B[m[32m+            "rust lifetimes borrowing",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+            "--rerank",
    (B[m[32m+            "-k",
    (B[m[32m+            "2",
    (B[m[32m+        ])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m         .assert();
         let out = String::from_utf8_lossy(&assert.get_output().stdout).to_string();
         let pos_rust = out.find("rust ownership borrowing lifetimes");
    Diff in /workspace/crates/cli/tests/test_memory_orchestrated_cli.rs:32:
         let pos_python = out.find("python asyncio event loop");
    [31m-    if let (Some(r), Some(p)) = (pos_rust, pos_python) { assert!(r < p, "rerank should order rust-related first. Output: {}", out); } else { panic!("Expected results not found in output: {}", out); }
    (B[m[32m+    if let (Some(r), Some(p)) = (pos_rust, pos_python) {
    (B[m[32m+        assert!(
    (B[m[32m+            r < p,
    (B[m[32m+            "rerank should order rust-related first. Output: {}",
    (B[m[32m+            out
    (B[m[32m+        );
    (B[m[32m+    } else {
    (B[m[32m+        panic!("Expected results not found in output: {}", out);
    (B[m[32m+    }
    (B[m }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_memory_search_cli.rs:9:
         // Prepare environment
         let mut add = Command::cargo_bin("magray").expect("binary built");
         add.current_dir(&temp)
    [31m-        .args(["memory","add","rust tokio async runtimes","--layer","interact"]) // 1
    (B[m[31m-        .env("MAGRAY_SKIP_AUTO_INSTALL","1")
    (B[m[31m-        .env("MAGRAY_FORCE_NO_ORT","1")
    (B[m[31m-        .env("CI","1").env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "add",
    (B[m[32m+            "rust tokio async runtimes",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+        ]) // 1
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     add.assert().success();
     
         let mut add2 = Command::cargo_bin("magray").expect("binary built");
    Diff in /workspace/crates/cli/tests/test_memory_search_cli.rs:19:
         add2.current_dir(&temp)
    [31m-        .args(["memory","add","python asyncio event loop","--layer","interact"]) // 2
    (B[m[31m-        .env("MAGRAY_SKIP_AUTO_INSTALL","1")
    (B[m[31m-        .env("MAGRAY_FORCE_NO_ORT","1")
    (B[m[31m-        .env("CI","1").env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "add",
    (B[m[32m+            "python asyncio event loop",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+        ]) // 2
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     add2.assert().success();
     
         let mut add3 = Command::cargo_bin("magray").expect("binary built");
    Diff in /workspace/crates/cli/tests/test_memory_search_cli.rs:27:
         add3.current_dir(&temp)
    [31m-        .args(["memory","add","rust ownership borrowing lifetimes","--layer","interact"]) // 3
    (B[m[31m-        .env("MAGRAY_SKIP_AUTO_INSTALL","1")
    (B[m[31m-        .env("MAGRAY_FORCE_NO_ORT","1")
    (B[m[31m-        .env("CI","1").env("MAGRAY_CMD_TIMEOUT","20");
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "add",
    (B[m[32m+            "rust ownership borrowing lifetimes",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+        ]) // 3
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     add3.assert().success();
     
         // Run search with rerank flag
    Diff in /workspace/crates/cli/tests/test_memory_search_cli.rs:35:
         let mut search = Command::cargo_bin("magray").expect("binary built");
    [31m-    let assert = search.current_dir(&temp)
    (B[m[31m-        .args(["memory","search","rust lifetimes borrowing","--layer","interact","--rerank","-k","3"]) // top-3
    (B[m[31m-        .env("MAGRAY_SKIP_AUTO_INSTALL","1")
    (B[m[31m-        .env("MAGRAY_FORCE_NO_ORT","1")
    (B[m[31m-        .env("CI","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[32m+    let assert = search
    (B[m[32m+        .current_dir(&temp)
    (B[m[32m+        .args([
    (B[m[32m+            "memory",
    (B[m[32m+            "search",
    (B[m[32m+            "rust lifetimes borrowing",
    (B[m[32m+            "--layer",
    (B[m[32m+            "interact",
    (B[m[32m+            "--rerank",
    (B[m[32m+            "-k",
    (B[m[32m+            "3",
    (B[m[32m+        ]) // top-3
    (B[m[32m+        .env("MAGRAY_SKIP_AUTO_INSTALL", "1")
    (B[m[32m+        .env("MAGRAY_FORCE_NO_ORT", "1")
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m         .assert();
         let output = String::from_utf8_lossy(&assert.get_output().stdout).to_string();
         // We do not rely on exact formatting (colors/indices); verify ordering of results heuristically
    Diff in /workspace/crates/cli/tests/test_memory_search_cli.rs:44:
         // Heuristic: expect the "rust ownership borrowing lifetimes" appears before python
         let pos_rust = output.find("rust ownership borrowing lifetimes");
         let pos_python = output.find("python asyncio event loop");
    [31m-    if let (Some(r), Some(p)) = (pos_rust, pos_python) { assert!(r < p); } else { panic!("Expected target texts not found in output: {}", output); }
    (B[m[32m+    if let (Some(r), Some(p)) = (pos_rust, pos_python) {
    (B[m[32m+        assert!(r < p);
    (B[m[32m+    } else {
    (B[m[32m+        panic!("Expected target texts not found in output: {}", output);
    (B[m[32m+    }
    (B[m }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_policies.rs:10:
     fn default_policy_blocks_shell_exec() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
         cmd.args([
    [31m-        "tools", "run",
    (B[m[31m-        "--name", "shell_exec",
    (B[m[31m-        "--command", "echo",
    (B[m[31m-        "--arg", "command=echo",
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "shell_exec",
    (B[m[32m+        "--command",
    (B[m[32m+        "echo",
    (B[m[32m+        "--arg",
    (B[m[32m+        "command=echo",
    (B[m     ])
         .env("CI", "1")
         .env("MAGRAY_CMD_TIMEOUT", "15");
    Diff in /workspace/crates/cli/tests/test_policies.rs:37:
     
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
         cmd.args([
    [31m-        "tools", "run",
    (B[m[31m-        "--name", "shell_exec",
    (B[m[31m-        "--command", "echo",
    (B[m[31m-        "--arg", "command=echo",
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "shell_exec",
    (B[m[32m+        "--command",
    (B[m[32m+        "echo",
    (B[m[32m+        "--arg",
    (B[m[32m+        "command=echo",
    (B[m     ])
         .env("CI", "1")
         .env("MAGRAY_HOME", home.to_string_lossy().to_string())
    Diff in /workspace/crates/cli/tests/test_policies.rs:52:
     #[test]
     fn default_policy_allows_memory_backup() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["memory", "backup"]).env("CI", "1").env("MAGRAY_CMD_TIMEOUT", "15");
    (B[m[32m+    cmd.args(["memory", "backup"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "15");
    (B[m     let status = cmd.status().expect("run ok");
         assert!(status.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies.rs:72:
         .unwrap();
     
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["memory", "backup"]).env("CI", "1").env("MAGRAY_CMD_TIMEOUT", "15").env("MAGRAY_HOME", home.to_string_lossy().to_string());
    (B[m[32m+    cmd.args(["memory", "backup"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "15")
    (B[m[32m+        .env("MAGRAY_HOME", home.to_string_lossy().to_string());
    (B[m     let status = cmd.status().expect("run ok");
         assert!(!status.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies.rs:92:
     
         // Non-interactive should fail
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["tools","run","--name","web_search","--command","search","--arg","query=rust"])
    (B[m[31m-    .env("CI","1").env("MAGRAY_NONINTERACTIVE","true")
    (B[m[32m+    cmd.args([
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "web_search",
    (B[m[32m+        "--command",
    (B[m[32m+        "search",
    (B[m[32m+        "--arg",
    (B[m[32m+        "query=rust",
    (B[m[32m+    ])
    (B[m[32m+    .env("CI", "1")
    (B[m[32m+    .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m     .env("MAGRAY_HOME", home.to_string_lossy().to_string())
    [31m-    .env("MAGRAY_CMD_TIMEOUT","15");
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "15");
    (B[m     let status = cmd.status().expect("run ok");
         assert!(!status.success());
     
    Diff in /workspace/crates/cli/tests/test_policies.rs:102:
         // Auto-approve should pass
         let mut cmd2 = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd2.args(["tools","run","--name","web_search","--command","search","--arg","query=rust"])
    (B[m[31m-    .env("CI","1")
    (B[m[32m+    cmd2.args([
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "web_search",
    (B[m[32m+        "--command",
    (B[m[32m+        "search",
    (B[m[32m+        "--arg",
    (B[m[32m+        "query=rust",
    (B[m[32m+    ])
    (B[m[32m+    .env("CI", "1")
    (B[m     .env("MAGRAY_HOME", home.to_string_lossy().to_string())
    [31m-    .env("MAGRAY_AUTO_APPROVE_ASK","true")
    (B[m[31m-    .env("MAGRAY_CMD_TIMEOUT","15");
    (B[m[32m+    .env("MAGRAY_AUTO_APPROVE_ASK", "true")
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "15");
    (B[m     let status2 = cmd2.status().expect("run ok");
         assert!(status2.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies.rs:113:
     #[test]
     fn status_shows_policy_audit() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["status"]).env("CI","1").env("MAGRAY_CMD_TIMEOUT","15");
    (B[m[32m+    cmd.args(["status"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "15");
    (B[m     let assert = cmd.assert();
         assert.success();
     }
    Diff in /workspace/crates/cli/tests/test_policies.rs:120:
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_policies_cli_env.rs:7:
     fn env_policy_allows_web_search() {
         let policy = r#"{"rules":[{"subject_kind":"Tool","subject_name":"web_search","when_contains_args":null,"action":"Allow","reason":"env-allow"}]}"#;
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["tools","run","--name","web_search","--command","search","--arg","query=rust"])
    (B[m[31m-        .env("CI","1")
    (B[m[31m-        .env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_POLICY_JSON", policy);
    (B[m[32m+    cmd.args([
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "web_search",
    (B[m[32m+        "--command",
    (B[m[32m+        "search",
    (B[m[32m+        "--arg",
    (B[m[32m+        "query=rust",
    (B[m[32m+    ])
    (B[m[32m+    .env("CI", "1")
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+    .env("MAGRAY_POLICY_JSON", policy);
    (B[m     let status = cmd.status().expect("run ok");
         assert!(status.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:20:
         let policy = r#"{"rules":[{"subject_kind":"Tool","subject_name":"web_fetch","when_contains_args":{"domain":"example.com"},"action":"Deny","reason":"blocked-domain"}]}"#;
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
         cmd.args([
    [31m-        "tools","run","--name","web_fetch","--command","fetch",
    (B[m[31m-        "--arg","url=https://example.com/path?q=1"
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "web_fetch",
    (B[m[32m+        "--command",
    (B[m[32m+        "fetch",
    (B[m[32m+        "--arg",
    (B[m[32m+        "url=https://example.com/path?q=1",
    (B[m     ])
    [31m-    .env("CI","1")
    (B[m[31m-    .env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[32m+    .env("CI", "1")
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m     .env("MAGRAY_POLICY_JSON", policy);
         let status = cmd.status().expect("run ok");
         assert!(!status.success());
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:35:
         // Tools handler enriches args with keyword=secret when query contains it
         let policy = r#"{"rules":[{"subject_kind":"Tool","subject_name":"web_search","when_contains_args":{"keyword":"secret"},"action":"Deny","reason":"no secrets"}]}"#;
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["tools","run","--name","web_search","--command","search","--arg","query=find secret docs"])
    (B[m[31m-        .env("CI","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_POLICY_JSON", policy);
    (B[m[32m+    cmd.args([
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "web_search",
    (B[m[32m+        "--command",
    (B[m[32m+        "search",
    (B[m[32m+        "--arg",
    (B[m[32m+        "query=find secret docs",
    (B[m[32m+    ])
    (B[m[32m+    .env("CI", "1")
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+    .env("MAGRAY_POLICY_JSON", policy);
    (B[m     let status = cmd.status().expect("run ok");
         assert!(!status.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:46:
     fn env_policy_ask_with_autoapprove_succeeds() {
         let policy = r#"{"rules":[{"subject_kind":"Tool","subject_name":"web_search","when_contains_args":null,"action":"Ask","reason":"medium"}]}"#;
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["tools","run","--name","web_search","--command","search","--arg","query=rust"])
    (B[m[31m-        .env("CI","1")
    (B[m[31m-        .env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_POLICY_JSON", policy)
    (B[m[31m-        .env("MAGRAY_AUTO_APPROVE_ASK","true");
    (B[m[32m+    cmd.args([
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "web_search",
    (B[m[32m+        "--command",
    (B[m[32m+        "search",
    (B[m[32m+        "--arg",
    (B[m[32m+        "query=rust",
    (B[m[32m+    ])
    (B[m[32m+    .env("CI", "1")
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+    .env("MAGRAY_POLICY_JSON", policy)
    (B[m[32m+    .env("MAGRAY_AUTO_APPROVE_ASK", "true");
    (B[m     let status = cmd.status().expect("run ok");
         assert!(status.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:60:
         let ask_backup = r#"{"rules":[{"subject_kind":"Command","subject_name":"memory.backup","when_contains_args":null,"action":"Ask","reason":"medium"}]}"#;
         // Non-interactive should fail
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["memory","backup"]).env("CI","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_NONINTERACTIVE","true").env("MAGRAY_POLICY_JSON", ask_backup);
    (B[m[32m+    cmd.args(["memory", "backup"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+        .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m[32m+        .env("MAGRAY_POLICY_JSON", ask_backup);
    (B[m     let status = cmd.status().expect("run ok");
         assert!(!status.success());
     
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:68:
         // Auto-approve should pass
         let mut cmd2 = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd2.args(["memory","backup"]).env("CI","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_AUTO_APPROVE_ASK","true").env("MAGRAY_POLICY_JSON", ask_backup);
    (B[m[32m+    cmd2.args(["memory", "backup"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+        .env("MAGRAY_AUTO_APPROVE_ASK", "true")
    (B[m[32m+        .env("MAGRAY_POLICY_JSON", ask_backup);
    (B[m     let status2 = cmd2.status().expect("run ok");
         assert!(status2.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:78:
         let ask_restore = r#"{"rules":[{"subject_kind":"Command","subject_name":"memory.restore","when_contains_args":null,"action":"Ask","reason":"high"}]}"#;
         // Non-interactive should fail
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["memory","restore","/dev/null"]).env("CI","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_NONINTERACTIVE","true").env("MAGRAY_POLICY_JSON", ask_restore);
    (B[m[32m+    cmd.args(["memory", "restore", "/dev/null"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+        .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m[32m+        .env("MAGRAY_POLICY_JSON", ask_restore);
    (B[m     let status = cmd.status().expect("run ok");
         assert!(!status.success());
     
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:86:
         // Auto-approve should pass
         let mut cmd2 = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd2.args(["memory","restore","/dev/null"]).env("CI","1").env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-        .env("MAGRAY_AUTO_APPROVE_ASK","true").env("MAGRAY_POLICY_JSON", ask_restore);
    (B[m[32m+    cmd2.args(["memory", "restore", "/dev/null"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+        .env("MAGRAY_AUTO_APPROVE_ASK", "true")
    (B[m[32m+        .env("MAGRAY_POLICY_JSON", ask_restore);
    (B[m     let status2 = cmd2.status().expect("run ok");
         assert!(status2.success());
     }
    Diff in /workspace/crates/cli/tests/test_policies_cli_env.rs:93:
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_smart_cli.rs:1:
     use assert_cmd::prelude::*;
     use predicates::prelude::*;
    [32m+use std::fs;
    (B[m use std::process::Command;
     use tempfile::TempDir;
    [31m-use std::fs;
    (B[m 
     fn cmd_with_temp_home() -> (Command, TempDir) {
         let temp_home = TempDir::new().expect("temp home");
    Diff in /workspace/crates/cli/tests/test_smart_cli.rs:20:
         cmd.arg("smart").arg("выполни команду echo from-smart");
     
         let assert = cmd.assert().success();
    [31m-    assert.stdout(predicate::str::contains("Smart планировщик"))
    (B[m[31m-          .stdout(predicate::str::contains("Выполнение завершено"))
    (B[m[31m-          .stdout(predicate::str::contains("from-smart"));
    (B[m[32m+    assert
    (B[m[32m+        .stdout(predicate::str::contains("Smart планировщик"))
    (B[m[32m+        .stdout(predicate::str::contains("Выполнение завершено"))
    (B[m[32m+        .stdout(predicate::str::contains("from-smart"));
    (B[m 
         // Проверим, что создались директории ~/.magray и ~/.magray/artifacts
         let magray_home = home.path().join(".magray");
    Diff in /workspace/crates/cli/tests/test_smart_cli.rs:46:
         }
         assert!(txt_found, "Ожидался текстовый артефакт шага");
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_tasks_cli.rs:33:
             .success()
             .stdout(predicate::str::contains("Готовые задачи:"));
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_tools_cli.rs:6:
     #[test]
     fn tools_list_runs() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["tools", "list"]).env("MAGRAY_CMD_TIMEOUT", "30").env("CI", "1");
    (B[m[32m+    cmd.args(["tools", "list"])
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "30")
    (B[m[32m+        .env("CI", "1");
    (B[m     let status = cmd.status().expect("run ok");
         assert!(status.success());
     }
    Diff in /workspace/crates/cli/tests/test_tools_cli.rs:14:
     #[tokio::test]
     async fn tools_run_event_bus_smoke() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
    [31m-    cmd.args(["tools", "list"]).env("CI", "1").env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m[32m+    cmd.args(["tools", "list"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_CMD_TIMEOUT", "20");
    (B[m     let status = cmd.status().expect("run ok");
         assert!(status.success());
     }
    Diff in /workspace/crates/cli/tests/test_tools_cli.rs:24:
         // Attempt to run blocked tool; expect non-zero exit
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
         cmd.args([
    [31m-        "tools", "run",
    (B[m[31m-        "--name", "shell_exec",
    (B[m[31m-        "--command", "echo",
    (B[m[31m-        "--arg", "command=echo",
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "shell_exec",
    (B[m[32m+        "--command",
    (B[m[32m+        "echo",
    (B[m[32m+        "--arg",
    (B[m[32m+        "command=echo",
    (B[m     ])
         .env("CI", "1")
         .env("MAGRAY_CMD_TIMEOUT", "20");
    Diff in /workspace/crates/cli/tests/test_tools_cli.rs:39:
     fn tools_run_file_delete_smoke() {
         let mut cmd = Command::cargo_bin("magray").expect("binary built");
         cmd.args([
    [31m-        "tools","run",
    (B[m[31m-        "--name","file_delete",
    (B[m[31m-        "--command","delete",
    (B[m[31m-        "--arg","path=/__definitely_not_exist__",
    (B[m[32m+        "tools",
    (B[m[32m+        "run",
    (B[m[32m+        "--name",
    (B[m[32m+        "file_delete",
    (B[m[32m+        "--command",
    (B[m[32m+        "delete",
    (B[m[32m+        "--arg",
    (B[m[32m+        "path=/__definitely_not_exist__",
    (B[m     ])
    [31m-    .env("CI","1")
    (B[m[31m-    .env("MAGRAY_CMD_TIMEOUT","20")
    (B[m[31m-    .env("MAGRAY_NONINTERACTIVE","true");
    (B[m[32m+    .env("CI", "1")
    (B[m[32m+    .env("MAGRAY_CMD_TIMEOUT", "20")
    (B[m[32m+    .env("MAGRAY_NONINTERACTIVE", "true");
    (B[m     let _ = cmd.status().expect("run ok");
     }
    [32m+
    (B[mDiff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:8:
     fn tools_list_basic_and_details_and_json() {
         // human list
         let mut cmd = Command::cargo_bin("magray").expect("built");
    [31m-    let out = cmd.args(["tools","list"]) // human output
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").output().expect("run ok");
    (B[m[32m+    let out = cmd
    (B[m[32m+        .args(["tools", "list"]) // human output
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out.status.success());
         let s = String::from_utf8_lossy(&out.stdout);
         assert!(s.contains("Registered Tools"));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:16:
     
         // details
         let mut cmd2 = Command::cargo_bin("magray").expect("built");
    [31m-    let out2 = cmd2.args(["tools","list","--details"]).env("CI","1").env("MAGRAY_NO_ANIM","1").output().expect("run ok");
    (B[m[32m+    let out2 = cmd2
    (B[m[32m+        .args(["tools", "list", "--details"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out2.status.success());
         let s2 = String::from_utf8_lossy(&out2.stdout);
         // Should show usage lines
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:24:
     
         // json
         let mut cmd3 = Command::cargo_bin("magray").expect("built");
    [31m-    let out3 = cmd3.args(["tools","list","--json"]).env("CI","1").env("MAGRAY_NO_ANIM","1").output().expect("run ok");
    (B[m[32m+    let out3 = cmd3
    (B[m[32m+        .args(["tools", "list", "--json"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out3.status.success());
         let s3 = String::from_utf8_lossy(&out3.stdout);
         // Validate basic JSON structure
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:37:
     fn tools_run_file_delete_triggers_dynamic_ask_non_interactive() {
         // file_delete marked as high-risk with side effects -> dynamic Ask should trigger and fail in non-interactive
         let mut cmd = Command::cargo_bin("magray").expect("built");
    [31m-    let out = cmd.args(["tools","run","--name","file_delete","--command","delete","--arg","path=/tmp/should_not_exist.txt"]) 
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_NONINTERACTIVE","true")
    (B[m[31m-        .output().expect("run ok");
    (B[m[32m+    let out = cmd
    (B[m[32m+        .args([
    (B[m[32m+            "tools",
    (B[m[32m+            "run",
    (B[m[32m+            "--name",
    (B[m[32m+            "file_delete",
    (B[m[32m+            "--command",
    (B[m[32m+            "delete",
    (B[m[32m+            "--arg",
    (B[m[32m+            "path=/tmp/should_not_exist.txt",
    (B[m[32m+        ])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(!out.status.success());
         let stderr = String::from_utf8_lossy(&out.stderr);
         assert!(stderr.contains("requires confirmation") || stderr.contains("Отменено пользователем"));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:49:
     fn tools_metrics_json_shape() {
         // Ask metrics snapshot JSON
         let mut cmd = Command::cargo_bin("magray").expect("built");
    [31m-    let out = cmd.args(["tools","metrics","--json"]).env("CI","1").env("MAGRAY_NO_ANIM","1").output().expect("run ok");
    (B[m[32m+    let out = cmd
    (B[m[32m+        .args(["tools", "metrics", "--json"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out.status.success());
         let s = String::from_utf8_lossy(&out.stdout);
         assert!(s.contains("\"tools\""));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:58:
     #[test]
     fn tools_select_json_structure() {
         let mut cmd = Command::cargo_bin("magray").expect("built");
    [31m-    let out = cmd.args(["tools","select","--query","скачай страницу","--json"]).env("CI","1").env("MAGRAY_NO_ANIM","1").output().expect("run ok");
    (B[m[32m+    let out = cmd
    (B[m[32m+        .args(["tools", "select", "--query", "скачай страницу", "--json"])
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out.status.success());
         let s = String::from_utf8_lossy(&out.stdout);
         // Expect array of explanations with keys
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:71:
     fn tools_select_json_contains_permissions_and_dryrun_breakdown() {
         let mut cmd = Command::cargo_bin("magray").expect("built");
         let out = cmd
    [31m-        .args(["tools","select","--query","скачай страницу","--json"]) // json
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1")
    (B[m[31m-        .output().expect("run ok");
    (B[m[32m+        .args(["tools", "select", "--query", "скачай страницу", "--json"]) // json
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(out.status.success());
         let s = String::from_utf8_lossy(&out.stdout);
         assert!(s.contains("\"breakdown\""));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:88:
         // Try write into /tmp (allowed) and into / (blocked) — we check blocked path deterministically using parent dir
         let mut cmd = Command::cargo_bin("magray").expect("built");
         let out = cmd
    [31m-        .args(["tools","run","--name","file_write","--command","write","--arg","path=/etc/shadow","--arg","content=oops"]) // obviously forbidden
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1")
    (B[m[31m-        .env("MAGRAY_NONINTERACTIVE","true")
    (B[m[31m-        .env("MAGRAY_FS_SANDBOX","1")
    (B[m[32m+        .args([
    (B[m[32m+            "tools",
    (B[m[32m+            "run",
    (B[m[32m+            "--name",
    (B[m[32m+            "file_write",
    (B[m[32m+            "--command",
    (B[m[32m+            "write",
    (B[m[32m+            "--arg",
    (B[m[32m+            "path=/etc/shadow",
    (B[m[32m+            "--arg",
    (B[m[32m+            "content=oops",
    (B[m[32m+        ]) // obviously forbidden
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m[32m+        .env("MAGRAY_FS_SANDBOX", "1")
    (B[m         .env("MAGRAY_FS_ROOTS", allowed.to_string_lossy().to_string())
    [31m-        .output().expect("run ok");
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(!out.status.success());
         let s = String::from_utf8_lossy(&out.stderr);
         assert!(s.contains("песочницы"));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:104:
         // Disallow all
         let mut cmd = Command::cargo_bin("magray").expect("built");
         let out = cmd
    [31m-        .args(["tools","run","--name","web_fetch","--command","get","--arg","url=https://example.com"]) // network
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_NONINTERACTIVE","true")
    (B[m[31m-        .env("MAGRAY_NET_ALLOW","") // no allowlist
    (B[m[31m-        .output().expect("run ok");
    (B[m[32m+        .args([
    (B[m[32m+            "tools",
    (B[m[32m+            "run",
    (B[m[32m+            "--name",
    (B[m[32m+            "web_fetch",
    (B[m[32m+            "--command",
    (B[m[32m+            "get",
    (B[m[32m+            "--arg",
    (B[m[32m+            "url=https://example.com",
    (B[m[32m+        ]) // network
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m[32m+        .env("MAGRAY_NET_ALLOW", "") // no allowlist
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     assert!(!out.status.success());
         let s = String::from_utf8_lossy(&out.stderr);
         assert!(s.to_lowercase().contains("сеть запрещена"));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:115:
         // Allow example.com
         let mut cmd2 = Command::cargo_bin("magray").expect("built");
         let out2 = cmd2
    [31m-        .args(["tools","run","--name","web_fetch","--command","get","--arg","url=https://example.com"]) // network
    (B[m[31m-        .env("CI","1").env("MAGRAY_NO_ANIM","1").env("MAGRAY_NONINTERACTIVE","true")
    (B[m[31m-        .env("MAGRAY_NET_ALLOW","example.com")
    (B[m[31m-        .output().expect("run ok");
    (B[m[32m+        .args([
    (B[m[32m+            "tools",
    (B[m[32m+            "run",
    (B[m[32m+            "--name",
    (B[m[32m+            "web_fetch",
    (B[m[32m+            "--command",
    (B[m[32m+            "get",
    (B[m[32m+            "--arg",
    (B[m[32m+            "url=https://example.com",
    (B[m[32m+        ]) // network
    (B[m[32m+        .env("CI", "1")
    (B[m[32m+        .env("MAGRAY_NO_ANIM", "1")
    (B[m[32m+        .env("MAGRAY_NONINTERACTIVE", "true")
    (B[m[32m+        .env("MAGRAY_NET_ALLOW", "example.com")
    (B[m[32m+        .output()
    (B[m[32m+        .expect("run ok");
    (B[m     // It may fail due to network unavailability in test env, but should not be blocked by sandbox. Accept success=false but not the sandbox error message.
         let s2e = String::from_utf8_lossy(&out2.stderr).to_lowercase();
         assert!(!s2e.contains("сеть запрещена"));
    Diff in /workspace/crates/cli/tests/test_tools_usage_guide.rs:125:
     }
    [32m+
    (B[mDiff in /workspace/crates/common/src/event_bus.rs:27:
     }
     
     impl<T: Clone + Send + Sync + Debug + 'static> Default for EventBus<T> {
    [31m-    fn default() -> Self { Self::new(1000, Duration::from_secs(1)) }
    (B[m[32m+    fn default() -> Self {
    (B[m[32m+        Self::new(1000, Duration::from_secs(1))
    (B[m[32m+    }
    (B[m }
     
     impl<T: Clone + Send + Sync + Debug + 'static> EventBus<T> {
    Diff in /workspace/crates/common/src/event_bus.rs:34:
         pub fn new(subscribe_buffer: usize, publish_timeout: Duration) -> Self {
             Self {
    [31m-            inner: Arc::new(RwLock::new(Inner { topics: HashMap::new() })),
    (B[m[32m+            inner: Arc::new(RwLock::new(Inner {
    (B[m[32m+                topics: HashMap::new(),
    (B[m[32m+            })),
    (B[m             publish_timeout,
                 subscribe_buffer,
             }
    Diff in /workspace/crates/common/src/event_bus.rs:50:
     
         pub async fn publish(&self, topic: Topic, payload: T) {
             self.ensure_topic(topic.clone()).await;
    [31m-        let envelope = EventEnvelope { topic: topic.clone(), payload, ts_ms: current_ts_ms() };
    (B[m[32m+        let envelope = EventEnvelope {
    (B[m[32m+            topic: topic.clone(),
    (B[m[32m+            payload,
    (B[m[32m+            ts_ms: current_ts_ms(),
    (B[m[32m+        };
    (B[m         let tx_opt = { self.inner.read().await.topics.get(topic.0).cloned() };
             if let Some(tx) = tx_opt {
                 let timeout_dur = self.publish_timeout;
    Diff in /workspace/crates/common/src/event_bus.rs:87:
     
     fn current_ts_ms() -> u128 {
         use std::time::{SystemTime, UNIX_EPOCH};
    [31m-    SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis()
    (B[m[32m+    SystemTime::now()
    (B[m[32m+        .duration_since(UNIX_EPOCH)
    (B[m[32m+        .unwrap_or_default()
    (B[m[32m+        .as_millis()
    (B[m }
     
     #[cfg(test)]
    Diff in /workspace/crates/common/src/event_bus.rs:204:
             assert_eq!(eb, "B1");
         }
     }
    [32m+
    (B[mDiff in /workspace/crates/common/src/events.rs:1:
     use crate::event_bus::{EventBus, EventEnvelope, Topic};
     use lazy_static::lazy_static;
    [32m+use std::collections::HashMap;
    (B[m use tokio::sync::{broadcast, Mutex};
     use tokio::time::Duration;
    [31m-use std::collections::HashMap;
    (B[m 
     lazy_static! {
         pub static ref GLOBAL_EVENT_BUS: EventBus<serde_json::Value> =
    Diff in /workspace/crates/common/src/events.rs:66:
         for (k, v) in &m.invocations {
             tools.insert(k.clone(), serde_json::json!({"invocations": v, "successes": m.successes.get(k).copied().unwrap_or(0), "asks": m.asks.get(k).copied().unwrap_or(0), "denies": m.denies.get(k).copied().unwrap_or(0)}));
         }
    [31m-    for (k, v) in &m.successes { tools.entry(k.clone()).and_modify(|e| { if let Some(obj)=e.as_object_mut(){ obj.insert("successes".into(), serde_json::json!(v)); }}).or_insert(serde_json::json!({"invocations": 0, "successes": v, "asks": m.asks.get(k).copied().unwrap_or(0), "denies": m.denies.get(k).copied().unwrap_or(0)})); }
    (B[m[31m-    for (k, v) in &m.asks { tools.entry(k.clone()).and_modify(|e| { if let Some(obj)=e.as_object_mut(){ obj.insert("asks".into(), serde_json::json!(v)); }}).or_insert(serde_json::json!({"invocations": 0, "successes": m.successes.get(k).copied().unwrap_or(0), "asks": v, "denies": m.denies.get(k).copied().unwrap_or(0)})); }
    (B[m[31m-    for (k, v) in &m.denies { tools.entry(k.clone()).and_modify(|e| { if let Some(obj)=e.as_object_mut(){ obj.insert("denies".into(), serde_json::json!(v)); }}).or_insert(serde_json::json!({"invocations": 0, "successes": m.successes.get(k).copied().unwrap_or(0), "asks": m.asks.get(k).copied().unwrap_or(0), "denies": v})); }
    (B[m[32m+    for (k, v) in &m.successes {
    (B[m[32m+        tools.entry(k.clone()).and_modify(|e| { if let Some(obj)=e.as_object_mut(){ obj.insert("successes".into(), serde_json::json!(v)); }}).or_insert(serde_json::json!({"invocations": 0, "successes": v, "asks": m.asks.get(k).copied().unwrap_or(0), "denies": m.denies.get(k).copied().unwrap_or(0)}));
    (B[m[32m+    }
    (B[m[32m+    for (k, v) in &m.asks {
    (B[m[32m+        tools.entry(k.clone()).and_modify(|e| { if let Some(obj)=e.as_object_mut(){ obj.insert("asks".into(), serde_json::json!(v)); }}).or_insert(serde_json::json!({"invocations": 0, "successes": m.successes.get(k).copied().unwrap_or(0), "asks": v, "denies": m.denies.get(k).copied().unwrap_or(0)}));
    (B[m[32m+    }
    (B[m[32m+    for (k, v) in &m.denies {
    (B[m[32m+        tools.entry(k.clone()).and_modify(|e| { if let Some(obj)=e.as_object_mut(){ obj.insert("denies".into(), serde_json::json!(v)); }}).or_insert(serde_json::json!({"invocations": 0, "successes": m.successes.get(k).copied().unwrap_or(0), "asks": m.asks.get(k).copied().unwrap_or(0), "denies": v}));
    (B[m[32m+    }
    (B[m     serde_json::json!({"tools": tools})
     }
     
    Diff in /workspace/crates/common/src/events.rs:79:
         #[tokio::test]
         async fn global_bus_publish_subscribe() {
             let mut rx = subscribe(Topic("tool.invoked")).await;
    [31m-        publish(Topic("tool.invoked"), serde_json::json!({"tool": "file_read", "ok": true}))
    (B[m[31m-            .await;
    (B[m[32m+        publish(
    (B[m[32m+            Topic("tool.invoked"),
    (B[m[32m+            serde_json::json!({"tool": "file_read", "ok": true}),
    (B[m[32m+        )
    (B[m[32m+        .await;
    (B[m         let evt = rx.recv().await.expect("receive");
             assert_eq!(evt.topic.0, "tool.invoked");
             assert_eq!(evt.payload["tool"], "file_read");
    Diff in /workspace/crates/common/src/events.rs:91:
         async fn multiple_subscribers_receive() {
             let mut rx1 = subscribe(Topic("policy.block")).await;
             let mut rx2 = subscribe(Topic("policy.block")).await;
    [31m-        publish(Topic("policy.block"), serde_json::json!({"tool": "shell_exec"})).await;
    (B[m[32m+        publish(
    (B[m[32m+            Topic("policy.block"),
    (B[m[32m+            serde_json::json!({"tool": "shell_exec"}),
    (B[m[32m+        )
    (B[m[32m+        .await;
    (B[m         let e1 = rx1.recv().await.unwrap();
             let e2 = rx2.recv().await.unwrap();
             assert_eq!(e1.payload["tool"], "shell_exec");
    Diff in /workspace/crates/common/src/events.rs:110:
             // give chance, but tool topic should not receive events for FS_T
             let maybe_b = tokio::time::timeout(Duration::from_millis(120), rx_b.recv()).await;
             assert_eq!(ea.topic.0, FS_T);
    [31m-        assert!(maybe_b.is_err(), "unexpected cross-topic event on {}", TOOL_T);
    (B[m[32m+        assert!(
    (B[m[32m+            maybe_b.is_err(),
    (B[m[32m+            "unexpected cross-topic event on {}",
    (B[m[32m+            TOOL_T
    (B[m[32m+        );
    (B[m     }
     
         #[tokio::test]
    Diff in /workspace/crates/common/src/events.rs:117:
         async fn tool_metrics_collects_invokes_and_blocks() {
             start_tool_metrics_aggregator().await;
    [31m-        publish(Topic("tool.invoked"), serde_json::json!({"tool":"file_read","success":true})).await;
    (B[m[31m-        publish(Topic("policy.block"), serde_json::json!({"tool":"shell_exec","action":"deny"})).await;
    (B[m[31m-        publish(Topic("policy.block"), serde_json::json!({"tool":"web_search","action":"ask"})).await;
    (B[m[32m+        publish(
    (B[m[32m+            Topic("tool.invoked"),
    (B[m[32m+            serde_json::json!({"tool":"file_read","success":true}),
    (B[m[32m+        )
    (B[m[32m+        .await;
    (B[m[32m+        publish(
    (B[m[32m+            Topic("policy.block"),
    (B[m[32m+            serde_json::json!({"tool":"shell_exec","action":"deny"}),
    (B[m[32m+        )
    (B[m[32m+        .await;
    (B[m[32m+        publish(
    (B[m[32m+            Topic("policy.block"),
    (B[m[32m+            serde_json::json!({"tool":"web_search","action":"ask"}),
    (B[m[32m+        )
    (B[m[32m+        .await;
    (B[m         // allow event loop to process
             tokio::time::sleep(Duration::from_millis(50)).await;
             let snap = tool_metrics_snapshot().await;
    Diff in /workspace/crates/common/src/events.rs:125:
             let tools = snap["tools"].as_object().unwrap();
             // Use lower-bound assertions due to possible concurrent events in test environment
    [31m-        assert!(tools.get("file_read").unwrap()["invocations"].as_u64().unwrap_or(0) >= 1);
    (B[m[31m-        assert!(tools.get("file_read").unwrap()["successes"].as_u64().unwrap_or(0) >= 1);
    (B[m[31m-        assert!(tools.get("shell_exec").unwrap()["denies"].as_u64().unwrap_or(0) >= 1);
    (B[m[31m-        assert!(tools.get("web_search").unwrap()["asks"].as_u64().unwrap_or(0) >= 1);
    (B[m[32m+        assert!(
    (B[m[32m+            tools.get("file_read").unwrap()["invocations"]
    (B[m[32m+                .as_u64()
    (B[m[32m+                .unwrap_or(0)
    (B[m[32m+                >= 1
    (B[m[32m+        );
    (B[m[32m+        assert!(
    (B[m[32m+            tools.get("file_read").unwrap()["successes"]
    (B[m[32m+                .as_u64()
    (B[m[32m+                .unwrap_or(0)
    (B[m[32m+                >= 1
    (B[m[32m+        );
    (B[m[32m+        assert!(
    (B[m[32m+            tools.get("shell_exec").unwrap()["denies"]
    (B[m[32m+                .as_u64()
    (B[m[32m+                .unwrap_or(0)
    (B[m[32m+                >= 1
    (B[m[32m+        );
    (B[m[32m+        assert!(
    (B[m[32m+            tools.get("web_search").unwrap()["asks"]
    (B[m[32m+                .as_u64()
    (B[m[32m+                .unwrap_or(0)
    (B[m[32m+                >= 1
    (B[m[32m+        );
    (B[m     }
     }
    [32m+
    (B[mDiff in /workspace/crates/common/src/lib.rs:1:
     pub mod comprehensive_errors;
     pub mod config_base;
    [32m+pub mod event_bus;
    (B[m[32m+pub mod events;
    (B[m pub mod macros;
    [32m+pub mod policy;
    (B[m[32m+pub mod sandbox_config;
    (B[m[32m+pub mod scheduler;
    (B[m pub mod service_macros;
     pub mod service_traits;
     pub mod structured_logging;
    Diff in /workspace/crates/common/src/lib.rs:7:
    [31m-pub mod event_bus;
    (B[m pub mod topics;
    [31m-pub mod scheduler;
    (B[m[31m-pub mod events;
    (B[m[31m-pub mod policy;
    (B[m[31m-pub mod sandbox_config;
    (B[m 
     #[cfg(test)]
     pub mod test_utils;
    Diff in /workspace/crates/common/src/lib.rs:28:
     
     // Re-export service traits
     pub use service_traits::{
    [31m-    BaseService, BuildableService, CacheService, CacheStats as CacheLayerStats, CircuitBreakerService,
    (B[m[31m-    CircuitBreakerState, ClearableService, ConfigTrait, ConfigurationProfile, ExecutableService,
    (B[m[31m-    HealthCheckService, InitializableService, LifecycleService, LifecycleState, MetricsService,
    (B[m[31m-    PooledService, PoolStats, RetryConfig, RetryableService, SearchPage, SearchableService,
    (B[m[31m-    ServiceCoordinator, StatisticsProvider,
    (B[m[32m+    BaseService, BuildableService, CacheService, CacheStats as CacheLayerStats,
    (B[m[32m+    CircuitBreakerService, CircuitBreakerState, ClearableService, ConfigTrait,
    (B[m[32m+    ConfigurationProfile, ExecutableService, HealthCheckService, InitializableService,
    (B[m[32m+    LifecycleService, LifecycleState, MetricsService, PoolStats, PooledService, RetryConfig,
    (B[m[32m+    RetryableService, SearchPage, SearchableService, ServiceCoordinator, StatisticsProvider,
    (B[m };
     
     // Re-export config base components
    Diff in /workspace/crates/common/src/policy.rs:1:
    [32m+use anyhow::Result as AnyResult;
    (B[m use serde::{Deserialize, Serialize};
     use std::collections::HashMap;
     use std::fs;
    Diff in /workspace/crates/common/src/policy.rs:4:
     use std::path::Path;
    [31m-use anyhow::Result as AnyResult;
    (B[m 
     #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
     pub enum PolicyAction {
    Diff in /workspace/crates/common/src/policy.rs:12:
     }
     
     #[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
    [31m-pub enum RiskLevel { Low, Medium, High }
    (B[m[32m+pub enum RiskLevel {
    (B[m[32m+    Low,
    (B[m[32m+    Medium,
    (B[m[32m+    High,
    (B[m[32m+}
    (B[m 
     #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
     pub enum PolicySubjectKind {
    Diff in /workspace/crates/common/src/policy.rs:48:
     }
     
     impl PolicyEngine {
    [31m-    pub fn new() -> Self { Self { rules: Vec::new() } }
    (B[m[32m+    pub fn new() -> Self {
    (B[m[32m+        Self { rules: Vec::new() }
    (B[m[32m+    }
    (B[m 
         pub fn with_rules(mut self, rules: Vec<PolicyRule>) -> Self {
             self.rules = rules;
    Diff in /workspace/crates/common/src/policy.rs:55:
             self
         }
     
    [31m-    pub fn from_document(doc: PolicyDocument) -> Self { Self { rules: doc.rules } }
    (B[m[32m+    pub fn from_document(doc: PolicyDocument) -> Self {
    (B[m[32m+        Self { rules: doc.rules }
    (B[m[32m+    }
    (B[m 
         pub fn evaluate_tool(&self, tool_name: &str, args: &HashMap<String, String>) -> PolicyDecision {
             self.evaluate(PolicySubjectKind::Tool, tool_name, args)
    Diff in /workspace/crates/common/src/policy.rs:62:
         }
     
    [31m-    pub fn evaluate_command(&self, command: &str, args: &HashMap<String, String>) -> PolicyDecision {
    (B[m[32m+    pub fn evaluate_command(
    (B[m[32m+        &self,
    (B[m[32m+        command: &str,
    (B[m[32m+        args: &HashMap<String, String>,
    (B[m[32m+    ) -> PolicyDecision {
    (B[m         self.evaluate(PolicySubjectKind::Command, command, args)
         }
     
    Diff in /workspace/crates/common/src/policy.rs:68:
    [31m-    fn evaluate(&self, kind: PolicySubjectKind, name: &str, args: &HashMap<String, String>) -> PolicyDecision {
    (B[m[32m+    fn evaluate(
    (B[m[32m+        &self,
    (B[m[32m+        kind: PolicySubjectKind,
    (B[m[32m+        name: &str,
    (B[m[32m+        args: &HashMap<String, String>,
    (B[m[32m+    ) -> PolicyDecision {
    (B[m         let mut last_match: Option<PolicyRule> = None;
             for rule in &self.rules {
    [31m-            if rule.subject_kind != kind { continue; }
    (B[m[31m-            if rule.subject_name != name && rule.subject_name != "*" { continue; }
    (B[m[32m+            if rule.subject_kind != kind {
    (B[m[32m+                continue;
    (B[m[32m+            }
    (B[m[32m+            if rule.subject_name != name && rule.subject_name != "*" {
    (B[m[32m+                continue;
    (B[m[32m+            }
    (B[m             if let Some(expected) = &rule.when_contains_args {
                     let mut all_match = true;
                     for (k, v) in expected {
    Diff in /workspace/crates/common/src/policy.rs:76:
    [31m-                    if args.get(k) != Some(v) { all_match = false; break; }
    (B[m[32m+                    if args.get(k) != Some(v) {
    (B[m[32m+                        all_match = false;
    (B[m[32m+                        break;
    (B[m[32m+                    }
    (B[m                 }
    [31m-                if !all_match { continue; }
    (B[m[32m+                if !all_match {
    (B[m[32m+                    continue;
    (B[m[32m+                }
    (B[m             }
                 last_match = Some(rule.clone());
             }
    Diff in /workspace/crates/common/src/policy.rs:83:
                 let action = rule.action.clone();
                 let risk = infer_risk_from_reason(rule.reason.as_deref());
                 let allowed = !matches!(action, PolicyAction::Deny);
    [31m-            PolicyDecision { allowed, matched_rule: last_match, action, risk }
    (B[m[32m+            PolicyDecision {
    (B[m[32m+                allowed,
    (B[m[32m+                matched_rule: last_match,
    (B[m[32m+                action,
    (B[m[32m+                risk,
    (B[m[32m+            }
    (B[m         } else {
                 // default allow if no rule matched
    [31m-            PolicyDecision { allowed: true, matched_rule: None, action: PolicyAction::Allow, risk: RiskLevel::Low }
    (B[m[32m+            PolicyDecision {
    (B[m[32m+                allowed: true,
    (B[m[32m+                matched_rule: None,
    (B[m[32m+                action: PolicyAction::Allow,
    (B[m[32m+                risk: RiskLevel::Low,
    (B[m[32m+            }
    (B[m         }
         }
     }
    Diff in /workspace/crates/common/src/policy.rs:93:
     
     /// Built-in default policies (secure-by-default)
     pub fn default_document() -> PolicyDocument {
    [31m-    PolicyDocument { rules: vec![
    (B[m[31m-        PolicyRule {
    (B[m[32m+    PolicyDocument {
    (B[m[32m+        rules: vec![PolicyRule {
    (B[m             subject_kind: PolicySubjectKind::Tool,
                 subject_name: "shell_exec".into(),
                 when_contains_args: None,
    Diff in /workspace/crates/common/src/policy.rs:101:
                 action: PolicyAction::Deny,
                 reason: Some("Shell execution disabled by default".into()),
    [31m-        },
    (B[m[31m-    ]}
    (B[m[32m+        }],
    (B[m[32m+    }
    (B[m }
     
     /// Load policies from a JSON file path
    Diff in /workspace/crates/common/src/policy.rs:123:
         let mut doc = default_document();
         if let Some(p) = file_path {
             if p.exists() {
    [31m-            if let Ok(d) = load_from_path(p) { doc = merge_documents(doc, d); }
    (B[m[32m+            if let Ok(d) = load_from_path(p) {
    (B[m[32m+                doc = merge_documents(doc, d);
    (B[m[32m+            }
    (B[m         }
         }
         if let Ok(path_str) = std::env::var("MAGRAY_POLICY_PATH") {
    Diff in /workspace/crates/common/src/policy.rs:130:
             let p = Path::new(&path_str);
             if p.exists() {
    [31m-            if let Ok(d) = load_from_path(p) { doc = merge_documents(doc, d); }
    (B[m[32m+            if let Ok(d) = load_from_path(p) {
    (B[m[32m+                doc = merge_documents(doc, d);
    (B[m[32m+            }
    (B[m         }
         }
         if let Ok(json_str) = std::env::var("MAGRAY_POLICY_JSON") {
    Diff in /workspace/crates/common/src/policy.rs:145:
     fn infer_risk_from_reason(reason: Option<&str>) -> RiskLevel {
         if let Some(r) = reason {
             let r = r.to_lowercase();
    [31m-        if r.contains("high") || r.contains("critical") || r.contains("danger") { return RiskLevel::High; }
    (B[m[31m-        if r.contains("medium") || r.contains("moderate") { return RiskLevel::Medium; }
    (B[m[32m+        if r.contains("high") || r.contains("critical") || r.contains("danger") {
    (B[m[32m+            return RiskLevel::High;
    (B[m[32m+        }
    (B[m[32m+        if r.contains("medium") || r.contains("moderate") {
    (B[m[32m+            return RiskLevel::Medium;
    (B[m[32m+        }
    (B[m     }
         RiskLevel::Low
     }
    Diff in /workspace/crates/common/src/policy.rs:162:
     
     /// Pre-check permissions against sandbox config (FS/NET/Shell)
     /// Returns: Some(decision) to enforce deny/ask; None to continue with normal policy evaluation
    [31m-pub fn precheck_permissions(_tool_name: &str, perms: &SimpleToolPermissions, cfg: &crate::sandbox_config::SandboxConfig) -> Option<PolicyDecision> {
    (B[m[32m+pub fn precheck_permissions(
    (B[m[32m+    _tool_name: &str,
    (B[m[32m+    perms: &SimpleToolPermissions,
    (B[m[32m+    cfg: &crate::sandbox_config::SandboxConfig,
    (B[m[32m+) -> Option<PolicyDecision> {
    (B[m     // Shell precheck
         if perms.allow_shell && !cfg.shell.allow_shell {
    [31m-        return Some(PolicyDecision { allowed: false, matched_rule: None, action: PolicyAction::Deny, risk: RiskLevel::High });
    (B[m[32m+        return Some(PolicyDecision {
    (B[m[32m+            allowed: false,
    (B[m[32m+            matched_rule: None,
    (B[m[32m+            action: PolicyAction::Deny,
    (B[m[32m+            risk: RiskLevel::High,
    (B[m[32m+        });
    (B[m     }
         // Network precheck
         if !perms.net_allowlist.is_empty() {
    Diff in /workspace/crates/common/src/policy.rs:172:
             if cfg.net.allowlist.is_empty() {
    [31m-            return Some(PolicyDecision { allowed: false, matched_rule: None, action: PolicyAction::Deny, risk: RiskLevel::Medium });
    (B[m[32m+            return Some(PolicyDecision {
    (B[m[32m+                allowed: false,
    (B[m[32m+                matched_rule: None,
    (B[m[32m+                action: PolicyAction::Deny,
    (B[m[32m+                risk: RiskLevel::Medium,
    (B[m[32m+            });
    (B[m         }
             let mut any_ok = false;
             for need in &perms.net_allowlist {
    Diff in /workspace/crates/common/src/policy.rs:177:
                 for allow in &cfg.net.allowlist {
    [31m-                if need.eq_ignore_ascii_case(allow) || need.to_lowercase().ends_with(&format!(".{}", allow.to_lowercase())) { any_ok = true; break; }
    (B[m[32m+                if need.eq_ignore_ascii_case(allow)
    (B[m[32m+                    || need
    (B[m[32m+                        .to_lowercase()
    (B[m[32m+                        .ends_with(&format!(".{}", allow.to_lowercase()))
    (B[m[32m+                {
    (B[m[32m+                    any_ok = true;
    (B[m[32m+                    break;
    (B[m[32m+                }
    (B[m             }
    [31m-            if any_ok { break; }
    (B[m[32m+            if any_ok {
    (B[m[32m+                break;
    (B[m[32m+            }
    (B[m         }
    [31m-        if !any_ok { return Some(PolicyDecision { allowed: false, matched_rule: None, action: PolicyAction::Deny, risk: RiskLevel::Medium }); }
    (B[m[32m+        if !any_ok {
    (B[m[32m+            return Some(PolicyDecision {
    (B[m[32m+                allowed: false,
    (B[m[32m+                matched_rule: None,
    (B[m[32m+                action: PolicyAction::Deny,
    (B[m[32m+                risk: RiskLevel::Medium,
    (B[m[32m+            });
    (B[m[32m+        }
    (B[m     }
         // FS precheck when sandbox is enabled: require coverage of requested roots
         if cfg.fs.enabled {
    Diff in /workspace/crates/common/src/policy.rs:186:
             let covers = |reqs: &Vec<String>| -> bool {
    [31m-            if reqs.is_empty() { return true; }
    (B[m[31m-            if cfg.fs.roots.is_empty() { return false; }
    (B[m[31m-            reqs.iter().all(|r| cfg.fs.roots.iter().any(|a| r.starts_with(a)))
    (B[m[32m+            if reqs.is_empty() {
    (B[m[32m+                return true;
    (B[m[32m+            }
    (B[m[32m+            if cfg.fs.roots.is_empty() {
    (B[m[32m+                return false;
    (B[m[32m+            }
    (B[m[32m+            reqs.iter()
    (B[m[32m+                .all(|r| cfg.fs.roots.iter().any(|a| r.starts_with(a)))
    (B[m         };
             if !covers(&perms.fs_read_roots) || !covers(&perms.fs_write_roots) {
    [31m-            return Some(PolicyDecision { allowed: false, matched_rule: None, action: PolicyAction::Deny, risk: RiskLevel::Medium });
    (B[m[32m+            return Some(PolicyDecision {
    (B[m[32m+                allowed: false,
    (B[m[32m+                matched_rule: None,
    (B[m[32m+                action: PolicyAction::Deny,
    (B[m[32m+                risk: RiskLevel::Medium,
    (B[m[32m+            });
    (B[m         }
         }
         None
    Diff in /workspace/crates/common/src/policy.rs:219:
     
         #[test]
         fn risk_level_inference_high_medium_low() {
    [31m-        assert_eq!(super::infer_risk_from_reason(Some("HIGH risk operation")), RiskLevel::High);
    (B[m[31m-        assert_eq!(super::infer_risk_from_reason(Some("medium level")), RiskLevel::Medium);
    (B[m[32m+        assert_eq!(
    (B[m[32m+            super::infer_risk_from_reason(Some("HIGH risk operation")),
    (B[m[32m+            RiskLevel::High
    (B[m[32m+        );
    (B[m[32m+        assert_eq!(
    (B[m[32m+            super::infer_risk_from_reason(Some("medium level")),
    (B[m[32m+            RiskLevel::Medium
    (B[m[32m+        );
    (B[m         assert_eq!(super::infer_risk_from_reason(Some("safe")), RiskLevel::Low);
             assert_eq!(super::infer_risk_from_reason(None), RiskLevel::Low);
         }
    Diff in /workspace/crates/common/src/policy.rs:227:
     
         #[test]
         fn ask_action_propagates_in_decision() {
    [31m-        let doc = PolicyDocument { rules: vec![PolicyRule {
    (B[m[31m-            subject_kind: PolicySubjectKind::Tool,
    (B[m[31m-            subject_name: "web_search".into(),
    (B[m[31m-            when_contains_args: None,
    (B[m[31m-            action: PolicyAction::Ask,
    (B[m[31m-            reason: Some("medium".into()),
    (B[m[31m-        }]};
    (B[m[32m+        let doc = PolicyDocument {
    (B[m[32m+            rules: vec![PolicyRule {
    (B[m[32m+                subject_kind: PolicySubjectKind::Tool,
    (B[m[32m+                subject_name: "web_search".into(),
    (B[m[32m+                when_contains_args: None,
    (B[m[32m+                action: PolicyAction::Ask,
    (B[m[32m+                reason: Some("medium".into()),
    (B[m[32m+            }],
    (B[m[32m+        };
    (B[m         let engine = PolicyEngine::from_document(doc);
             let d = engine.evaluate_tool("web_search", &HashMap::new());
    [31m-        assert!(d.allowed, "Ask should not auto-deny in engine; caller handles prompt");
    (B[m[32m+        assert!(
    (B[m[32m+            d.allowed,
    (B[m[32m+            "Ask should not auto-deny in engine; caller handles prompt"
    (B[m[32m+        );
    (B[m         assert_eq!(d.action, PolicyAction::Ask);
             assert_eq!(d.risk, RiskLevel::Medium);
         }
    Diff in /workspace/crates/common/src/policy.rs:243:
     
         #[test]
         fn deny_specific_tool() {
    [31m-        let doc = PolicyDocument { rules: vec![PolicyRule {
    (B[m[31m-            subject_kind: PolicySubjectKind::Tool,
    (B[m[31m-            subject_name: "shell_exec".into(),
    (B[m[31m-            when_contains_args: None,
    (B[m[31m-            action: PolicyAction::Deny,
    (B[m[31m-            reason: Some("Shell exec disabled".into()),
    (B[m[31m-        }]};
    (B[m[32m+        let doc = PolicyDocument {
    (B[m[32m+            rules: vec![PolicyRule {
    (B[m[32m+                subject_kind: PolicySubjectKind::Tool,
    (B[m[32m+                subject_name: "shell_exec".into(),
    (B[m[32m+                when_contains_args: None,
    (B[m[32m+                action: PolicyAction::Deny,
    (B[m[32m+                reason: Some("Shell exec disabled".into()),
    (B[m[32m+            }],
    (B[m[32m+        };
    (B[m         let engine = PolicyEngine::from_document(doc);
             let d = engine.evaluate_tool("shell_exec", &HashMap::new());
             assert!(!d.allowed);
    Diff in /workspace/crates/common/src/policy.rs:256:
    [31m-        assert_eq!(d.matched_rule.unwrap().reason.unwrap(), "Shell exec disabled");
    (B[m[32m+        assert_eq!(
    (B[m[32m+            d.matched_rule.unwrap().reason.unwrap(),
    (B[m[32m+            "Shell exec disabled"
    (B[m[32m+        );
    (B[m         assert_eq!(d.action, PolicyAction::Deny);
         }
     
    Diff in /workspace/crates/common/src/policy.rs:260:
         #[test]
         fn allow_with_args_match() {
    [31m-        let doc = PolicyDocument { rules: vec![PolicyRule {
    (B[m[31m-            subject_kind: PolicySubjectKind::Tool,
    (B[m[31m-            subject_name: "file_read".into(),
    (B[m[31m-            when_contains_args: Some(HashMap::from([("path".into(), "/etc/hosts".into())])),
    (B[m[31m-            action: PolicyAction::Allow,
    (B[m[31m-            reason: None,
    (B[m[31m-        }]};
    (B[m[32m+        let doc = PolicyDocument {
    (B[m[32m+            rules: vec![PolicyRule {
    (B[m[32m+                subject_kind: PolicySubjectKind::Tool,
    (B[m[32m+                subject_name: "file_read".into(),
    (B[m[32m+                when_contains_args: Some(HashMap::from([("path".into(), "/etc/hosts".into())])),
    (B[m[32m+                action: PolicyAction::Allow,
    (B[m[32m+                reason: None,
    (B[m[32m+            }],
    (B[m[32m+        };
    (B[m         let engine = PolicyEngine::from_document(doc);
    [31m-        let d1 = engine.evaluate_tool("file_read", &HashMap::from([("path".into(), "/etc/hosts".into())]));
    (B[m[32m+        let d1 = engine.evaluate_tool(
    (B[m[32m+            "file_read",
    (B[m[32m+            &HashMap::from([("path".into(), "/etc/hosts".into())]),
    (B[m[32m+        );
    (B[m         assert!(d1.allowed);
             assert_eq!(d1.action, PolicyAction::Allow);
    [31m-        let d2 = engine.evaluate_tool("file_read", &HashMap::from([("path".into(), "/etc/passwd".into())]));
    (B[m[32m+        let d2 = engine.evaluate_tool(
    (B[m[32m+            "file_read",
    (B[m[32m+            &HashMap::from([("path".into(), "/etc/passwd".into())]),
    (B[m[32m+        );
    (B[m         assert!(d2.allowed); // default allow since no rule matched
             assert_eq!(d2.action, PolicyAction::Allow);
         }
    Diff in /workspace/crates/common/src/policy.rs:278:
         #[test]
         fn merge_precedence() {
             let base = default_document(); // denies shell_exec
    [31m-        let overlay = PolicyDocument { rules: vec![PolicyRule {
    (B[m[31m-            subject_kind: PolicySubjectKind::Tool,
    (B[m[31m-            subject_name: "shell_exec".into(),
    (B[m[31m-            when_contains_args: None,
    (B[m[31m-            action: PolicyAction::Allow,
    (B[m[31m-            reason: Some("override".into()),
    (B[m[31m-        }]};
    (B[m[32m+        let overlay = PolicyDocument {
    (B[m[32m+            rules: vec![PolicyRule {
    (B[m[32m+                subject_kind: PolicySubjectKind::Tool,
    (B[m[32m+                subject_name: "shell_exec".into(),
    (B[m[32m+                when_contains_args: None,
    (B[m[32m+                action: PolicyAction::Allow,
    (B[m[32m+                reason: Some("override".into()),
    (B[m[32m+            }],
    (B[m[32m+        };
    (B[m         let merged = merge_documents(base, overlay);
             let engine = PolicyEngine::from_document(merged);
             let d = engine.evaluate_tool("shell_exec", &HashMap::new());
    Diff in /workspace/crates/common/src/policy.rs:299:
             let p = tmp.path().join("policy.json");
             fs::write(&p, r#"{"rules":[{"subject_kind":"Tool","subject_name":"shell_exec","when_contains_args":null,"action":"Deny"}]}"#).unwrap();
             std::env::set_var("MAGRAY_POLICY_PATH", p.to_string_lossy().to_string());
    [31m-        std::env::set_var("MAGRAY_POLICY_JSON", r#"{"rules":[{"subject_kind":"Tool","subject_name":"shell_exec","when_contains_args":null,"action":"Allow"}]}"#);
    (B[m[32m+        std::env::set_var(
    (B[m[32m+            "MAGRAY_POLICY_JSON",
    (B[m[32m+            r#"{"rules":[{"subject_kind":"Tool","subject_name":"shell_exec","when_contains_args":null,"action":"Allow"}]}"#,
    (B[m[32m+        );
    (B[m         let effective = load_effective_policy(None);
             let engine = PolicyEngine::from_document(effective);
             let d = engine.evaluate_tool("shell_exec", &HashMap::new());
    Diff in /workspace/crates/common/src/policy.rs:310:
             std::env::remove_var("MAGRAY_POLICY_JSON");
         }
     }
    [32m+
    (B[mDiff in /workspace/crates/common/src/sandbox_config.rs:26:
     impl SandboxConfig {
         fn default_path() -> std::path::PathBuf {
             // Avoid circular dep on cli; resolve home here
    [31m-        let base = std::env::var("MAGRAY_HOME").ok().map(std::path::PathBuf::from).unwrap_or_else(|| {
    (B[m[31m-            let mut d = dirs::home_dir().unwrap_or_else(|| std::path::PathBuf::from("."));
    (B[m[31m-            d.push(".magray");
    (B[m[31m-            d
    (B[m[31m-        });
    (B[m[32m+        let base = std::env::var("MAGRAY_HOME")
    (B[m[32m+            .ok()
    (B[m[32m+            .map(std::path::PathBuf::from)
    (B[m[32m+            .unwrap_or_else(|| {
    (B[m[32m+                let mut d = dirs::home_dir().unwrap_or_else(|| std::path::PathBuf::from("."));
    (B[m[32m+                d.push(".magray");
    (B[m[32m+                d
    (B[m[32m+            });
    (B[m         let mut p = base;
             std::fs::create_dir_all(&p).ok();
             p.push("sandbox.json");
    Diff in /workspace/crates/common/src/sandbox_config.rs:39:
     
         fn from_file() -> Option<Self> {
             let p = Self::default_path();
    [31m-        if !p.exists() { return None; }
    (B[m[32m+        if !p.exists() {
    (B[m[32m+            return None;
    (B[m[32m+        }
    (B[m         let data = std::fs::read_to_string(&p).ok()?;
             serde_json::from_str::<SandboxConfig>(&data).ok()
         }
    Diff in /workspace/crates/common/src/sandbox_config.rs:59:
                     .map(|s| s.trim().to_string())
                     .filter(|s| !s.is_empty())
                     .collect();
    [31m-            if !roots.is_empty() { cfg.fs.roots = roots; }
    (B[m[32m+            if !roots.is_empty() {
    (B[m[32m+                cfg.fs.roots = roots;
    (B[m[32m+            }
    (B[m         }
     
             // NET
    Diff in /workspace/crates/common/src/sandbox_config.rs:83:
     
         pub fn save_to_file(&self) -> std::io::Result<()> {
             let p = Self::default_path();
    [31m-        if let Some(parent) = p.parent() { std::fs::create_dir_all(parent)?; }
    (B[m[32m+        if let Some(parent) = p.parent() {
    (B[m[32m+            std::fs::create_dir_all(parent)?;
    (B[m[32m+        }
    (B[m         let s = serde_json::to_string_pretty(self).unwrap_or_else(|_| "{}".into());
             std::fs::write(p, s)
         }
    Diff in /workspace/crates/common/src/sandbox_config.rs:90:
     }
    [32m+
    (B[mDiff in /workspace/crates/common/src/scheduler.rs:13:
     
     #[derive(Clone)]
     pub struct Scheduler {
    [31m-    inner: Arc<RwLock<Inner>>,    
    (B[m[32m+    inner: Arc<RwLock<Inner>>,
    (B[m }
     
     struct Inner {
    Diff in /workspace/crates/common/src/scheduler.rs:23:
     impl Scheduler {
         pub fn new() -> Self {
             let (tx, _rx) = broadcast::channel(8);
    [31m-        Self { inner: Arc::new(RwLock::new(Inner { shutdown_tx: tx })) }
    (B[m[32m+        Self {
    (B[m[32m+            inner: Arc::new(RwLock::new(Inner { shutdown_tx: tx })),
    (B[m[32m+        }
    (B[m     }
     
    [31m-    pub async fn spawn_periodic<F, Fut>(&self, job: ScheduledJob, mut f: F) where
    (B[m[32m+    pub async fn spawn_periodic<F, Fut>(&self, job: ScheduledJob, mut f: F)
    (B[m[32m+    where
    (B[m         F: FnMut() -> Fut + Send + 'static,
             Fut: std::future::Future<Output = ()> + Send + 'static,
         {
    Diff in /workspace/crates/common/src/scheduler.rs:68:
             let sched = Scheduler::new();
             let counter = Arc::new(AtomicUsize::new(0));
             let c2 = counter.clone();
    [31m-        let job = ScheduledJob { id: JobId("test.job"), interval: Duration::from_millis(20) };
    (B[m[31m-        sched.spawn_periodic(job, move || {
    (B[m[31m-            let c = c2.clone();
    (B[m[31m-            async move {
    (B[m[31m-                c.fetch_add(1, Ordering::Relaxed);
    (B[m[31m-            }
    (B[m[31m-        }).await;
    (B[m[32m+        let job = ScheduledJob {
    (B[m[32m+            id: JobId("test.job"),
    (B[m[32m+            interval: Duration::from_millis(20),
    (B[m[32m+        };
    (B[m[32m+        sched
    (B[m[32m+            .spawn_periodic(job, move || {
    (B[m[32m+                let c = c2.clone();
    (B[m[32m+                async move {
    (B[m[32m+                    c.fetch_add(1, Ordering::Relaxed);
    (B[m[32m+                }
    (B[m[32m+            })
    (B[m[32m+            .await;
    (B[m 
             tokio::time::sleep(Duration::from_millis(75)).await;
             sched.shutdown().await;
    Diff in /workspace/crates/common/src/scheduler.rs:89:
             let c2 = Arc::new(AtomicUsize::new(0));
             let c1c = c1.clone();
             let c2c = c2.clone();
    [31m-        let j1 = ScheduledJob { id: JobId("job.1"), interval: Duration::from_millis(15) };
    (B[m[31m-        let j2 = ScheduledJob { id: JobId("job.2"), interval: Duration::from_millis(22) };
    (B[m[31m-        sched.spawn_periodic(j1, move || { let cc = c1c.clone(); async move { cc.fetch_add(1, Ordering::Relaxed); } }).await;
    (B[m[31m-        sched.spawn_periodic(j2, move || { let cc = c2c.clone(); async move { cc.fetch_add(1, Ordering::Relaxed); } }).await;
    (B[m[32m+        let j1 = ScheduledJob {
    (B[m[32m+            id: JobId("job.1"),
    (B[m[32m+            interval: Duration::from_millis(15),
    (B[m[32m+        };
    (B[m[32m+        let j2 = ScheduledJob {
    (B[m[32m+            id: JobId("job.2"),
    (B[m[32m+            interval: Duration::from_millis(22),
    (B[m[32m+        };
    (B[m[32m+        sched
    (B[m[32m+            .spawn_periodic(j1, move || {
    (B[m[32m+                let cc = c1c.clone();
    (B[m[32m+                async move {
    (B[m[32m+                    cc.fetch_add(1, Ordering::Relaxed);
    (B[m[32m+                }
    (B[m[32m+            })
    (B[m[32m+            .await;
    (B[m[32m+        sched
    (B[m[32m+            .spawn_periodic(j2, move || {
    (B[m[32m+                let cc = c2c.clone();
    (B[m[32m+                async move {
    (B[m[32m+                    cc.fetch_add(1, Ordering::Relaxed);
    (B[m[32m+                }
    (B[m[32m+            })
    (B[m[32m+            .await;
    (B[m 
             tokio::time::sleep(Duration::from_millis(80)).await;
             sched.shutdown().await;
    Diff in /workspace/crates/common/src/scheduler.rs:99:
             let n1 = c1.load(Ordering::Relaxed);
             let n2 = c2.load(Ordering::Relaxed);
    [31m-        assert!(n1 > 0 && n2 > 0, "jobs must tick independently: n1={}, n2={}", n1, n2);
    (B[m[32m+        assert!(
    (B[m[32m+            n1 > 0 && n2 > 0,
    (B[m[32m+            "jobs must tick independently: n1={}, n2={}",
    (B[m[32m+            n1,
    (B[m[32m+            n2
    (B[m[32m+        );
    (B[m     }
     }
    [32m+
    (B[mDiff in /workspace/crates/common/src/topics.rs:12:
     pub const TOPIC_LLM_TOKENS: Topic = Topic("llm.tokens");
     pub const TOPIC_ERROR: Topic = Topic("error");
     pub const TOPIC_HEALTH: Topic = Topic("health");
    [32m+
    (B[mDiff in /workspace/crates/common/tests/test_event_bus_stress.rs:41:
             let done = counters
                 .iter()
                 .all(|c| c.load(Ordering::Relaxed) >= messages);
    [31m-        if done { break; }
    (B[m[31m-        if std::time::Instant::now() > deadline { break; }
    (B[m[32m+        if done {
    (B[m[32m+            break;
    (B[m[32m+        }
    (B[m[32m+        if std::time::Instant::now() > deadline {
    (B[m[32m+            break;
    (B[m[32m+        }
    (B[m         tokio::time::sleep(std::time::Duration::from_millis(10)).await;
         }
     
    Diff in /workspace/crates/common/tests/test_event_bus_stress.rs:49:
         // Join tasks
    [31m-    for h in handles { let _ = h.await; }
    (B[m[32m+    for h in handles {
    (B[m[32m+        let _ = h.await;
    (B[m[32m+    }
    (B[m 
         // Verify no loss
         for (idx, c) in counters.iter().enumerate() {
    Diff in /workspace/crates/common/tests/test_event_bus_stress.rs:54:
             let v = c.load(Ordering::Relaxed);
    [31m-        assert_eq!(v, messages, "subscriber {} missed {} msgs", idx, messages - v);
    (B[m[32m+        assert_eq!(
    (B[m[32m+            v,
    (B[m[32m+            messages,
    (B[m[32m+            "subscriber {} missed {} msgs",
    (B[m[32m+            idx,
    (B[m[32m+            messages - v
    (B[m[32m+        );
    (B[m     }
     }
    [32m+
    (B[mDiff in /workspace/crates/domain/src/entities/search_query.rs:358:
                 .with_kind("note".to_string())
                 .unwrap()
                 .with_score_threshold(ScoreThreshold::high())
    [31m-            .with_layers(vec![LayerType::Interact, LayerType::Insights, LayerType::Assets]);
    (B[m[32m+            .with_layers(vec![
    (B[m[32m+                LayerType::Interact,
    (B[m[32m+                LayerType::Insights,
    (B[m[32m+                LayerType::Assets,
    (B[m[32m+            ]);
    (B[m         assert!(q.has_filters());
             assert!(!q.is_simple());
             assert_eq!(q.score_threshold().value(), ScoreThreshold::high().value());
    Diff in /workspace/crates/domain/src/entities/search_query.rs:365:
     
             // invalid tag
    [31m-        let bad = SearchQuery::new("hello".to_string()).unwrap().with_tags(vec!["".into()]);
    (B[m[32m+        let bad = SearchQuery::new("hello".to_string())
    (B[m[32m+            .unwrap()
    (B[m[32m+            .with_tags(vec!["".into()]);
    (B[m         assert!(bad.is_err());
             // invalid kind
    [31m-        let badk = SearchQuery::new("hello".to_string()).unwrap().with_kind("".into());
    (B[m[32m+        let badk = SearchQuery::new("hello".to_string())
    (B[m[32m+            .unwrap()
    (B[m[32m+            .with_kind("".into());
    (B[m         assert!(badk.is_err());
         }
     
    Diff in /workspace/crates/domain/tests/test_value_objects.rs:1:
     #![cfg(feature = "extended-tests")]
    [32m+
    (B[mDiff in /workspace/crates/memory/examples/comprehensive_performance_validation.rs:1:
    [31m-#![cfg(all(feature = "extended-tests", any(feature = "hnsw-index", feature = "gpu-acceleration")))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    any(feature = "hnsw-index", feature = "gpu-acceleration")
    (B[m[32m+))]
    (B[m 
     //! Comprehensive Performance Validation - Ultimate HNSW Optimization Results
     //!
    Diff in /workspace/crates/memory/src/api.rs:8:
         // promotion::PromotionStats,
         // services::RefactoredDIMemoryService,
         types::SearchOptions as CoreSearchOptions,
    [31m-    Layer, Record,
    (B[m[32m+    Layer,
    (B[m[32m+    Record,
    (B[m };
    [31m-use common::event_bus::{EventBus, Topic, EventEnvelope};
    (B[m[32m+use common::event_bus::{EventBus, EventEnvelope, Topic};
    (B[m use once_cell::sync::Lazy;
     
     #[cfg(all(not(feature = "minimal"), feature = "persistence"))]
    Diff in /workspace/crates/memory/src/api.rs:36:
         #[cfg(feature = "reranking")]
         use ai::{OptimizedQwen3RerankerService, RerankBatch, RerankingConfig};
         use parking_lot::RwLock;
    [31m-    use std::sync::OnceLock;
    (B[m     use std::io::Write;
    [32m+    use std::sync::OnceLock;
    (B[m 
         // EventBus for memory events (recorded globally)
         #[derive(Debug, Clone)]
    Diff in /workspace/crates/memory/src/api.rs:44:
         pub enum MemoryEventPayload {
    [31m-        Remember { id: uuid::Uuid, layer: Layer },
    (B[m[31m-        Search { query: String, layer: Layer, results: usize },
    (B[m[32m+        Remember {
    (B[m[32m+            id: uuid::Uuid,
    (B[m[32m+            layer: Layer,
    (B[m[32m+        },
    (B[m[32m+        Search {
    (B[m[32m+            query: String,
    (B[m[32m+            layer: Layer,
    (B[m[32m+            results: usize,
    (B[m[32m+        },
    (B[m     }
     
    [31m-    pub static MEMORY_EVENT_BUS: Lazy<EventBus<MemoryEventPayload>> = Lazy::new(|| EventBus::new(1024, std::time::Duration::from_millis(250)));
    (B[m[32m+    pub static MEMORY_EVENT_BUS: Lazy<EventBus<MemoryEventPayload>> =
    (B[m[32m+        Lazy::new(|| EventBus::new(1024, std::time::Duration::from_millis(250)));
    (B[m 
         #[derive(Clone)]
         struct StoredRecord {
    Diff in /workspace/crates/memory/src/api.rs:69:
             fn init() -> &'static SimpleMemoryEngine {
                 ENGINE.get_or_init(|| {
                     // Try to create real embedding service
    [31m-                let model_name = std::env::var("MAGRAY_EMBED_MODEL").unwrap_or_else(|_| "qwen3emb".to_string());
    (B[m[32m+                let model_name =
    (B[m[32m+                    std::env::var("MAGRAY_EMBED_MODEL").unwrap_or_else(|_| "qwen3emb".to_string());
    (B[m                 let cfg = EmbeddingConfig {
                         model_name: model_name.clone(),
                         max_length: 512,
    Diff in /workspace/crates/memory/src/api.rs:78:
                         gpu_config: None,
                         embedding_dim: Some(1024),
                     };
    [31m-                let embedding_service = if ai::should_disable_ort() { None } else { CpuEmbeddingService::new(cfg).ok() };
    (B[m[32m+                let embedding_service = if ai::should_disable_ort() {
    (B[m[32m+                    None
    (B[m[32m+                } else {
    (B[m[32m+                    CpuEmbeddingService::new(cfg).ok()
    (B[m[32m+                };
    (B[m                 let embedding_dim = 1024;
     
                     #[cfg(feature = "reranking")]
    Diff in /workspace/crates/memory/src/api.rs:85:
                     let reranker = {
                         let disable_rerank = std::env::var("MAGRAY_DISABLE_RERANK")
    [31m-                        .map(|v| matches!(v.to_lowercase().as_str(), "1"|"true"|"yes"|"y"))
    (B[m[32m+                        .map(|v| matches!(v.to_lowercase().as_str(), "1" | "true" | "yes" | "y"))
    (B[m                         .unwrap_or(false);
    [31m-                    if disable_rerank { None } else {
    (B[m[31m-                    let rcfg = RerankingConfig {
    (B[m[31m-                        model_name: "qwen3_reranker".to_string(),
    (B[m[31m-                        batch_size: 32,
    (B[m[31m-                        max_length: 512,
    (B[m[31m-                        use_gpu: false,
    (B[m[31m-                        gpu_config: None,
    (B[m[31m-                    };
    (B[m[31m-                    OptimizedQwen3RerankerService::new_with_config(rcfg).ok()
    (B[m[32m+                    if disable_rerank {
    (B[m[32m+                        None
    (B[m[32m+                    } else {
    (B[m[32m+                        let rcfg = RerankingConfig {
    (B[m[32m+                            model_name: "qwen3_reranker".to_string(),
    (B[m[32m+                            batch_size: 32,
    (B[m[32m+                            max_length: 512,
    (B[m[32m+                            use_gpu: false,
    (B[m[32m+                            gpu_config: None,
    (B[m[32m+                        };
    (B[m[32m+                        OptimizedQwen3RerankerService::new_with_config(rcfg).ok()
    (B[m                     }
                     };
    [31m-                let store_path = Some(std::env::var("MAGRAY_MEMORY_FILE").unwrap_or_else(|_| "magray_memory.jsonl".to_string()))
    (B[m[31m-                    .map(std::path::PathBuf::from);
    (B[m[32m+                let store_path = Some(
    (B[m[32m+                    std::env::var("MAGRAY_MEMORY_FILE")
    (B[m[32m+                        .unwrap_or_else(|_| "magray_memory.jsonl".to_string()),
    (B[m[32m+                )
    (B[m[32m+                .map(std::path::PathBuf::from);
    (B[m 
                     // Preload existing JSONL if present
                     let mut initial_records: Vec<StoredRecord> = Vec::new();
    Diff in /workspace/crates/memory/src/api.rs:105:
                     if let Some(path) = store_path.as_ref() {
                         if let Ok(text) = std::fs::read_to_string(path) {
                             for line in text.lines() {
    [31m-                            if line.trim().is_empty() { continue; }
    (B[m[32m+                            if line.trim().is_empty() {
    (B[m[32m+                                continue;
    (B[m[32m+                            }
    (B[m                             if let Ok(mut rec) = serde_json::from_str::<Record>(line) {
                                     // Compute embedding
                                     let emb = match &embedding_service {
    Diff in /workspace/crates/memory/src/api.rs:112:
    [31m-                                    Some(svc) => svc.embed(&rec.text).map(|e| e.embedding).unwrap_or_else(|_| Self::mock_embed_static(&rec.text, embedding_dim)),
    (B[m[32m+                                    Some(svc) => {
    (B[m[32m+                                        svc.embed(&rec.text).map(|e| e.embedding).unwrap_or_else(
    (B[m[32m+                                            |_| Self::mock_embed_static(&rec.text, embedding_dim),
    (B[m[32m+                                        )
    (B[m[32m+                                    }
    (B[m                                     None => Self::mock_embed_static(&rec.text, embedding_dim),
                                     };
                                     rec.score = 0.0;
    Diff in /workspace/crates/memory/src/api.rs:116:
    [31m-                                initial_records.push(StoredRecord { record: rec, embedding: emb });
    (B[m[32m+                                initial_records.push(StoredRecord {
    (B[m[32m+                                    record: rec,
    (B[m[32m+                                    embedding: emb,
    (B[m[32m+                                });
    (B[m                             }
                             }
                         }
    Diff in /workspace/crates/memory/src/api.rs:148:
                 };
                 // store score placeholder
                 record.score = 0.0;
    [31m-            self.records.write().push(StoredRecord { record: record.clone(), embedding: emb });
    (B[m[32m+            self.records.write().push(StoredRecord {
    (B[m[32m+                record: record.clone(),
    (B[m[32m+                embedding: emb,
    (B[m[32m+            });
    (B[m             // append to JSONL store for cross-process persistence
                 if let Some(path) = self.store_path.as_ref() {
    [31m-                if let Ok(mut f) = std::fs::OpenOptions::new().create(true).append(true).open(path) {
    (B[m[31m-                    if let Ok(line) = serde_json::to_string(&record) { let _ = writeln!(f, "{}", line); }
    (B[m[32m+                if let Ok(mut f) = std::fs::OpenOptions::new()
    (B[m[32m+                    .create(true)
    (B[m[32m+                    .append(true)
    (B[m[32m+                    .open(path)
    (B[m[32m+                {
    (B[m[32m+                    if let Ok(line) = serde_json::to_string(&record) {
    (B[m[32m+                        let _ = writeln!(f, "{}", line);
    (B[m[32m+                    }
    (B[m                 }
                 }
                 // fire event (non-blocking publish with timeout inside)
    Diff in /workspace/crates/memory/src/api.rs:159:
    [31m-            let payload = MemoryEventPayload::Remember { id: record.id, layer: record.layer };
    (B[m[32m+            let payload = MemoryEventPayload::Remember {
    (B[m[32m+                id: record.id,
    (B[m[32m+                layer: record.layer,
    (B[m[32m+            };
    (B[m             tokio::spawn(MEMORY_EVENT_BUS.publish(common::topics::TOPIC_MEMORY_UPSERT, payload));
                 // also forward to global JSON bus for cross-crate observability
    [31m-            let json_evt = serde_json::json!({"id": record.id, "layer": format!("{:?}", record.layer)});
    (B[m[31m-            tokio::spawn(common::events::publish(common::topics::TOPIC_MEMORY_UPSERT, json_evt));
    (B[m[32m+            let json_evt =
    (B[m[32m+                serde_json::json!({"id": record.id, "layer": format!("{:?}", record.layer)});
    (B[m[32m+            tokio::spawn(common::events::publish(
    (B[m[32m+                common::topics::TOPIC_MEMORY_UPSERT,
    (B[m[32m+                json_evt,
    (B[m[32m+            ));
    (B[m             Ok(record.id)
             }
     
    Diff in /workspace/crates/memory/src/api.rs:189:
                 if let Some(reranker) = &self.reranker {
                     let documents: Vec<String> = scored.iter().map(|(_, r)| r.text.clone()).collect();
                     if !documents.is_empty() {
    [31m-                    let batch = RerankBatch { query: query.to_string(), documents, top_k: Some(top_k) };
    (B[m[32m+                    let batch = RerankBatch {
    (B[m[32m+                        query: query.to_string(),
    (B[m[32m+                        documents,
    (B[m[32m+                        top_k: Some(top_k),
    (B[m[32m+                    };
    (B[m                     if let Ok(reranked) = reranker.rerank_batch(&batch) {
                             // Map back according to returned order (top_k applied inside)
                             let mut new_order = Vec::with_capacity(reranked.results.len());
    Diff in /workspace/crates/memory/src/api.rs:216:
                 let returned = out.len().min(top_k);
                 out.truncate(top_k);
                 // fire event with summary
    [31m-            let payload = MemoryEventPayload::Search { query: query.to_string(), layer, results: returned };
    (B[m[32m+            let payload = MemoryEventPayload::Search {
    (B[m[32m+                query: query.to_string(),
    (B[m[32m+                layer,
    (B[m[32m+                results: returned,
    (B[m[32m+            };
    (B[m             tokio::spawn(MEMORY_EVENT_BUS.publish(common::topics::TOPIC_MEMORY_SEARCH, payload));
                 // also forward to global JSON bus
                 let json_evt = serde_json::json!({"query": query, "layer": format!("{:?}", layer), "results": returned});
    Diff in /workspace/crates/memory/src/api.rs:223:
    [31m-            tokio::spawn(common::events::publish(common::topics::TOPIC_MEMORY_SEARCH, json_evt));
    (B[m[32m+            tokio::spawn(common::events::publish(
    (B[m[32m+                common::topics::TOPIC_MEMORY_SEARCH,
    (B[m[32m+                json_evt,
    (B[m[32m+            ));
    (B[m             Ok(out)
             }
     
    Diff in /workspace/crates/memory/src/api.rs:243:
                     };
                     // Ensure score is sane
                     rec.score = 0.0;
    [31m-                self.records.write().push(StoredRecord { record: rec, embedding: emb });
    (B[m[32m+                self.records.write().push(StoredRecord {
    (B[m[32m+                    record: rec,
    (B[m[32m+                    embedding: emb,
    (B[m[32m+                });
    (B[m                 inserted += 1;
                 }
                 Ok(inserted)
    Diff in /workspace/crates/memory/src/api.rs:266:
                     na += av * av;
                     nb += bv * bv;
                 }
    [31m-            if na <= 1e-8 || nb <= 1e-8 { return 0.0; }
    (B[m[32m+            if na <= 1e-8 || nb <= 1e-8 {
    (B[m[32m+                return 0.0;
    (B[m[32m+            }
    (B[m             dot / (na.sqrt() * nb.sqrt())
             }
     
    Diff in /workspace/crates/memory/src/api.rs:276:
                 let mut idx = 0usize;
                 for token in text.split_whitespace() {
                     let mut h: u64 = 1469598103934665603;
    [31m-                for b in token.as_bytes() { h = h ^ (*b as u64); h = h.wrapping_mul(1099511628211); }
    (B[m[32m+                for b in token.as_bytes() {
    (B[m[32m+                    h = h ^ (*b as u64);
    (B[m[32m+                    h = h.wrapping_mul(1099511628211);
    (B[m[32m+                }
    (B[m                 let pos = (h as usize) % self.embedding_dim;
                     v[pos] += 1.0;
                     idx += 1;
    Diff in /workspace/crates/memory/src/api.rs:283:
    [31m-                if idx >= self.embedding_dim { break; }
    (B[m[32m+                if idx >= self.embedding_dim {
    (B[m[32m+                    break;
    (B[m[32m+                }
    (B[m             }
                 // L2 normalize
    [31m-            let mut norm = 0.0f32; for x in &v { norm += *x * *x; }
    (B[m[31m-            if norm > 0.0 { let inv = 1.0 / norm.sqrt(); for x in &mut v { *x *= inv; } }
    (B[m[32m+            let mut norm = 0.0f32;
    (B[m[32m+            for x in &v {
    (B[m[32m+                norm += *x * *x;
    (B[m[32m+            }
    (B[m[32m+            if norm > 0.0 {
    (B[m[32m+                let inv = 1.0 / norm.sqrt();
    (B[m[32m+                for x in &mut v {
    (B[m[32m+                    *x *= inv;
    (B[m[32m+                }
    (B[m[32m+            }
    (B[m             v
             }
     
    Diff in /workspace/crates/memory/src/api.rs:293:
                 let mut idx = 0usize;
                 for token in text.split_whitespace() {
                     let mut h: u64 = 1469598103934665603;
    [31m-                for b in token.as_bytes() { h = h ^ (*b as u64); h = h.wrapping_mul(1099511628211); }
    (B[m[32m+                for b in token.as_bytes() {
    (B[m[32m+                    h = h ^ (*b as u64);
    (B[m[32m+                    h = h.wrapping_mul(1099511628211);
    (B[m[32m+                }
    (B[m                 let pos = (h as usize) % dim;
                     v[pos] += 1.0;
                     idx += 1;
    Diff in /workspace/crates/memory/src/api.rs:300:
    [31m-                if idx >= dim { break; }
    (B[m[32m+                if idx >= dim {
    (B[m[32m+                    break;
    (B[m[32m+                }
    (B[m             }
    [31m-            let mut norm = 0.0f32; for x in &v { norm += *x * *x; }
    (B[m[31m-            if norm > 0.0 { let inv = 1.0 / norm.sqrt(); for x in &mut v { *x *= inv; } }
    (B[m[32m+            let mut norm = 0.0f32;
    (B[m[32m+            for x in &v {
    (B[m[32m+                norm += *x * *x;
    (B[m[32m+            }
    (B[m[32m+            if norm > 0.0 {
    (B[m[32m+                let inv = 1.0 / norm.sqrt();
    (B[m[32m+                for x in &mut v {
    (B[m[32m+                    *x *= inv;
    (B[m[32m+                }
    (B[m[32m+            }
    (B[m             v
             }
         }
    Diff in /workspace/crates/memory/src/api.rs:307:
     
         // Public facade used by trait impl
    [31m-    pub(super) fn engine() -> &'static SimpleMemoryEngine { SimpleMemoryEngine::init() }
    (B[m[32m+    pub(super) fn engine() -> &'static SimpleMemoryEngine {
    (B[m[32m+        SimpleMemoryEngine::init()
    (B[m[32m+    }
    (B[m }
     
     /// Trait для абстракции над различными реализациями memory service
    Diff in /workspace/crates/memory/src/api.rs:349:
     
         fn get_system_health(&self) -> SystemHealthStatus {
             #[cfg(feature = "embeddings")]
    [31m-        { simple_engine::SimpleMemoryEngine::health_status() }
    (B[m[32m+        {
    (B[m[32m+            simple_engine::SimpleMemoryEngine::health_status()
    (B[m[32m+        }
    (B[m         #[cfg(not(feature = "embeddings"))]
    [31m-        { SystemHealthStatus::default() }
    (B[m[32m+        {
    (B[m[32m+            SystemHealthStatus::default()
    (B[m[32m+        }
    (B[m     }
     
         fn cache_stats(&self) -> (u64, u64, u64) {
    Diff in /workspace/crates/memory/src/api.rs:457:
             let records = engine.export_records();
             let json = serde_json::to_string_pretty(&records)?;
             let p = path.as_ref();
    [31m-        if let Some(parent) = p.parent() { fs::create_dir_all(parent)?; }
    (B[m[32m+        if let Some(parent) = p.parent() {
    (B[m[32m+            fs::create_dir_all(parent)?;
    (B[m[32m+        }
    (B[m         fs::write(p, json)?;
             Ok(records.len())
         }
    Diff in /workspace/crates/memory/src/api.rs:856:
             }
             use crate::types::Layer;
             // Subscribe before actions
    [31m-        let mut rx_upsert = simple_engine::MEMORY_EVENT_BUS.subscribe(common::topics::TOPIC_MEMORY_UPSERT).await;
    (B[m[31m-        let mut rx_search = simple_engine::MEMORY_EVENT_BUS.subscribe(common::topics::TOPIC_MEMORY_SEARCH).await;
    (B[m[32m+        let mut rx_upsert = simple_engine::MEMORY_EVENT_BUS
    (B[m[32m+            .subscribe(common::topics::TOPIC_MEMORY_UPSERT)
    (B[m[32m+            .await;
    (B[m[32m+        let mut rx_search = simple_engine::MEMORY_EVENT_BUS
    (B[m[32m+            .subscribe(common::topics::TOPIC_MEMORY_SEARCH)
    (B[m[32m+            .await;
    (B[m 
             // Use public API to trigger events
             let api = UnifiedMemoryAPI::new(Arc::new(DIMemoryService::new()));
    Diff in /workspace/crates/memory/src/api.rs:864:
             let _id = api
    [31m-            .remember("event bus note".to_string(), MemoryContext::new("note").with_layer(Layer::Insights))
    (B[m[32m+            .remember(
    (B[m[32m+                "event bus note".to_string(),
    (B[m[32m+                MemoryContext::new("note").with_layer(Layer::Insights),
    (B[m[32m+            )
    (B[m             .await
                 .expect("remember ok");
     
    Diff in /workspace/crates/memory/src/api.rs:875:
     
             // Trigger search
             let _ = api
    [31m-            .recall("note" , SearchOptions::default().in_layers(vec![Layer::Insights]).limit(1))
    (B[m[32m+            .recall(
    (B[m[32m+                "note",
    (B[m[32m+                SearchOptions::default()
    (B[m[32m+                    .in_layers(vec![Layer::Insights])
    (B[m[32m+                    .limit(1),
    (B[m[32m+            )
    (B[m             .await
                 .expect("recall ok");
     
    Diff in /workspace/crates/memory/src/cache_lru.rs:748:
     
     fn current_timestamp() -> u64 {
         #[cfg(test)]
    [31m-    if let Some(ts) = _clock_mock::get() { return ts; }
    (B[m[32m+    if let Some(ts) = _clock_mock::get() {
    (B[m[32m+        return ts;
    (B[m[32m+    }
    (B[m     SystemTime::now()
             .duration_since(UNIX_EPOCH)
             .map(|d| d.as_secs())
    Diff in /workspace/crates/memory/src/cache_lru.rs:761:
     /// Safe version that returns Result instead of panicking
     fn current_timestamp_safe() -> Result<u64> {
         #[cfg(test)]
    [31m-    if let Some(ts) = _clock_mock::get() { return Ok(ts); }
    (B[m[32m+    if let Some(ts) = _clock_mock::get() {
    (B[m[32m+        return Ok(ts);
    (B[m[32m+    }
    (B[m     SystemTime::now()
             .duration_since(UNIX_EPOCH)
             .map(|d| d.as_secs())
    Diff in /workspace/crates/memory/src/di/container_metrics_impl.rs:667:
         fn test_record_failure() {
             let metrics = ContainerMetricsImpl::new(MetricsConfig::development());
             let type_id = TypeId::of::<String>();
    [31m-        let error = DIError::validation_error("Type not registered", Some(format!("{:?}", type_id)), "resolution");
    (B[m[32m+        let error = DIError::validation_error(
    (B[m[32m+            "Type not registered",
    (B[m[32m+            Some(format!("{:?}", type_id)),
    (B[m[32m+            "resolution",
    (B[m[32m+        );
    (B[m 
             metrics.record_resolution_failure(type_id, &error);
     
    Diff in /workspace/crates/memory/src/di/mod.rs:70:
     // === НОВЫЕ ДЕКОМПОЗИРОВАННЫЕ МОДУЛИ ===
     pub mod container_metrics_impl;
     pub mod dependency_graph_validator; // Валидация циклических зависимостей
    [31m-// (отключаем устаревшие/вторые реализации registry/resolver, чтобы исключить конфликты)
    (B[m[31m-// #[cfg(not(feature = "minimal"))]
    (B[m[31m-// pub mod memory_configurator; // Настройка memory компонентов в DI
    (B[m[31m-// #[cfg(not(feature = "minimal"))]
    (B[m[31m-// pub mod service_registry_impl; // Регистрация сервисов
    (B[m[31m-// #[cfg(not(feature = "minimal"))]
    (B[m[31m-// pub mod service_resolver_impl; // Разрешение зависимостей // Сбор метрик производительности
    (B[m[32m+                                    // (отключаем устаревшие/вторые реализации registry/resolver, чтобы исключить конфликты)
    (B[m[32m+                                    // #[cfg(not(feature = "minimal"))]
    (B[m[32m+                                    // pub mod memory_configurator; // Настройка memory компонентов в DI
    (B[m[32m+                                    // #[cfg(not(feature = "minimal"))]
    (B[m[32m+                                    // pub mod service_registry_impl; // Регистрация сервисов
    (B[m[32m+                                    // #[cfg(not(feature = "minimal"))]
    (B[m[32m+                                    // pub mod service_resolver_impl; // Разрешение зависимостей // Сбор метрик производительности
    (B[m 
     // === Старые модули (deprecated) — отключены для единой реализации ===
     // pub mod container_builder;
    Diff in /workspace/crates/memory/src/di/mod.rs:124:
     // Совместимые алиасы для единой реализации
     #[cfg(not(feature = "minimal"))]
     pub use unified_container_impl::{
    [31m-    container_builder,
    (B[m[31m-    create_container,
    (B[m[31m-    create_development_container,
    (B[m[31m-    create_production_container,
    (B[m[31m-    create_test_container,
    (B[m[31m-    development_builder,
    (B[m[31m-    production_builder,
    (B[m[31m-    UnifiedContainer,
    (B[m[32m+    container_builder, create_container, create_development_container, create_production_container,
    (B[m[32m+    create_test_container, development_builder, production_builder, UnifiedContainer,
    (B[m     UnifiedContainerBuilder,
     };
     
    Diff in /workspace/crates/memory/src/hnsw_index/index.rs:12:
     use std::arch::x86_64::*;
     
     #[cfg(feature = "hnsw-index")]
    [31m-use rayon::slice::ParallelSlice;
    (B[m[32m+use rayon::iter::{IndexedParallelIterator, IntoParallelRefIterator, ParallelIterator};
    (B[m #[cfg(feature = "hnsw-index")]
    [31m-use rayon::iter::{IntoParallelRefIterator, IndexedParallelIterator, ParallelIterator};
    (B[m[32m+use rayon::slice::ParallelSlice;
    (B[m 
     use super::config::HnswConfig;
     use super::stats::HnswStats;
    Diff in /workspace/crates/memory/src/hnsw_index/index.rs:146:
             let iter = queries.par_chunks(chunk_size);
             #[cfg(not(feature = "hnsw-index"))]
             let iter = queries.chunks(chunk_size);
    [31m-        iter
    (B[m[31m-            .flat_map(|chunk| batch_cosine_distance_avx2_ultra(chunk, target))
    (B[m[32m+        iter.flat_map(|chunk| batch_cosine_distance_avx2_ultra(chunk, target))
    (B[m             .collect()
         }
     
    Diff in /workspace/crates/memory/src/hnsw_index/index.rs:288:
     
                 let ef_c = self.config.ef_construction as usize;
                 let m = self.config.max_connections as usize;
    [31m-            let hnsw: Hnsw<f32, DistCosine> = Hnsw::new(m, actual_size, self.config.dimension, ef_c, DistCosine {});
    (B[m[32m+            let hnsw: Hnsw<f32, DistCosine> =
    (B[m[32m+                Hnsw::new(m, actual_size, self.config.dimension, ef_c, DistCosine {});
    (B[m             *hnsw_guard = Some(hnsw);
     
                 info!(
    Diff in /workspace/crates/memory/src/hnsw_index/index.rs:787:
                     let iter = vectors.par_iter();
                     #[cfg(not(feature = "hnsw-index"))]
                     let iter = vectors.iter();
    [31m-                iter
    (B[m[31m-                    .map(|v| {
    (B[m[31m-                        let aligned_vec =
    (B[m[31m-                            crate::simd_ultra_optimized::AlignedVector::new(v.clone());
    (B[m[31m-                        if aligned_vec.is_avx2_aligned() {
    (B[m[31m-                            unsafe { self.compute_norm_avx2(aligned_vec.as_aligned_slice()) }
    (B[m[31m-                        } else {
    (B[m[31m-                            self.compute_norm_scalar(v)
    (B[m[31m-                        }
    (B[m[31m-                    })
    (B[m[31m-                    .collect()
    (B[m[32m+                iter.map(|v| {
    (B[m[32m+                    let aligned_vec = crate::simd_ultra_optimized::AlignedVector::new(v.clone());
    (B[m[32m+                    if aligned_vec.is_avx2_aligned() {
    (B[m[32m+                        unsafe { self.compute_norm_avx2(aligned_vec.as_aligned_slice()) }
    (B[m[32m+                    } else {
    (B[m[32m+                        self.compute_norm_scalar(v)
    (B[m[32m+                    }
    (B[m[32m+                })
    (B[m[32m+                .collect()
    (B[m             } else {
                     // Fallback к оптимизированному scalar обработке
                     #[cfg(feature = "hnsw-index")]
    Diff in /workspace/crates/memory/src/hnsw_index/index.rs:804:
                     let iter = vectors.par_iter();
                     #[cfg(not(feature = "hnsw-index"))]
                     let iter = vectors.iter();
    [31m-                iter
    (B[m[31m-                    .map(|v| self.compute_norm_scalar(v))
    (B[m[31m-                    .collect()
    (B[m[32m+                iter.map(|v| self.compute_norm_scalar(v)).collect()
    (B[m             }
             }
     
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:12:
     }
     
     impl KeywordIndex {
    [31m-    pub fn new() -> Self { Self::default() }
    (B[m[32m+    pub fn new() -> Self {
    (B[m[32m+        Self::default()
    (B[m[32m+    }
    (B[m 
         pub fn add_document(&mut self, id: &str, text: &str, layer: Layer) -> Result<()> {
             let tokens = tokenize(text);
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:19:
    [31m-        if tokens.is_empty() { return Ok(()); }
    (B[m[32m+        if tokens.is_empty() {
    (B[m[32m+            return Ok(());
    (B[m[32m+        }
    (B[m 
             let mut tf_map: HashMap<String, u32> = HashMap::new();
    [31m-        for tok in tokens.iter() { *tf_map.entry(tok.clone()).or_insert(0) += 1; }
    (B[m[32m+        for tok in tokens.iter() {
    (B[m[32m+            *tf_map.entry(tok.clone()).or_insert(0) += 1;
    (B[m[32m+        }
    (B[m 
             let id_string = id.to_string();
             let length = tokens.len() as u32;
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:28:
             self.total_docs += 1;
     
             for (token, tf) in tf_map.into_iter() {
    [31m-            self.inverted_index.entry(token).or_default().push((id_string.clone(), tf));
    (B[m[32m+            self.inverted_index
    (B[m[32m+                .entry(token)
    (B[m[32m+                .or_default()
    (B[m[32m+                .push((id_string.clone(), tf));
    (B[m         }
             Ok(())
         }
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:35:
     
    [31m-    pub fn search(&self, query: &str, k: usize, layer: Option<Layer>) -> Result<Vec<(String, f32)>> {
    (B[m[32m+    pub fn search(
    (B[m[32m+        &self,
    (B[m[32m+        query: &str,
    (B[m[32m+        k: usize,
    (B[m[32m+        layer: Option<Layer>,
    (B[m[32m+    ) -> Result<Vec<(String, f32)>> {
    (B[m         let query_tokens = tokenize(query);
    [31m-        if query_tokens.is_empty() || self.total_docs == 0 { return Ok(vec![]); }
    (B[m[32m+        if query_tokens.is_empty() || self.total_docs == 0 {
    (B[m[32m+            return Ok(vec![]);
    (B[m[32m+        }
    (B[m 
             let avgdl: f32 = {
                 let sum: u64 = self.doc_len.values().map(|&l| l as u64).sum();
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:55:
                         if let Some(dl) = self.doc_len.get(doc_id) {
                             if let Some(l_filter) = layer {
                                 if let Some(doc_layer) = self.id_to_layer.get(doc_id) {
    [31m-                                if *doc_layer != l_filter { continue; }
    (B[m[32m+                                if *doc_layer != l_filter {
    (B[m[32m+                                    continue;
    (B[m[32m+                                }
    (B[m                             }
                             }
                             let tf = *tf as f32;
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:78:
     fn tokenize(text: &str) -> Vec<String> {
         let mut norm = String::with_capacity(text.len());
         for ch in text.chars() {
    [31m-        if ch.is_alphanumeric() { norm.push(ch.to_ascii_lowercase()); }
    (B[m[31m-        else { norm.push(' '); }
    (B[m[32m+        if ch.is_alphanumeric() {
    (B[m[32m+            norm.push(ch.to_ascii_lowercase());
    (B[m[32m+        } else {
    (B[m[32m+            norm.push(' ');
    (B[m[32m+        }
    (B[m     }
         norm.split_whitespace().map(|s| s.to_string()).collect()
     }
    Diff in /workspace/crates/memory/src/keyword_index/mod.rs:86:
    [32m+
    (B[mDiff in /workspace/crates/memory/src/lib.rs:1:
    [31m-#![cfg_attr(feature = "minimal", allow(dead_code, unused_imports, unused_variables))]
    (B[m[32m+#![cfg_attr(
    (B[m[32m+    feature = "minimal",
    (B[m[32m+    allow(dead_code, unused_imports, unused_variables)
    (B[m[32m+)]
    (B[m 
     #[cfg(not(feature = "minimal"))]
     mod batch_manager;
    Diff in /workspace/crates/memory/src/lib.rs:54:
     mod flush_config;
     #[cfg(not(feature = "minimal"))]
     pub mod gpu_accelerated;
    [32m+#[cfg(all(not(feature = "minimal"), feature = "keyword-search"))]
    (B[m[32m+pub mod keyword_index;
    (B[m #[cfg(all(not(feature = "minimal"), feature = "persistence"))]
     pub mod migration;
     #[cfg(not(feature = "minimal"))]
    Diff in /workspace/crates/memory/src/lib.rs:69:
     #[cfg(not(feature = "minimal"))]
     pub mod types;
     #[cfg(all(not(feature = "minimal"), feature = "hnsw-index"))]
    [31m-mod vector_index_hnswlib; // Critical for vector storage
    (B[m[31m-#[cfg(all(not(feature = "minimal"), feature = "keyword-search"))]
    (B[m[31m-pub mod keyword_index; // BM25/Tantivy индекс для гибридного поиска
    (B[m[31m-                          
    (B[m[32m+mod vector_index_hnswlib; // Critical for vector storage // BM25/Tantivy индекс для гибридного поиска
    (B[m[32m+
    (B[m // Экспорт единой DI-системы
     pub mod di;
     
    Diff in /workspace/crates/memory/src/lib.rs:81:
     // ОСНОВНОЙ DI API (в минимальном профиле доступен базовый контейнер)
     #[cfg(not(feature = "minimal"))]
     pub use di::{
    [31m-    UnifiedContainer as DIContainer,
    (B[m[31m-    UnifiedContainerBuilder as DIContainerBuilder,
    (B[m[31m-    Lifetime,
    (B[m[32m+    Lifetime, UnifiedContainer as DIContainer, UnifiedContainerBuilder as DIContainerBuilder,
    (B[m };
     #[cfg(feature = "minimal")]
     pub use di::{
    Diff in /workspace/crates/memory/src/lib.rs:90:
    [31m-    UnifiedContainer as DIContainer,
    (B[m[31m-    UnifiedContainerBuilder as DIContainerBuilder,
    (B[m[31m-    Lifetime,
    (B[m[32m+    Lifetime, UnifiedContainer as DIContainer, UnifiedContainerBuilder as DIContainerBuilder,
    (B[m };
     
     // Legacy API types - перенаправляем на реальные типы из di
    Diff in /workspace/crates/memory/src/lib.rs:103:
     // Utility functions и error handling
     #[cfg(not(feature = "minimal"))]
     pub mod utils;
    [32m+#[cfg(all(not(feature = "minimal"), feature = "persistence"))]
    (B[m[32m+pub use batch_manager::{BatchConfig, BatchOperationBuilder, BatchOperationManager, BatchStats};
    (B[m #[cfg(all(not(feature = "minimal"), feature = "vector-search"))]
     pub use batch_optimized::{
         AlignedBatchVectors, BatchOptimizedConfig, BatchOptimizedProcessor, BatchOptimizedStats,
    Diff in /workspace/crates/memory/src/lib.rs:109:
     };
    [31m-#[cfg(all(not(feature = "minimal"), feature = "persistence"))]
    (B[m[31m-pub use batch_manager::{BatchConfig, BatchOperationBuilder, BatchOperationManager, BatchStats};
    (B[m #[cfg(not(feature = "minimal"))]
     pub use cache_lru::{
         CacheConfig as LruCacheConfig, CacheConfig, EmbeddingCacheLRU as EmbeddingCache,
    Diff in /workspace/crates/memory/src/notifications.rs:839:
     
         #[async_trait]
         impl NotificationSender for DummySender {
    [31m-        fn channel_name(&self) -> &str { self.name }
    (B[m[32m+        fn channel_name(&self) -> &str {
    (B[m[32m+            self.name
    (B[m[32m+        }
    (B[m         async fn send_single(&self, _alert: &HealthAlert) -> Result<()> {
                 *self.singles.write() += 1;
                 Ok(())
    Diff in /workspace/crates/memory/src/notifications.rs:873:
             let batches = Arc::new(parking_lot::RwLock::new(0usize));
             manager.senders.insert(
                 "dummy".to_string(),
    [31m-            Arc::new(DummySender { name: "dummy", singles: singles.clone(), batches: batches.clone() })
    (B[m[32m+            Arc::new(DummySender {
    (B[m[32m+                name: "dummy",
    (B[m[32m+                singles: singles.clone(),
    (B[m[32m+                batches: batches.clone(),
    (B[m[32m+            }),
    (B[m         );
     
             // filtered out by ignore pattern
    Diff in /workspace/crates/memory/src/notifications.rs:893:
             assert_eq!(*singles.read(), 0);
     
             // passes filters and will be grouped (not sent yet)
    [31m-        let alert_ok = HealthAlert { id: "a2".into(), component: crate::health::ComponentType::Cache, severity: AlertSeverity::Warning, title: "ok1".into(), description: "d".into(), metric_value: None, threshold: None, timestamp: chrono::Utc::now(), resolved: false, resolved_at: None };
    (B[m[32m+        let alert_ok = HealthAlert {
    (B[m[32m+            id: "a2".into(),
    (B[m[32m+            component: crate::health::ComponentType::Cache,
    (B[m[32m+            severity: AlertSeverity::Warning,
    (B[m[32m+            title: "ok1".into(),
    (B[m[32m+            description: "d".into(),
    (B[m[32m+            metric_value: None,
    (B[m[32m+            threshold: None,
    (B[m[32m+            timestamp: chrono::Utc::now(),
    (B[m[32m+            resolved: false,
    (B[m[32m+            resolved_at: None,
    (B[m[32m+        };
    (B[m         manager.handle_alert(alert_ok).await.unwrap();
             assert_eq!(*singles.read(), 0);
     
    Diff in /workspace/crates/memory/src/notifications.rs:900:
             // second one triggers group send (max_group_size=2)
    [31m-        let alert_ok2 = HealthAlert { id: "a3".into(), component: crate::health::ComponentType::Cache, severity: AlertSeverity::Warning, title: "ok2".into(), description: "d".into(), metric_value: None, threshold: None, timestamp: chrono::Utc::now(), resolved: false, resolved_at: None };
    (B[m[32m+        let alert_ok2 = HealthAlert {
    (B[m[32m+            id: "a3".into(),
    (B[m[32m+            component: crate::health::ComponentType::Cache,
    (B[m[32m+            severity: AlertSeverity::Warning,
    (B[m[32m+            title: "ok2".into(),
    (B[m[32m+            description: "d".into(),
    (B[m[32m+            metric_value: None,
    (B[m[32m+            threshold: None,
    (B[m[32m+            timestamp: chrono::Utc::now(),
    (B[m[32m+            resolved: false,
    (B[m[32m+            resolved_at: None,
    (B[m[32m+        };
    (B[m         manager.handle_alert(alert_ok2).await.unwrap();
             // batch path counts number of alerts sent
             assert_eq!(*batches.read(), 2);
    Diff in /workspace/crates/memory/src/notifications.rs:905:
     
             // cooldown: send immediate fatal bypass grouping
    [31m-        let alert_fatal = HealthAlert { id: "a4".into(), component: crate::health::ComponentType::Cache, severity: AlertSeverity::Fatal, title: "fatal".into(), description: "d".into(), metric_value: None, threshold: None, timestamp: chrono::Utc::now(), resolved: false, resolved_at: None };
    (B[m[32m+        let alert_fatal = HealthAlert {
    (B[m[32m+            id: "a4".into(),
    (B[m[32m+            component: crate::health::ComponentType::Cache,
    (B[m[32m+            severity: AlertSeverity::Fatal,
    (B[m[32m+            title: "fatal".into(),
    (B[m[32m+            description: "d".into(),
    (B[m[32m+            metric_value: None,
    (B[m[32m+            threshold: None,
    (B[m[32m+            timestamp: chrono::Utc::now(),
    (B[m[32m+            resolved: false,
    (B[m[32m+            resolved_at: None,
    (B[m[32m+        };
    (B[m         manager.handle_alert(alert_fatal).await.unwrap();
             assert_eq!(*singles.read(), 1);
         }
    Diff in /workspace/crates/memory/src/orchestration/background_task_manager.rs:88:
         pub async fn start_all_tasks(
             &self,
             health_coordinator: Arc<dyn HealthCoordinator>,
    [31m-        #[cfg(feature = "legacy-orchestrator")]
    (B[m[31m-        circuit_breaker_manager: Arc<CircuitBreakerManager>,
    (B[m[31m-        #[cfg(feature = "legacy-orchestrator")]
    (B[m[31m-        metrics_collector: Arc<MetricsCollector>,
    (B[m[32m+        #[cfg(feature = "legacy-orchestrator")] circuit_breaker_manager: Arc<CircuitBreakerManager>,
    (B[m[32m+        #[cfg(feature = "legacy-orchestrator")] metrics_collector: Arc<MetricsCollector>,
    (B[m     ) -> Result<()> {
             info!("🔄 Запуск всех background задач");
     
    Diff in /workspace/crates/memory/src/orchestration/background_task_manager.rs:395:
                     uptime_seconds: 0,
                 })
             }
    [31m-        async fn component_health(&self, _component: &str) -> Result<bool> { Ok(true) }
    (B[m[31m-        async fn run_health_check(&self) -> Result<()> { Ok(()) }
    (B[m[31m-        async fn get_alerts(&self) -> Vec<String> { vec![] }
    (B[m[31m-        async fn clear_alerts(&self) -> Result<()> { Ok(()) }
    (B[m[32m+        async fn component_health(&self, _component: &str) -> Result<bool> {
    (B[m[32m+            Ok(true)
    (B[m[32m+        }
    (B[m[32m+        async fn run_health_check(&self) -> Result<()> {
    (B[m[32m+            Ok(())
    (B[m[32m+        }
    (B[m[32m+        async fn get_alerts(&self) -> Vec<String> {
    (B[m[32m+            vec![]
    (B[m[32m+        }
    (B[m[32m+        async fn clear_alerts(&self) -> Result<()> {
    (B[m[32m+            Ok(())
    (B[m[32m+        }
    (B[m         async fn health_check(&self) -> Result<()> {
                 self.call_count.fetch_add(1, Ordering::Relaxed);
     
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:198:
     
     #[cfg(not(all(not(feature = "minimal"), feature = "gpu-acceleration")))]
     impl EmbeddingCoordinator {
    [31m-    pub fn new_stub() -> Self { Self }
    (B[m[32m+    pub fn new_stub() -> Self {
    (B[m[32m+        Self
    (B[m[32m+    }
    (B[m }
     
     #[async_trait]
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:311:
     #[cfg(not(all(not(feature = "minimal"), feature = "gpu-acceleration")))]
     #[async_trait::async_trait]
     impl Coordinator for EmbeddingCoordinator {
    [31m-    async fn initialize(&self) -> Result<()> { Ok(()) }
    (B[m[31m-    async fn is_ready(&self) -> bool { true }
    (B[m[31m-    async fn health_check(&self) -> Result<()> { Ok(()) }
    (B[m[31m-    async fn shutdown(&self) -> Result<()> { Ok(()) }
    (B[m[31m-    async fn metrics(&self) -> serde_json::Value { serde_json::json!({"ready": true}) }
    (B[m[32m+    async fn initialize(&self) -> Result<()> {
    (B[m[32m+        Ok(())
    (B[m[32m+    }
    (B[m[32m+    async fn is_ready(&self) -> bool {
    (B[m[32m+        true
    (B[m[32m+    }
    (B[m[32m+    async fn health_check(&self) -> Result<()> {
    (B[m[32m+        Ok(())
    (B[m[32m+    }
    (B[m[32m+    async fn shutdown(&self) -> Result<()> {
    (B[m[32m+        Ok(())
    (B[m[32m+    }
    (B[m[32m+    async fn metrics(&self) -> serde_json::Value {
    (B[m[32m+        serde_json::json!({"ready": true})
    (B[m[32m+    }
    (B[m }
     
     #[async_trait]
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:461:
     #[cfg(not(all(not(feature = "minimal"), feature = "gpu-acceleration")))]
     #[async_trait::async_trait]
     impl EmbeddingCoordinatorTrait for EmbeddingCoordinator {
    [31m-    async fn get_embedding(&self, _text: &str) -> Result<Vec<f32>> { Ok(vec![0.0; 1024]) }
    (B[m[32m+    async fn get_embedding(&self, _text: &str) -> Result<Vec<f32>> {
    (B[m[32m+        Ok(vec![0.0; 1024])
    (B[m[32m+    }
    (B[m     async fn get_embeddings(&self, texts: &[String]) -> Result<Vec<Vec<f32>>> {
             Ok(texts.iter().map(|_| vec![0.0; 1024]).collect())
         }
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:468:
    [31m-    async fn check_cache(&self, _text: &str) -> Option<Vec<f32>> { None }
    (B[m[31m-    async fn cache_stats(&self) -> (u64, u64, u64) { (0,0,0) }
    (B[m[31m-    async fn clear_cache(&self) -> Result<()> { Ok(()) }
    (B[m[32m+    async fn check_cache(&self, _text: &str) -> Option<Vec<f32>> {
    (B[m[32m+        None
    (B[m[32m+    }
    (B[m[32m+    async fn cache_stats(&self) -> (u64, u64, u64) {
    (B[m[32m+        (0, 0, 0)
    (B[m[32m+    }
    (B[m[32m+    async fn clear_cache(&self) -> Result<()> {
    (B[m[32m+        Ok(())
    (B[m[32m+    }
    (B[m }
     
     #[cfg(all(not(feature = "minimal"), feature = "gpu-acceleration"))]
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:568:
             }
     
             // Простейшая адаптация: если средняя латентность растет - уменьшаем batch
    [31m-        let avg_latency: f64 =
    (B[m[31m-            config.recent_latencies.iter().map(|&x| x as f64).sum::<f64>()
    (B[m[31m-                / config.recent_latencies.len().max(1) as f64;
    (B[m[32m+        let avg_latency: f64 = config
    (B[m[32m+            .recent_latencies
    (B[m[32m+            .iter()
    (B[m[32m+            .map(|&x| x as f64)
    (B[m[32m+            .sum::<f64>()
    (B[m[32m+            / config.recent_latencies.len().max(1) as f64;
    (B[m 
             if avg_latency > 50.0 && config.current_size > config.min_size {
                 config.current_size = (config.current_size / 2).max(config.min_size);
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:577:
    [31m-            debug!("📉 Снижаем batch размер до {} из-за высокой латентности {}ms", config.current_size, avg_latency);
    (B[m[32m+            debug!(
    (B[m[32m+                "📉 Снижаем batch размер до {} из-за высокой латентности {}ms",
    (B[m[32m+                config.current_size, avg_latency
    (B[m[32m+            );
    (B[m         } else if avg_latency < 20.0 && config.current_size < config.max_size {
                 config.current_size = (config.current_size * 2).min(config.max_size);
    [31m-            debug!("📈 Увеличиваем batch размер до {} при низкой латентности {}ms", config.current_size, avg_latency);
    (B[m[32m+            debug!(
    (B[m[32m+                "📈 Увеличиваем batch размер до {} при низкой латентности {}ms",
    (B[m[32m+                config.current_size, avg_latency
    (B[m[32m+            );
    (B[m         }
         }
     }
    Diff in /workspace/crates/memory/src/orchestration/embedding_coordinator.rs:585:
     #[cfg(not(all(not(feature = "minimal"), feature = "gpu-acceleration")))]
     impl EmbeddingCoordinator {
         async fn start_batch_processor(&self) {}
    [31m-    async fn warm_model(&self) -> Result<()> { Ok(()) }
    (B[m[31m-    pub async fn get_performance_metrics(&self) -> PerformanceMetrics { PerformanceMetrics::default() }
    (B[m[32m+    async fn warm_model(&self) -> Result<()> {
    (B[m[32m+        Ok(())
    (B[m[32m+    }
    (B[m[32m+    pub async fn get_performance_metrics(&self) -> PerformanceMetrics {
    (B[m[32m+        PerformanceMetrics::default()
    (B[m[32m+    }
    (B[m     async fn adjust_batch_size(&self, _latency_ms: u64) {}
     }
     
    Diff in /workspace/crates/memory/src/orchestration/search_coordinator.rs:469:
     
             // 1) Векторные кандидаты
             let k_vec = options.top_k;
    [31m-        let vector_candidates = self.vector_search(&vector, layer, SearchOptions { top_k: k_vec, ..options }).await?;
    (B[m[32m+        let vector_candidates = self
    (B[m[32m+            .vector_search(
    (B[m[32m+                &vector,
    (B[m[32m+                layer,
    (B[m[32m+                SearchOptions {
    (B[m[32m+                    top_k: k_vec,
    (B[m[32m+                    ..options
    (B[m[32m+                },
    (B[m[32m+            )
    (B[m[32m+            .await?;
    (B[m 
             // 2) Ключевые кандидаты (если индекс доступен)
             #[cfg(all(not(feature = "minimal"), feature = "keyword-search"))]
    Diff in /workspace/crates/memory/src/orchestration/search_coordinator.rs:504:
     
             // RRF (reciprocal rank fusion) + веса alpha/beta
             let alpha = 0.6_f32; // вес вектора
    [31m-        let beta = 0.4_f32;  // вес keyword
    (B[m[32m+        let beta = 0.4_f32; // вес keyword
    (B[m         let k_rrf = 60.0_f32; // сглаживание
     
             let mut scored: Vec<(Record, f32)> = fused
    Diff in /workspace/crates/memory/src/orchestration/search_coordinator.rs:520:
             scored.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
             scored.truncate(options.top_k);
     
    [31m-        let mut out: Vec<Record> = scored.into_iter().map(|mut t| { let mut r=t.0; r.score=t.1; r }).collect();
    (B[m[32m+        let mut out: Vec<Record> = scored
    (B[m[32m+            .into_iter()
    (B[m[32m+            .map(|mut t| {
    (B[m[32m+                let mut r = t.0;
    (B[m[32m+                r.score = t.1;
    (B[m[32m+                r
    (B[m[32m+            })
    (B[m[32m+            .collect();
    (B[m         Ok(out)
         }
     
    Diff in /workspace/crates/memory/src/orchestration/search_coordinator.rs:556:
             if let Some(model) = self.rerank_model.read().await.as_ref() {
                 let start_time = Instant::now();
                 let documents: Vec<String> = candidates.iter().map(|r| r.text.clone()).collect();
    [31m-            let batch = ai::RerankBatch { query: query.to_string(), documents, top_k: Some(options.top_k) };
    (B[m[32m+            let batch = ai::RerankBatch {
    (B[m[32m+                query: query.to_string(),
    (B[m[32m+                documents,
    (B[m[32m+                top_k: Some(options.top_k),
    (B[m[32m+            };
    (B[m             match model.rerank_batch(&batch) {
                     Ok(batch_out) => {
                         let rerank_latency = start_time.elapsed().as_millis();
    Diff in /workspace/crates/memory/src/orchestration/search_coordinator.rs:566:
                             metrics.rerank_operations += 1;
                         }
                         let mut new_order = Vec::with_capacity(batch_out.results.len());
    [31m-                    for item in batch_out.results { // item.index соответствует позиции в candidates
    (B[m[32m+                    for item in batch_out.results {
    (B[m[32m+                        // item.index соответствует позиции в candidates
    (B[m                         if let Some(r) = candidates.get(item.index) {
                                 let mut rr = r.clone();
                                 rr.score = item.score;
    Diff in /workspace/crates/memory/src/service_di/coordinator_factory.rs:21:
         orchestration::{EmbeddingCoordinator, HealthManager, ResourceController, SearchCoordinator},
     };
     
    [31m-use crate::orchestration::Coordinator;
    (B[m use crate::di::core_traits::ServiceResolver;
    [32m+use crate::orchestration::Coordinator;
    (B[m 
     /// Trait для создания координаторов (Dependency Inversion)
     #[allow(async_fn_in_trait)]
    Diff in /workspace/crates/memory/src/service_di/coordinator_factory.rs:437:
             }
             #[cfg(not(all(not(feature = "minimal"), feature = "gpu-acceleration")))]
             {
    [31m-            Err(anyhow::anyhow!("GpuBatchProcessor недоступен без фичи gpu-acceleration"))
    (B[m[32m+            Err(anyhow::anyhow!(
    (B[m[32m+                "GpuBatchProcessor недоступен без фичи gpu-acceleration"
    (B[m[32m+            ))
    (B[m         }
         }
     
    Diff in /workspace/crates/memory/src/service_di/coordinator_factory.rs:455:
                 .ok_or_else(|| anyhow::anyhow!("Не удалось resolve VectorStore из DI container"))?;
     
             #[cfg(not(all(not(feature = "minimal"), feature = "persistence")))]
    [31m-        return Err(anyhow::anyhow!("VectorStore недоступен без фичи persistence"));
    (B[m[32m+        return Err(anyhow::anyhow!(
    (B[m[32m+            "VectorStore недоступен без фичи persistence"
    (B[m[32m+        ));
    (B[m 
             let coordinator = Arc::new(SearchCoordinator::new_production(
                 store,
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:20:
     
     #[cfg(all(not(feature = "minimal"), feature = "backup-restore"))]
     use crate::backup::BackupManager;
    [31m-use crate::{batch_manager::BatchOperationManager, di::traits::DIResolver, metrics::MetricsCollector};
    (B[m use crate::di::core_traits::ServiceResolver;
     use crate::orchestration::traits::EmbeddingCoordinator as EmbeddingCoordinatorTrait;
    [32m+use crate::{
    (B[m[32m+    batch_manager::BatchOperationManager, di::traits::DIResolver, metrics::MetricsCollector,
    (B[m[32m+};
    (B[m 
     #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
     use crate::di::unified_container_impl::UnifiedContainer as UnifiedDIContainer;
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:29:
     
     // NEW: Bring commonly used types into scope
     #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
    [31m-use crate::storage::VectorStore;
    (B[m[32m+use crate::orchestration::traits::SearchCoordinator as SearchCoordinatorTrait;
    (B[m #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
    [31m-use crate::types::{Layer, Record, SearchOptions};
    (B[m[32m+use crate::orchestration::{
    (B[m[32m+    EmbeddingCoordinator as EmbeddingCoordinatorImpl, SearchCoordinator as SearchCoordinatorImpl,
    (B[m[32m+};
    (B[m #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
     use crate::orchestration::{RetryHandler, RetryPolicy, RetryResult};
     #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:38:
    [31m-use crate::orchestration::traits::SearchCoordinator as SearchCoordinatorTrait;
    (B[m[32m+use crate::storage::VectorStore;
    (B[m #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
    [31m-use crate::orchestration::{EmbeddingCoordinator as EmbeddingCoordinatorImpl, SearchCoordinator as SearchCoordinatorImpl};
    (B[m[32m+use crate::types::{Layer, Record, SearchOptions};
    (B[m #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
     use common::OperationTimer;
     
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:65:
     #[cfg(all(not(feature = "minimal"), feature = "orchestration-modules"))]
     #[async_trait]
     pub trait OperationExecutor: Send + Sync {
    [31m-    async fn search(&self, query: &str, layer: crate::types::Layer, options: crate::types::SearchOptions) -> anyhow::Result<Vec<crate::types::Record>>;
    (B[m[32m+    async fn search(
    (B[m[32m+        &self,
    (B[m[32m+        query: &str,
    (B[m[32m+        layer: crate::types::Layer,
    (B[m[32m+        options: crate::types::SearchOptions,
    (B[m[32m+    ) -> anyhow::Result<Vec<crate::types::Record>>;
    (B[m     async fn insert(&self, record: crate::types::Record) -> anyhow::Result<()>;
         async fn run_promotion(&self) -> anyhow::Result<crate::promotion::PromotionStats>;
         async fn get_stats(&self) -> crate::metrics::MemoryMetrics;
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:72:
     
    [31m-    async fn batch_insert(&self, records: Vec<crate::types::Record>) -> anyhow::Result<BatchInsertResult>;
    (B[m[31m-    async fn batch_search(&self, queries: Vec<String>, layer: crate::types::Layer, options: crate::types::SearchOptions) -> anyhow::Result<BatchSearchResult>;
    (B[m[32m+    async fn batch_insert(
    (B[m[32m+        &self,
    (B[m[32m+        records: Vec<crate::types::Record>,
    (B[m[32m+    ) -> anyhow::Result<BatchInsertResult>;
    (B[m[32m+    async fn batch_search(
    (B[m[32m+        &self,
    (B[m[32m+        queries: Vec<String>,
    (B[m[32m+        layer: crate::types::Layer,
    (B[m[32m+        options: crate::types::SearchOptions,
    (B[m[32m+    ) -> anyhow::Result<BatchSearchResult>;
    (B[m     async fn update(&self, record: crate::types::Record) -> anyhow::Result<()>;
         async fn delete(&self, id: &uuid::Uuid, layer: crate::types::Layer) -> anyhow::Result<()>;
         async fn initialize(&self) -> anyhow::Result<()>;
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:78:
         async fn shutdown(&self) -> anyhow::Result<()>;
         async fn flush_all(&self) -> anyhow::Result<()>;
    [31m-    async fn create_backup(&self, path: &str) -> anyhow::Result<crate::orchestration::traits::BackupMetadata>;
    (B[m[32m+    async fn create_backup(
    (B[m[32m+        &self,
    (B[m[32m+        path: &str,
    (B[m[32m+    ) -> anyhow::Result<crate::orchestration::traits::BackupMetadata>;
    (B[m }
     
     /// Конфигурация для выполнения операций
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:540:
         }
     
         /// Создать backup
    [31m-    async fn create_backup(&self, path: &str) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m[32m+    async fn create_backup(
    (B[m[32m+        &self,
    (B[m[32m+        path: &str,
    (B[m[32m+    ) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m         let start = Instant::now();
             #[cfg(all(not(feature = "minimal"), feature = "backup-restore"))]
             let backup_manager = self.container.resolve::<crate::backup::BackupManager>()?;
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:713:
         }
     
         /// Простой backup (mock implementation)
    [31m-    async fn create_backup(&self, path: &str) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m[32m+    async fn create_backup(
    (B[m[32m+        &self,
    (B[m[32m+        path: &str,
    (B[m[32m+    ) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m         let start = Instant::now();
             let duration = start.elapsed();
             info!("Бэкап создан за {:?}", duration);
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:756:
         }
     
         /// Создать backup
    [31m-    pub async fn create_backup(&self, path: &str) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m[32m+    pub async fn create_backup(
    (B[m[32m+        &self,
    (B[m[32m+        path: &str,
    (B[m[32m+    ) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m         debug!("Создание backup через DI: {}", path);
     
             #[cfg(all(not(feature = "minimal"), feature = "backup-restore"))]
    Diff in /workspace/crates/memory/src/service_di/operation_executor.rs:868:
             self.base_executor.run_promotion().await
         }
     
    [31m-    async fn create_backup(&self, path: &str) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m[32m+    async fn create_backup(
    (B[m[32m+        &self,
    (B[m[32m+        path: &str,
    (B[m[32m+    ) -> Result<crate::orchestration::traits::BackupMetadata> {
    (B[m         self.base_executor.create_backup(path).await
         }
     
    Diff in /workspace/crates/memory/src/service_di/service_config.rs:8:
     use common::service_traits::ConfigurationProfile;
     use std::path::PathBuf;
     
    [31m-use crate::{
    (B[m[31m-    cache_lru::CacheConfig,
    (B[m[31m-    resource_manager::ResourceConfig,
    (B[m[31m-};
    (B[m[32m+#[cfg(all(not(feature = "minimal"), feature = "persistence"))]
    (B[m[32m+use crate::batch_manager::BatchConfig;
    (B[m #[cfg(all(not(feature = "minimal"), feature = "gpu-acceleration"))]
     use crate::gpu_accelerated::GpuDeviceManager;
    [31m-#[cfg(not(feature = "minimal"))]
    (B[m[31m-use crate::notifications::NotificationConfig;
    (B[m #[cfg(all(not(feature = "minimal"), feature = "persistence"))]
     use crate::ml_promotion::MLPromotionConfig;
    [31m-#[cfg(all(not(feature = "minimal"), feature = "persistence"))]
    (B[m[31m-use crate::batch_manager::BatchConfig;
    (B[m[31m-use crate::{health::HealthMonitorConfig, streaming::StreamingConfig, types::PromotionConfig, CacheConfigType};
    (B[m[32m+#[cfg(not(feature = "minimal"))]
    (B[m[32m+use crate::notifications::NotificationConfig;
    (B[m[32m+use crate::{cache_lru::CacheConfig, resource_manager::ResourceConfig};
    (B[m[32m+use crate::{
    (B[m[32m+    health::HealthMonitorConfig, streaming::StreamingConfig, types::PromotionConfig,
    (B[m[32m+    CacheConfigType,
    (B[m[32m+};
    (B[m 
     // Fallback BatchConfig when persistence is disabled
     #[cfg(not(all(not(feature = "minimal"), feature = "persistence")))]
    Diff in /workspace/crates/memory/src/service_di/service_config.rs:33:
     #[cfg(not(all(not(feature = "minimal"), feature = "persistence")))]
     impl Default for BatchConfig {
         fn default() -> Self {
    [31m-        Self { max_batch_size: 64, flush_interval_ms: 100 }
    (B[m[32m+        Self {
    (B[m[32m+            max_batch_size: 64,
    (B[m[32m+            flush_interval_ms: 100,
    (B[m[32m+        }
    (B[m     }
     }
     
    Diff in /workspace/crates/memory/src/service_di/service_config.rs:40:
     #[cfg(not(all(not(feature = "minimal"), feature = "persistence")))]
     impl BatchConfig {
    [31m-    pub fn production() -> Self { Self { max_batch_size: 512, flush_interval_ms: 50 } }
    (B[m[31m-    pub fn minimal() -> Self { Self { max_batch_size: 16, flush_interval_ms: 250 } }
    (B[m[32m+    pub fn production() -> Self {
    (B[m[32m+        Self {
    (B[m[32m+            max_batch_size: 512,
    (B[m[32m+            flush_interval_ms: 50,
    (B[m[32m+        }
    (B[m[32m+    }
    (B[m[32m+    pub fn minimal() -> Self {
    (B[m[32m+        Self {
    (B[m[32m+            max_batch_size: 16,
    (B[m[32m+            flush_interval_ms: 250,
    (B[m[32m+        }
    (B[m[32m+    }
    (B[m }
     
     /// Типы конфигурации Memory Service
    Diff in /workspace/crates/memory/src/streaming.rs:6:
     use tracing::{debug, error, info, warn};
     use uuid::Uuid;
     
    [31m-use crate::{
    (B[m[31m-    types::SearchOptions, Layer, Record,
    (B[m[31m-};
    (B[m[32m+use crate::{types::SearchOptions, Layer, Record};
    (B[m 
     #[cfg(all(not(feature = "minimal"), feature = "services-modules"))]
     use crate::services::RefactoredDIMemoryService as MemoryService;
    Diff in /workspace/crates/memory/src/streaming.rs:16:
     #[cfg(not(all(not(feature = "minimal"), feature = "services-modules")))]
     pub struct MemoryService;
     #[cfg(not(all(not(feature = "minimal"), feature = "services-modules")))]
    [31m-impl MemoryService { pub async fn insert(&self, _r: Record) -> Result<()> { Ok(()) } }
    (B[m[32m+impl MemoryService {
    (B[m[32m+    pub async fn insert(&self, _r: Record) -> Result<()> {
    (B[m[32m+        Ok(())
    (B[m[32m+    }
    (B[m[32m+}
    (B[m #[cfg(not(all(not(feature = "minimal"), feature = "services-modules")))]
    [31m-impl MemoryService { pub async fn search(&self, _q: &str, _l: Layer, _o: crate::types::SearchOptions) -> Result<Vec<Record>> { Ok(vec![]) } }
    (B[m[31m-
    (B[m[32m+impl MemoryService {
    (B[m[32m+    pub async fn search(
    (B[m[32m+        &self,
    (B[m[32m+        _q: &str,
    (B[m[32m+        _l: Layer,
    (B[m[32m+        _o: crate::types::SearchOptions,
    (B[m[32m+    ) -> Result<Vec<Record>> {
    (B[m[32m+        Ok(vec![])
    (B[m[32m+    }
    (B[m[32m+}
    (B[m 
     /// Streaming API для real-time обработки embeddings
     pub struct StreamingMemoryAPI {
    Diff in /workspace/crates/memory/src/utils/error_utils.rs:148:
     
     #[cfg(feature = "persistence")]
     pub fn open_db_with_context(path: &std::path::Path) -> Result<sled::Db> {
    [31m-    sled::open(path).with_context_fmt("Failed to open database", &[&path.display(), &"sled open"])        
    (B[m[32m+    sled::open(path).with_context_fmt("Failed to open database", &[&path.display(), &"sled open"])
    (B[m }
     
     #[cfg(feature = "persistence")]
    Diff in /workspace/crates/memory/src/utils/error_utils.rs:159:
     }
     
     #[cfg(feature = "persistence")]
    [31m-pub fn insert_with_context<K, V>(
    (B[m[31m-    tree: &sled::Tree,
    (B[m[31m-    key: K,
    (B[m[31m-    value: V,
    (B[m[31m-    context: &str,
    (B[m[31m-) -> Result<()>
    (B[m[32m+pub fn insert_with_context<K, V>(tree: &sled::Tree, key: K, value: V, context: &str) -> Result<()>
    (B[m where
         K: AsRef<[u8]>,
         V: Into<sled::IVec>,
    Diff in /workspace/crates/memory/tests/mod.rs:9:
     }
     
     // Heavier suites gated to persistence/vector/gpu features
    [31m-#[cfg(all(not(feature = "minimal"), feature = "persistence", feature = "legacy-tests"))]
    (B[m[32m+#[cfg(all(
    (B[m[32m+    not(feature = "minimal"),
    (B[m[32m+    feature = "persistence",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m mod persistence_suites {
         include!("./test_vector_store.rs");
         include!("./test_cache_migration.rs");
    Diff in /workspace/crates/memory/tests/mod.rs:20:
         include!("./test_batch_optimized.rs");
     }
     
    [31m-#[cfg(all(not(feature = "minimal"), feature = "gpu-acceleration", feature = "legacy-tests"))]
    (B[m[32m+#[cfg(all(
    (B[m[32m+    not(feature = "minimal"),
    (B[m[32m+    feature = "gpu-acceleration",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m mod gpu_suites {
         include!("./test_gpu_batch_processor.rs");
     }
    Diff in /workspace/crates/memory/tests/mod.rs:27:
    [32m+
    (B[mDiff in /workspace/crates/memory/tests/smoke_memory.rs:1:
     #[allow(unused_imports)]
    [31m-use memory::api::{MemoryContext, UnifiedMemoryAPI, MemoryServiceTrait};
    (B[m[31m-use memory::types::Layer;
    (B[m[32m+use memory::api::{MemoryContext, MemoryServiceTrait, UnifiedMemoryAPI};
    (B[m use memory::di::UnifiedContainer;
    [32m+use memory::types::Layer;
    (B[m 
     #[tokio::test]
     async fn smoke_remember_and_search() {
    Diff in /workspace/crates/memory/tests/smoke_memory.rs:23:
             .expect("remember must succeed");
     
         let results = tokio::time::timeout(std::time::Duration::from_secs(5), async {
    [31m-        api.recall("hello", memory::api::SearchOptions::default().limit(5)).await
    (B[m[32m+        api.recall("hello", memory::api::SearchOptions::default().limit(5))
    (B[m[32m+            .await
    (B[m     })
         .await
         .expect("search timeout")
    Diff in /workspace/crates/memory/tests/smoke_memory.rs:32:
         assert!(!id.as_bytes().is_empty());
         assert!(results.len() <= 5);
     }
    [32m+
    (B[mDiff in /workspace/crates/memory/tests/test_cache_migration.rs:1:
    [31m-#![cfg(all(feature = "extended-tests", feature = "persistence", feature = "legacy-tests"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    feature = "persistence",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m 
     use anyhow::Result;
     use memory::{
    Diff in /workspace/crates/memory/tests/test_gpu_batch_processor.rs:1:
     #![cfg(all(feature = "gpu-acceleration", feature = "extended-tests"))]
    [31m-
    (B[m // @component: {"k":"T","id":"gpu_batch_processor_tests","t":"Comprehensive unit tests for GpuBatchProcessor","m":{"cur":100,"tgt":100,"u":"%"},"f":["testing","gpu","performance","batch","fallback"]}
     
     //! Comprehensive Unit Tests для GpuBatchProcessor
    Diff in /workspace/crates/memory/tests/test_hnsw_index.rs:11:
         let index = VectorIndex::new(cfg).expect("config ok");
     
         // two clusters around unit vectors
    [31m-    let a = vec![1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0];
    (B[m[31m-    let b = vec![0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0];
    (B[m[32m+    let a = vec![1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    (B[m[32m+    let b = vec![0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    (B[m 
         index.add("A".into(), a.clone()).unwrap();
         index.add("B".into(), b.clone()).unwrap();
    Diff in /workspace/crates/memory/tests/test_hnsw_index.rs:19:
     
         // query near A
    [31m-    let q = vec![0.9,0.1,0.0,0.0,0.0,0.0,0.0,0.0];
    (B[m[32m+    let q = vec![0.9, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
    (B[m     let res = index.search(&q, 2).expect("search ok");
         assert_eq!(res.len(), 2);
    [31m-    let ids: Vec<String> = res.into_iter().map(|(id,_d)| id).collect();
    (B[m[32m+    let ids: Vec<String> = res.into_iter().map(|(id, _d)| id).collect();
    (B[m     assert_eq!(ids[0], "A");
     }
     
    Diff in /workspace/crates/memory/tests/test_hnsw_index.rs:31:
         cfg.dimension = 4;
         cfg.max_elements = 1;
         let index = VectorIndex::new(cfg).unwrap();
    [31m-    index.add("one".into(), vec![1.0,0.0,0.0,0.0]).unwrap();
    (B[m[31m-    let err = index.add("two".into(), vec![0.0,1.0,0.0,0.0]).unwrap_err();
    (B[m[32m+    index.add("one".into(), vec![1.0, 0.0, 0.0, 0.0]).unwrap();
    (B[m[32m+    let err = index
    (B[m[32m+        .add("two".into(), vec![0.0, 1.0, 0.0, 0.0])
    (B[m[32m+        .unwrap_err();
    (B[m     assert!(err.to_string().contains("capacity"));
     }
     
    Diff in /workspace/crates/memory/tests/test_hnsw_index.rs:45:
         let index = VectorIndex::new(cfg).unwrap();
     
         for i in 0..10 {
    [31m-        let mut v = vec![0.0,0.0,0.0,0.0];
    (B[m[32m+        let mut v = vec![0.0, 0.0, 0.0, 0.0];
    (B[m         v[i % 4] = 1.0;
             index.add(format!("id{}", i), v).unwrap();
         }
    Diff in /workspace/crates/memory/tests/test_hnsw_index.rs:52:
     
         let queries = vec![
    [31m-        vec![1.0,0.0,0.0,0.0],
    (B[m[31m-        vec![0.0,1.0,0.0,0.0],
    (B[m[31m-        vec![0.0,0.0,1.0,0.0],
    (B[m[32m+        vec![1.0, 0.0, 0.0, 0.0],
    (B[m[32m+        vec![0.0, 1.0, 0.0, 0.0],
    (B[m[32m+        vec![0.0, 0.0, 1.0, 0.0],
    (B[m     ];
         let out = index.parallel_search(&queries, 1).unwrap();
         assert_eq!(out.len(), 3);
    Diff in /workspace/crates/memory/tests/test_hnsw_index.rs:63:
             assert!(id.contains(&format!("{}", i))); // nearest one-hot should match position
         }
     }
    [32m+
    (B[mDiff in /workspace/crates/memory/tests/test_hnsw_property_based_comprehensive.rs:1:
    [31m-#![cfg(all(not(feature = "minimal"), feature = "hnsw-index", feature = "rayon", feature = "legacy-tests"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    not(feature = "minimal"),
    (B[m[32m+    feature = "hnsw-index",
    (B[m[32m+    feature = "rayon",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m 
     use arbitrary::{Arbitrary, Unstructured};
     use memory::{
    Diff in /workspace/crates/memory/tests/test_hybrid_search.rs:1:
    [31m-#![cfg(all(feature = "extended-tests", feature = "orchestrated-search", feature = "keyword-search"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    feature = "orchestrated-search",
    (B[m[32m+    feature = "keyword-search"
    (B[m[32m+))]
    (B[m 
    [31m-use memory::orchestration::SearchCoordinator;
    (B[m use memory::orchestration::traits::SearchCoordinator as SearchCoordinatorTrait;
    [31m-use memory::{storage::VectorStore, types::{Layer, Record, SearchOptions}};
    (B[m[32m+use memory::orchestration::SearchCoordinator;
    (B[m[32m+use memory::{
    (B[m[32m+    storage::VectorStore,
    (B[m[32m+    types::{Layer, Record, SearchOptions},
    (B[m[32m+};
    (B[m use std::sync::Arc;
     
     #[tokio::test]
    Diff in /workspace/crates/memory/tests/test_hybrid_search.rs:9:
     async fn hybrid_prefers_keyword_when_query_matches() {
         // Prepare store
         let temp = tempfile::TempDir::new().unwrap();
    [31m-    let store = Arc::new(VectorStore::with_config(&temp.path(), memory::vector_index_hnswlib::HnswRsConfig::default()).await.unwrap());
    (B[m[32m+    let store = Arc::new(
    (B[m[32m+        VectorStore::with_config(
    (B[m[32m+            &temp.path(),
    (B[m[32m+            memory::vector_index_hnswlib::HnswRsConfig::default(),
    (B[m[32m+        )
    (B[m[32m+        .await
    (B[m[32m+        .unwrap(),
    (B[m[32m+    );
    (B[m 
         // Insert records
    [31m-    let rec1 = Record { id: uuid::Uuid::new_v4(), text: "rust ownership borrowing lifetimes".to_string(), embedding: vec![0.0;1024], layer: Layer::Interact, kind: "note".into(), tags: vec![], project: "p".into(), session: "s".into(), ts: chrono::Utc::now(), score: 0.0, access_count: 0, last_access: chrono::Utc::now() };
    (B[m[31m-    let rec2 = Record { id: uuid::Uuid::new_v4(), text: "python asyncio event loop".to_string(), embedding: vec![0.0;1024], layer: Layer::Interact, kind: "note".into(), tags: vec![], project: "p".into(), session: "s".into(), ts: chrono::Utc::now(), score: 0.0, access_count: 0, last_access: chrono::Utc::now() };
    (B[m[32m+    let rec1 = Record {
    (B[m[32m+        id: uuid::Uuid::new_v4(),
    (B[m[32m+        text: "rust ownership borrowing lifetimes".to_string(),
    (B[m[32m+        embedding: vec![0.0; 1024],
    (B[m[32m+        layer: Layer::Interact,
    (B[m[32m+        kind: "note".into(),
    (B[m[32m+        tags: vec![],
    (B[m[32m+        project: "p".into(),
    (B[m[32m+        session: "s".into(),
    (B[m[32m+        ts: chrono::Utc::now(),
    (B[m[32m+        score: 0.0,
    (B[m[32m+        access_count: 0,
    (B[m[32m+        last_access: chrono::Utc::now(),
    (B[m[32m+    };
    (B[m[32m+    let rec2 = Record {
    (B[m[32m+        id: uuid::Uuid::new_v4(),
    (B[m[32m+        text: "python asyncio event loop".to_string(),
    (B[m[32m+        embedding: vec![0.0; 1024],
    (B[m[32m+        layer: Layer::Interact,
    (B[m[32m+        kind: "note".into(),
    (B[m[32m+        tags: vec![],
    (B[m[32m+        project: "p".into(),
    (B[m[32m+        session: "s".into(),
    (B[m[32m+        ts: chrono::Utc::now(),
    (B[m[32m+        score: 0.0,
    (B[m[32m+        access_count: 0,
    (B[m[32m+        last_access: chrono::Utc::now(),
    (B[m[32m+    };
    (B[m     store.insert(&rec1).await.unwrap();
         store.insert(&rec2).await.unwrap();
     
    Diff in /workspace/crates/memory/tests/test_hybrid_search.rs:22:
         // Resolve embedding coordinator dependency indirectly via SearchCoordinator::new_production requires real EmbeddingCoordinator
         // For test simplicity use SearchCoordinator::new with no production init
         // We need a dummy EmbeddingCoordinator; UnifiedContainer resolves it in orchestrated profile
    [31m-    let embedding = container.resolve::<memory::orchestration::EmbeddingCoordinator>().unwrap();
    (B[m[32m+    let embedding = container
    (B[m[32m+        .resolve::<memory::orchestration::EmbeddingCoordinator>()
    (B[m[32m+        .unwrap();
    (B[m 
         let coord = SearchCoordinator::new_production(store.clone(), embedding, 8, 128);
         coord.initialize().await.unwrap();
    Diff in /workspace/crates/memory/tests/test_hybrid_search.rs:29:
     
    [31m-    let opts = SearchOptions { top_k: 2, ..Default::default() };
    (B[m[31m-    let out = SearchCoordinatorTrait::hybrid_search(&coord, "rust lifetimes", None, Layer::Interact, opts).await.unwrap();
    (B[m[32m+    let opts = SearchOptions {
    (B[m[32m+        top_k: 2,
    (B[m[32m+        ..Default::default()
    (B[m[32m+    };
    (B[m[32m+    let out = SearchCoordinatorTrait::hybrid_search(
    (B[m[32m+        &coord,
    (B[m[32m+        "rust lifetimes",
    (B[m[32m+        None,
    (B[m[32m+        Layer::Interact,
    (B[m[32m+        opts,
    (B[m[32m+    )
    (B[m[32m+    .await
    (B[m[32m+    .unwrap();
    (B[m     let texts: Vec<String> = out.iter().map(|r| r.text.clone()).collect();
    [31m-    assert!(texts.iter().any(|t| t.contains("rust ownership borrowing lifetimes")), "{:?}", texts);
    (B[m[32m+    assert!(
    (B[m[32m+        texts
    (B[m[32m+            .iter()
    (B[m[32m+            .any(|t| t.contains("rust ownership borrowing lifetimes")),
    (B[m[32m+        "{:?}",
    (B[m[32m+        texts
    (B[m[32m+    );
    (B[m }
    [32m+
    (B[mDiff in /workspace/crates/memory/tests/test_memory_events.rs:2:
     
     use anyhow::Result;
     use common::{events, topics};
    [31m-use memory::Layer;
    (B[m[31m-use memory::di::UnifiedContainer;
    (B[m use memory::api::MemoryServiceTrait;
    [32m+use memory::di::UnifiedContainer;
    (B[m[32m+use memory::Layer;
    (B[m 
     #[tokio::test]
     async fn emits_json_events_on_remember_and_search() -> Result<()> {
    Diff in /workspace/crates/memory/tests/test_memory_events.rs:27:
         let id = svc.remember_sync(text.clone(), layer)?;
     
         // wait upsert event
    [31m-    if let Ok(Ok(up_evt)) = tokio::time::timeout(std::time::Duration::from_millis(1500), rx_up.recv()).await {
    (B[m[32m+    if let Ok(Ok(up_evt)) =
    (B[m[32m+        tokio::time::timeout(std::time::Duration::from_millis(1500), rx_up.recv()).await
    (B[m[32m+    {
    (B[m         assert_eq!(up_evt.topic.0, topics::TOPIC_MEMORY_UPSERT.0);
    [31m-        assert_eq!(up_evt.payload["layer"].as_str().unwrap_or_default(), format!("{:?}", layer));
    (B[m[31m-        assert_eq!(up_evt.payload["id"].as_str().unwrap_or_default(), id.to_string());
    (B[m[32m+        assert_eq!(
    (B[m[32m+            up_evt.payload["layer"].as_str().unwrap_or_default(),
    (B[m[32m+            format!("{:?}", layer)
    (B[m[32m+        );
    (B[m[32m+        assert_eq!(
    (B[m[32m+            up_evt.payload["id"].as_str().unwrap_or_default(),
    (B[m[32m+            id.to_string()
    (B[m[32m+        );
    (B[m     }
     
         // perform search; expect a search event best-effort
    Diff in /workspace/crates/memory/tests/test_memory_events.rs:37:
         let _ = svc.search_sync("event payload", layer, 3)?;
    [31m-    if let Ok(Ok(srch_evt)) = tokio::time::timeout(std::time::Duration::from_millis(1500), rx_search.recv()).await {
    (B[m[32m+    if let Ok(Ok(srch_evt)) =
    (B[m[32m+        tokio::time::timeout(std::time::Duration::from_millis(1500), rx_search.recv()).await
    (B[m[32m+    {
    (B[m         assert_eq!(srch_evt.topic.0, topics::TOPIC_MEMORY_SEARCH.0);
    [31m-        assert_eq!(srch_evt.payload["layer"].as_str().unwrap_or_default(), format!("{:?}", layer));
    (B[m[32m+        assert_eq!(
    (B[m[32m+            srch_evt.payload["layer"].as_str().unwrap_or_default(),
    (B[m[32m+            format!("{:?}", layer)
    (B[m[32m+        );
    (B[m     }
         Ok(())
     }
    Diff in /workspace/crates/memory/tests/test_memory_events.rs:49:
         std::env::set_var("MAGRAY_SKIP_AUTO_INSTALL", "1");
     
         let svc = UnifiedContainer::new();
    [31m-    let api = memory::api::UnifiedMemoryAPI::new(std::sync::Arc::new(svc) as std::sync::Arc<dyn memory::api::MemoryServiceTrait>);
    (B[m[32m+    let api = memory::api::UnifiedMemoryAPI::new(
    (B[m[32m+        std::sync::Arc::new(svc) as std::sync::Arc<dyn memory::api::MemoryServiceTrait>
    (B[m[32m+    );
    (B[m 
         // Insert records with controlled token overlap
         let ctx = memory::api::MemoryContext::new("note").with_layer(Layer::Interact);
    Diff in /workspace/crates/memory/tests/test_memory_events.rs:56:
    [31m-    let _ = api.remember("rust tokio async runtimes".to_string(), ctx.clone()).await?;
    (B[m[31m-    let _ = api.remember("python asyncio event loop".to_string(), ctx.clone()).await?;
    (B[m[31m-    let _ = api.remember("rust ownership borrowing lifetimes".to_string(), ctx.clone()).await?;
    (B[m[32m+    let _ = api
    (B[m[32m+        .remember("rust tokio async runtimes".to_string(), ctx.clone())
    (B[m[32m+        .await?;
    (B[m[32m+    let _ = api
    (B[m[32m+        .remember("python asyncio event loop".to_string(), ctx.clone())
    (B[m[32m+        .await?;
    (B[m[32m+    let _ = api
    (B[m[32m+        .remember(
    (B[m[32m+            "rust ownership borrowing lifetimes".to_string(),
    (B[m[32m+            ctx.clone(),
    (B[m[32m+        )
    (B[m[32m+        .await?;
    (B[m 
         // Query closer to third record by tokens
    [31m-    let results = api.recall("rust lifetimes borrowing", memory::api::SearchOptions::default().in_layers(vec![Layer::Interact]).limit(3)).await?;
    (B[m[32m+    let results = api
    (B[m[32m+        .recall(
    (B[m[32m+            "rust lifetimes borrowing",
    (B[m[32m+            memory::api::SearchOptions::default()
    (B[m[32m+                .in_layers(vec![Layer::Interact])
    (B[m[32m+                .limit(3),
    (B[m[32m+        )
    (B[m[32m+        .await?;
    (B[m 
         assert!(!results.is_empty());
         // Expect a result containing rust/borrowing/lifetimes ranked highly
    Diff in /workspace/crates/memory/tests/test_memory_events.rs:68:
         assert!(top.contains("lifetimes") || top.contains("borrowing") || top.contains("rust"));
         Ok(())
     }
    [32m+
    (B[mDiff in /workspace/crates/memory/tests/test_promotion.rs:1:
    [31m-#![cfg(all(feature = "extended-tests", feature = "persistence", feature = "legacy-tests"))]
    (B[m[32m+#![cfg(all(
    (B[m[32m+    feature = "extended-tests",
    (B[m[32m+    feature = "persistence",
    (B[m[32m+    feature = "legacy-tests"
    (B[m[32m+))]
    (B[m 
     use anyhow::Result;
     use chrono::{Duration, Utc};
    Diff in /workspace/crates/todo/src/service_v2.rs:5:
     use dashmap::DashMap;
     use lru::LruCache;
     use parking_lot::Mutex;
    [32m+use std::collections::HashMap;
    (B[m use std::num::NonZeroUsize;
     use std::path::Path;
     use std::sync::Arc;
    Diff in /workspace/crates/todo/src/service_v2.rs:11:
    [31m-use std::collections::HashMap;
    (B[m use tokio::sync::mpsc;
     use tracing::{debug, info, instrument};
     use uuid::Uuid;
    Diff in /workspace/crates/todo/src/service_v2.rs:374:
         }
     
         /// Обновить/добавить ключи в metadata задачи
    [31m-    pub async fn upsert_metadata(&self, id: &Uuid, meta: HashMap<String, serde_json::Value>) -> Result<()> {
    (B[m[32m+    pub async fn upsert_metadata(
    (B[m[32m+        &self,
    (B[m[32m+        id: &Uuid,
    (B[m[32m+        meta: HashMap<String, serde_json::Value>,
    (B[m[32m+    ) -> Result<()> {
    (B[m         self.store.update_metadata(id, meta).await
         }
     
    Diff in /workspace/crates/todo/src/service_v2.rs:381:
         /// Добавить элемент в массив metadata задачи по ключу
    [31m-    pub async fn push_metadata_item(&self, id: &Uuid, key: &str, element: serde_json::Value) -> Result<()> {
    (B[m[32m+    pub async fn push_metadata_item(
    (B[m[32m+        &self,
    (B[m[32m+        id: &Uuid,
    (B[m[32m+        key: &str,
    (B[m[32m+        element: serde_json::Value,
    (B[m[32m+    ) -> Result<()> {
    (B[m         self.store.append_metadata_array(id, key, element).await
         }
     }
    Diff in /workspace/crates/todo/src/store_v2.rs:1:
    [32m+use crate::types::Layer;
    (B[m use crate::types::*;
     use anyhow::{Context, Result};
     use chrono::{DateTime, Utc};
    Diff in /workspace/crates/todo/src/store_v2.rs:4:
    [31m-use crate::types::Layer;
    (B[m use r2d2::Pool;
     use r2d2_sqlite::SqliteConnectionManager;
     use rusqlite::{params, Connection, OptionalExtension, Row};
    Diff in /workspace/crates/todo/src/store_v2.rs:638:
         }
     
         /// Обновить metadata задачи (мердж по ключам)
    [31m-    pub async fn update_metadata(&self, id: &Uuid, new_meta: HashMap<String, serde_json::Value>) -> Result<()> {
    (B[m[32m+    pub async fn update_metadata(
    (B[m[32m+        &self,
    (B[m[32m+        id: &Uuid,
    (B[m[32m+        new_meta: HashMap<String, serde_json::Value>,
    (B[m[32m+    ) -> Result<()> {
    (B[m         let mut conn = self.pool.get()?;
             let tx = conn.transaction()?;
     
    Diff in /workspace/crates/todo/src/store_v2.rs:645:
             // Получаем текущий metadata
             let current_json: Option<String> = tx
    [31m-            .query_row("SELECT metadata FROM todos WHERE id = ?1", params![id.to_string()], |row| row.get(0))
    (B[m[32m+            .query_row(
    (B[m[32m+                "SELECT metadata FROM todos WHERE id = ?1",
    (B[m[32m+                params![id.to_string()],
    (B[m[32m+                |row| row.get(0),
    (B[m[32m+            )
    (B[m             .optional()?;
     
             let mut meta_obj: serde_json::Map<String, serde_json::Value> = current_json
    Diff in /workspace/crates/todo/src/store_v2.rs:667:
         }
     
         /// Добавить элемент в массив внутри metadata по ключу (создает массив при отсутствии)
    [31m-    pub async fn append_metadata_array(&self, id: &Uuid, key: &str, element: serde_json::Value) -> Result<()> {
    (B[m[32m+    pub async fn append_metadata_array(
    (B[m[32m+        &self,
    (B[m[32m+        id: &Uuid,
    (B[m[32m+        key: &str,
    (B[m[32m+        element: serde_json::Value,
    (B[m[32m+    ) -> Result<()> {
    (B[m         let mut conn = self.pool.get()?;
             let tx = conn.transaction()?;
     
    Diff in /workspace/crates/todo/src/store_v2.rs:674:
             let current_json: Option<String> = tx
    [31m-            .query_row("SELECT metadata FROM todos WHERE id = ?1", params![id.to_string()], |row| row.get(0))
    (B[m[32m+            .query_row(
    (B[m[32m+                "SELECT metadata FROM todos WHERE id = ?1",
    (B[m[32m+                params![id.to_string()],
    (B[m[32m+                |row| row.get(0),
    (B[m[32m+            )
    (B[m             .optional()?;
     
             let mut root: serde_json::Value = current_json
    Diff in /workspace/crates/todo/src/store_v2.rs:684:
             }
     
             let obj = root.as_object_mut().unwrap();
    [31m-        let arr = obj.entry(key.to_string()).or_insert_with(|| serde_json::json!([]));
    (B[m[32m+        let arr = obj
    (B[m[32m+            .entry(key.to_string())
    (B[m[32m+            .or_insert_with(|| serde_json::json!([]));
    (B[m         if !arr.is_array() {
                 *arr = serde_json::json!([]);
             }
    Diff in /workspace/crates/todo/tests/test_graph.rs:4:
     use uuid::Uuid;
     
     fn create_test_task(title: &str) -> TodoItem {
    [31m-    TodoItem { title: title.to_string(), ..TodoItem::default() }
    (B[m[32m+    TodoItem {
    (B[m[32m+        title: title.to_string(),
    (B[m[32m+        ..TodoItem::default()
    (B[m[32m+    }
    (B[m }
     
     #[test]
    Error writing files: failed to resolve mod `execution_pipeline`: /workspace/crates/tools/src/execution_pipeline.rs does not exist
    Diff in /workspace/crates/tools/tests/test_file_ops.rs:161:
     #[tokio::test]
     async fn test_file_write_emits_fs_diff() -> anyhow::Result<()> {
         use common::{events, topics};
    [32m+    use std::collections::HashMap;
    (B[m[32m+    use tempfile::TempDir;
    (B[m     use tools::file_ops::FileWriter;
         use tools::{Tool, ToolInput};
    [31m-    use tempfile::TempDir;
    (B[m[31m-    use std::collections::HashMap;
    (B[m 
         let tmp = TempDir::new().unwrap();
         let file_path = tmp.path().join("evt.txt");
    Diff in /workspace/crates/tools/tests/test_file_ops.rs:176:
         let mut args = HashMap::new();
         args.insert("path".into(), file_path.to_string_lossy().to_string());
         args.insert("content".into(), "hello".into());
    [31m-    let input = ToolInput { command: "file_write".into(), args, context: None, dry_run: false, timeout_ms: None };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "file_write".into(),
    (B[m[32m+        args,
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m 
         let out = writer.execute(input).await?;
         assert!(out.success);
    Diff in /workspace/crates/tools/tests/test_git_ops.rs:33:
     #[tokio::test]
     async fn test_git_status_execute() -> Result<()> {
         let git_status = GitStatus::new();
    [31m-        let input = ToolInput {
    (B[m[32m+    let input = ToolInput {
    (B[m         command: "git_status".to_string(),
             args: HashMap::new(),
             context: None,
    Diff in /workspace/crates/tools/tests/test_git_ops.rs:40:
             dry_run: false,
             timeout_ms: None,
         };
    [31m- 
    (B[m[32m+
    (B[m     // Execute git status (may fail if not in git repo, but shouldn't panic)
         let result = git_status.execute(input).await;
         assert!(result.is_ok());
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:1:
     #![cfg(feature = "extended-tests")]
     
     use anyhow::Result;
    [31m-use tempfile::TempDir;
    (B[m[32m+use common::{events, topics};
    (B[m use std::collections::HashMap;
     use std::fs;
     use std::process::Command;
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:8:
    [32m+use tempfile::TempDir;
    (B[m use tools::git_ops::{GitCommit, GitDiff, GitStatus};
     use tools::{Tool, ToolInput};
    [31m-use common::{events, topics};
    (B[m 
     #[tokio::test]
     async fn git_status_works_with_cwd_in_temp_repo() -> Result<()> {
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:14:
         let tmp = TempDir::new().unwrap();
         let repo = tmp.path();
    [31m-    assert!(Command::new("git").arg("init").current_dir(repo).status()?.success());
    (B[m[32m+    assert!(Command::new("git")
    (B[m[32m+        .arg("init")
    (B[m[32m+        .current_dir(repo)
    (B[m[32m+        .status()?
    (B[m[32m+        .success());
    (B[m     // create a file
         fs::write(repo.join("a.txt"), "hello")?;
     
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:34:
     async fn git_commit_and_diff_publish_events() -> Result<()> {
         let tmp = TempDir::new().unwrap();
         let repo = tmp.path();
    [31m-    assert!(Command::new("git").arg("init").current_dir(repo).status()?.success());
    (B[m[31m-    assert!(Command::new("git").args(["config","user.email","test@example.com"]).current_dir(repo).status()?.success());
    (B[m[31m-    assert!(Command::new("git").args(["config","user.name","Test"]).current_dir(repo).status()?.success());
    (B[m[32m+    assert!(Command::new("git")
    (B[m[32m+        .arg("init")
    (B[m[32m+        .current_dir(repo)
    (B[m[32m+        .status()?
    (B[m[32m+        .success());
    (B[m[32m+    assert!(Command::new("git")
    (B[m[32m+        .args(["config", "user.email", "test@example.com"])
    (B[m[32m+        .current_dir(repo)
    (B[m[32m+        .status()?
    (B[m[32m+        .success());
    (B[m[32m+    assert!(Command::new("git")
    (B[m[32m+        .args(["config", "user.name", "Test"])
    (B[m[32m+        .current_dir(repo)
    (B[m[32m+        .status()?
    (B[m[32m+        .success());
    (B[m 
         // subscribe before actions
         let mut rx = events::subscribe(topics::TOPIC_FS_DIFF).await;
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:58:
         let _ = commit.execute(input).await?; // allow "Нет изменений" as well in edge timing
     
         let diff = GitDiff::new();
    [31m-    let dinput = ToolInput { command: "git_diff".into(), args: HashMap::from([("cwd".into(), repo.to_string_lossy().to_string())]), context: None, dry_run: false, timeout_ms: None };
    (B[m[32m+    let dinput = ToolInput {
    (B[m[32m+        command: "git_diff".into(),
    (B[m[32m+        args: HashMap::from([("cwd".into(), repo.to_string_lossy().to_string())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let _ = diff.execute(dinput).await?;
     
         // collect a couple of fs.diff ops best-effort
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:69:
         while Instant::now() < deadline {
             if let Ok(Ok(evt)) = tokio::time::timeout(Duration::from_millis(150), rx.recv()).await {
                 if let Some(op) = evt.payload.get("op").and_then(|v| v.as_str()) {
    [31m-                if op == "commit" { saw_commit = true; }
    (B[m[31m-                if op == "diff" { saw_diff = true; }
    (B[m[32m+                if op == "commit" {
    (B[m[32m+                    saw_commit = true;
    (B[m[32m+                }
    (B[m[32m+                if op == "diff" {
    (B[m[32m+                    saw_diff = true;
    (B[m[32m+                }
    (B[m             }
    [31m-            if saw_commit && saw_diff { break; }
    (B[m[32m+            if saw_commit && saw_diff {
    (B[m[32m+                break;
    (B[m[32m+            }
    (B[m         }
         }
         // Best-effort: at least one of them should appear depending on environment
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:79:
    [31m-    assert!(saw_commit || saw_diff, "expected at least one fs.diff op from commit/diff");
    (B[m[32m+    assert!(
    (B[m[32m+        saw_commit || saw_diff,
    (B[m[32m+        "expected at least one fs.diff op from commit/diff"
    (B[m[32m+    );
    (B[m     Ok(())
     }
     
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:85:
         use tools::file_ops::FileDeleter;
         let del = FileDeleter::new();
         let args = HashMap::from([("path".into(), "/tmp/whatever".into())]);
    [31m-    let input = ToolInput { command: "file_delete".into(), args, context: None, dry_run: true, timeout_ms: None };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "file_delete".into(),
    (B[m[32m+        args,
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: true,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let out = del.execute(input).await?;
         assert!(out.success);
    [31m-    assert_eq!(out.metadata.get("dry_run").map(String::as_str), Some("true"));
    (B[m[32m+    assert_eq!(
    (B[m[32m+        out.metadata.get("dry_run").map(String::as_str),
    (B[m[32m+        Some("true")
    (B[m[32m+    );
    (B[m     assert!(out.result.contains("[dry-run] rm"));
         Ok(())
     }
    Diff in /workspace/crates/tools/tests/test_git_ops_integration.rs:95:
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_intelligent_selector.rs:1:
     use std::collections::HashMap;
    [32m+use tools::intelligent_selector::{
    (B[m[32m+    IntelligentToolSelector, SelectorConfig, TaskComplexity, ToolSelectionContext, UrgencyLevel,
    (B[m[32m+    UserExpertise,
    (B[m[32m+};
    (B[m use tools::{ToolSpec, UsageGuide};
    [31m-use tools::intelligent_selector::{IntelligentToolSelector, SelectorConfig, ToolSelectionContext, TaskComplexity, UrgencyLevel, UserExpertise};
    (B[m 
    [31m-fn mk_guide(tags: Vec<&str>, caps: Vec<&str>, good_for: Vec<&str>, latency: &str, risk: u8) -> UsageGuide {
    (B[m[32m+fn mk_guide(
    (B[m[32m+    tags: Vec<&str>,
    (B[m[32m+    caps: Vec<&str>,
    (B[m[32m+    good_for: Vec<&str>,
    (B[m[32m+    latency: &str,
    (B[m[32m+    risk: u8,
    (B[m[32m+) -> UsageGuide {
    (B[m     UsageGuide {
             usage_title: "t".into(),
             usage_summary: "s".into(),
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:59:
         let a = mk_spec(
             "alpha",
             "Downloader tool",
    [31m-        Some(mk_guide(vec!["download", "http"], vec!["fetch"], vec!["web"], "fast", 1)),
    (B[m[32m+        Some(mk_guide(
    (B[m[32m+            vec!["download", "http"],
    (B[m[32m+            vec!["fetch"],
    (B[m[32m+            vec!["web"],
    (B[m[32m+            "fast",
    (B[m[32m+            1,
    (B[m[32m+        )),
    (B[m     );
         let b = mk_spec("beta", "Generic tool", None);
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:66:
         selector.register_tool(a.clone()).await;
         selector.register_tool(b.clone()).await;
     
    [31m-    let choices = selector.select_tools(&ctx("скачай страницу", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("скачай страницу", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     assert!(!choices.is_empty());
         // alpha should rank higher than beta
         let pos_alpha = choices.iter().position(|c| c.tool_name == "alpha").unwrap();
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:73:
         let pos_beta = choices.iter().position(|c| c.tool_name == "beta").unwrap();
    [31m-    assert!(pos_alpha < pos_beta, "alpha should outrank beta due to tags/caps match");
    (B[m[32m+    assert!(
    (B[m[32m+        pos_alpha < pos_beta,
    (B[m[32m+        "alpha should outrank beta due to tags/caps match"
    (B[m[32m+    );
    (B[m }
     
     #[tokio::test]
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:78:
     async fn selector_accounts_for_latency_with_high_urgency() {
         let selector = IntelligentToolSelector::new(low_threshold_config());
     
    [31m-    let fast = mk_spec("fast", "Fast tool", Some(mk_guide(vec![], vec![], vec![], "fast", 3)));
    (B[m[31m-    let slow = mk_spec("slow", "Slow tool", Some(mk_guide(vec![], vec![], vec![], "slow", 3)));
    (B[m[32m+    let fast = mk_spec(
    (B[m[32m+        "fast",
    (B[m[32m+        "Fast tool",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 3)),
    (B[m[32m+    );
    (B[m[32m+    let slow = mk_spec(
    (B[m[32m+        "slow",
    (B[m[32m+        "Slow tool",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "slow", 3)),
    (B[m[32m+    );
    (B[m 
         selector.register_tool(fast.clone()).await;
         selector.register_tool(slow.clone()).await;
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:86:
     
    [31m-    let choices = selector.select_tools(&ctx("latency test", UrgencyLevel::High)).await.unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("latency test", UrgencyLevel::High))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     let pos_fast = choices.iter().position(|c| c.tool_name == "fast").unwrap();
         let pos_slow = choices.iter().position(|c| c.tool_name == "slow").unwrap();
    [31m-    assert!(pos_fast < pos_slow, "fast latency should be preferred under high urgency");
    (B[m[32m+    assert!(
    (B[m[32m+        pos_fast < pos_slow,
    (B[m[32m+        "fast latency should be preferred under high urgency"
    (B[m[32m+    );
    (B[m }
     
     #[tokio::test]
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:94:
     async fn selector_prefers_lower_risk() {
         let selector = IntelligentToolSelector::new(low_threshold_config());
     
    [31m-    let low = mk_spec("lowrisk", "Low risk", Some(mk_guide(vec![], vec![], vec![], "fast", 1)));
    (B[m[31m-    let high = mk_spec("highrisk", "High risk", Some(mk_guide(vec![], vec![], vec![], "fast", 5)));
    (B[m[32m+    let low = mk_spec(
    (B[m[32m+        "lowrisk",
    (B[m[32m+        "Low risk",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 1)),
    (B[m[32m+    );
    (B[m[32m+    let high = mk_spec(
    (B[m[32m+        "highrisk",
    (B[m[32m+        "High risk",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 5)),
    (B[m[32m+    );
    (B[m 
         selector.register_tool(low.clone()).await;
         selector.register_tool(high.clone()).await;
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:102:
     
    [31m-    let choices = selector.select_tools(&ctx("do something", UrgencyLevel::Normal)).await.unwrap();
    (B[m[31m-    let pos_low = choices.iter().position(|c| c.tool_name == "lowrisk").unwrap();
    (B[m[31m-    let pos_high = choices.iter().position(|c| c.tool_name == "highrisk").unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("do something", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m[32m+    let pos_low = choices
    (B[m[32m+        .iter()
    (B[m[32m+        .position(|c| c.tool_name == "lowrisk")
    (B[m[32m+        .unwrap();
    (B[m[32m+    let pos_high = choices
    (B[m[32m+        .iter()
    (B[m[32m+        .position(|c| c.tool_name == "highrisk")
    (B[m[32m+        .unwrap();
    (B[m     assert!(pos_low < pos_high, "low risk should have slight bonus");
     }
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:110:
     async fn selector_is_deterministic_for_same_input() {
         let selector = IntelligentToolSelector::new(SelectorConfig::default());
     
    [31m-    let t1 = mk_spec("t1", "Tool one", Some(mk_guide(vec!["tag1"], vec!["cap1"], vec!["general"], "fast", 1)));
    (B[m[31m-    let t2 = mk_spec("t2", "Tool two", Some(mk_guide(vec!["tag2"], vec!["cap2"], vec!["general"], "slow", 3)));
    (B[m[32m+    let t1 = mk_spec(
    (B[m[32m+        "t1",
    (B[m[32m+        "Tool one",
    (B[m[32m+        Some(mk_guide(
    (B[m[32m+            vec!["tag1"],
    (B[m[32m+            vec!["cap1"],
    (B[m[32m+            vec!["general"],
    (B[m[32m+            "fast",
    (B[m[32m+            1,
    (B[m[32m+        )),
    (B[m[32m+    );
    (B[m[32m+    let t2 = mk_spec(
    (B[m[32m+        "t2",
    (B[m[32m+        "Tool two",
    (B[m[32m+        Some(mk_guide(
    (B[m[32m+            vec!["tag2"],
    (B[m[32m+            vec!["cap2"],
    (B[m[32m+            vec!["general"],
    (B[m[32m+            "slow",
    (B[m[32m+            3,
    (B[m[32m+        )),
    (B[m[32m+    );
    (B[m     selector.register_tool(t1.clone()).await;
         selector.register_tool(t2.clone()).await;
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:118:
    [31m-    let c1 = selector.select_tools(&ctx("some query with tag1", UrgencyLevel::Normal)).await.unwrap();
    (B[m[31m-    let c2 = selector.select_tools(&ctx("some query with tag1", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let c1 = selector
    (B[m[32m+        .select_tools(&ctx("some query with tag1", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m[32m+    let c2 = selector
    (B[m[32m+        .select_tools(&ctx("some query with tag1", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     assert_eq!(c1.len(), c2.len());
         // Compare order of tool names
         let names1: Vec<_> = c1.iter().map(|x| x.tool_name.clone()).collect();
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:123:
         let names2: Vec<_> = c2.iter().map(|x| x.tool_name.clone()).collect();
    [31m-    assert_eq!(names1, names2, "selection should be deterministic for same input");
    (B[m[32m+    assert_eq!(
    (B[m[32m+        names1, names2,
    (B[m[32m+        "selection should be deterministic for same input"
    (B[m[32m+    );
    (B[m }
     
     #[tokio::test]
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:136:
             examples: vec![],
             input_schema: "{}".into(),
             usage_guide: None,
    [31m-        permissions: Some(tools::ToolPermissions { allow_shell: true, ..Default::default() }),
    (B[m[32m+        permissions: Some(tools::ToolPermissions {
    (B[m[32m+            allow_shell: true,
    (B[m[32m+            ..Default::default()
    (B[m[32m+        }),
    (B[m         supports_dry_run: true,
         };
         let other = mk_spec("other", "Generic", None);
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:143:
         selector.register_tool(shell).await;
         selector.register_tool(other.clone()).await;
    [31m-    let choices = selector.select_tools(&ctx("run command", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("run command", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     // shell_exec must not appear
         assert!(choices.iter().all(|c| c.tool_name != "shell_exec"));
     }
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:158:
             examples: vec![],
             input_schema: "{}".into(),
             usage_guide: None,
    [31m-        permissions: Some(tools::ToolPermissions { net_allowlist: vec!["example.com".into()], ..Default::default() }),
    (B[m[32m+        permissions: Some(tools::ToolPermissions {
    (B[m[32m+            net_allowlist: vec!["example.com".into()],
    (B[m[32m+            ..Default::default()
    (B[m[32m+        }),
    (B[m         supports_dry_run: true,
         };
         let other = mk_spec("other", "Generic", None);
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:165:
         selector.register_tool(web).await;
         selector.register_tool(other.clone()).await;
    [31m-    let choices = selector.select_tools(&ctx("скачай страницу", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("скачай страницу", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     assert!(choices.iter().all(|c| c.tool_name != "web_fetch"));
     }
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:180:
             examples: vec![],
             input_schema: "{}".into(),
             usage_guide: None,
    [31m-        permissions: Some(tools::ToolPermissions { fs_write_roots: vec!["/other".into()], ..Default::default() }),
    (B[m[32m+        permissions: Some(tools::ToolPermissions {
    (B[m[32m+            fs_write_roots: vec!["/other".into()],
    (B[m[32m+            ..Default::default()
    (B[m[32m+        }),
    (B[m         supports_dry_run: true,
         };
         let ok = mk_spec("file_read", "Reader", None);
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:187:
         selector.register_tool(needs_fs).await;
         selector.register_tool(ok.clone()).await;
    [31m-    let choices = selector.select_tools(&ctx("write file", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("write file", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     assert!(choices.iter().all(|c| c.tool_name != "file_write"));
     }
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:198:
         let selector = IntelligentToolSelector::new(low_threshold_config());
     
         // Tool A: needs shell + write FS (riskier), no dry-run
    [31m-    let mut a = mk_spec("risky", "Risky tool", Some(mk_guide(vec![], vec![], vec![], "fast", 1)));
    (B[m[32m+    let mut a = mk_spec(
    (B[m[32m+        "risky",
    (B[m[32m+        "Risky tool",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 1)),
    (B[m[32m+    );
    (B[m     a.permissions = Some(tools::ToolPermissions {
             allow_shell: true,
             fs_write_roots: vec!["/".into()],
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:207:
         a.supports_dry_run = false;
     
         // Tool B: no explicit permissions (least-privilege), supports dry-run
    [31m-    let mut b = mk_spec("safe", "Safe tool", Some(mk_guide(vec![], vec![], vec![], "fast", 1)));
    (B[m[32m+    let mut b = mk_spec(
    (B[m[32m+        "safe",
    (B[m[32m+        "Safe tool",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 1)),
    (B[m[32m+    );
    (B[m     b.permissions = None;
         b.supports_dry_run = true;
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:214:
         selector.register_tool(a.clone()).await;
         selector.register_tool(b.clone()).await;
     
    [31m-    let choices = selector.select_tools(&ctx("do something", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let choices = selector
    (B[m[32m+        .select_tools(&ctx("do something", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     let pos_safe = choices.iter().position(|c| c.tool_name == "safe").unwrap();
         let pos_risky = choices.iter().position(|c| c.tool_name == "risky").unwrap();
    [31m-    assert!(pos_safe < pos_risky, "Tools with fewer privileges and dry-run should rank higher");
    (B[m[32m+    assert!(
    (B[m[32m+        pos_safe < pos_risky,
    (B[m[32m+        "Tools with fewer privileges and dry-run should rank higher"
    (B[m[32m+    );
    (B[m }
     
     #[tokio::test]
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:227:
         std::env::set_var("MAGRAY_FS_SANDBOX", "0");
         let selector = IntelligentToolSelector::new(low_threshold_config());
     
    [31m-    let mut risky = mk_spec("risky2", "Risky tool 2", Some(mk_guide(vec![], vec![], vec![], "fast", 1)));
    (B[m[31m-    risky.permissions = Some(tools::ToolPermissions { allow_shell: true, fs_write_roots: vec!["/".into()], ..Default::default() });
    (B[m[32m+    let mut risky = mk_spec(
    (B[m[32m+        "risky2",
    (B[m[32m+        "Risky tool 2",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 1)),
    (B[m[32m+    );
    (B[m[32m+    risky.permissions = Some(tools::ToolPermissions {
    (B[m[32m+        allow_shell: true,
    (B[m[32m+        fs_write_roots: vec!["/".into()],
    (B[m[32m+        ..Default::default()
    (B[m[32m+    });
    (B[m     risky.supports_dry_run = false;
     
    [31m-    let mut safe = mk_spec("safe2", "Safe tool 2", Some(mk_guide(vec![], vec![], vec![], "fast", 1)));
    (B[m[32m+    let mut safe = mk_spec(
    (B[m[32m+        "safe2",
    (B[m[32m+        "Safe tool 2",
    (B[m[32m+        Some(mk_guide(vec![], vec![], vec![], "fast", 1)),
    (B[m[32m+    );
    (B[m     safe.permissions = None;
         safe.supports_dry_run = true;
     
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:238:
         selector.register_tool(risky.clone()).await;
         selector.register_tool(safe.clone()).await;
     
    [31m-    let exps = selector.select_tools_with_explanations(&ctx("do something", UrgencyLevel::Normal)).await.unwrap();
    (B[m[32m+    let exps = selector
    (B[m[32m+        .select_tools_with_explanations(&ctx("do something", UrgencyLevel::Normal))
    (B[m[32m+        .await
    (B[m[32m+        .unwrap();
    (B[m     // Find both explanations
         let er = exps.iter().find(|e| e.tool_name == "risky2").unwrap();
         let es = exps.iter().find(|e| e.tool_name == "safe2").unwrap();
    Diff in /workspace/crates/tools/tests/test_intelligent_selector.rs:248:
         assert!(es.breakdown.permissions_adjust >= 0.0);
         assert!(es.breakdown.dry_run_bonus >= 0.0);
     }
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_registry.rs:169:
             timeout_ms: None,
         };
     
    [31m-
    (B[m     // Сериализация
         let json = serde_json::to_string(&input).unwrap();
         assert!(json.contains("test_cmd"));
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:1:
     #![cfg(feature = "extended-tests")]
     
     use anyhow::Result;
    [31m-use tempfile::TempDir;
    (B[m use std::collections::HashMap;
    [32m+use tempfile::TempDir;
    (B[m use tools::shell_ops::ShellExec;
     use tools::{Tool, ToolInput};
     
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:9:
     #[tokio::test]
     async fn shell_exec_dry_run_preview() -> Result<()> {
         let tool = ShellExec::new();
    [31m-    let input = ToolInput { command: "shell_exec".into(), args: HashMap::from([("command".into(), "echo hello".into())]), context: None, dry_run: true, timeout_ms: None };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "shell_exec".into(),
    (B[m[32m+        args: HashMap::from([("command".into(), "echo hello".into())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: true,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let out = tool.execute(input).await?;
         assert!(out.success);
         assert!(out.formatted_output.unwrap().contains("[dry-run]"));
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:19:
     #[tokio::test]
     async fn shell_exec_timeout_triggers() -> Result<()> {
         let tool = ShellExec::new();
    [31m-    let input = ToolInput { command: "shell_exec".into(), args: HashMap::from([("command".into(), "sleep 2".into())]), context: None, dry_run: false, timeout_ms: Some(200) };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "shell_exec".into(),
    (B[m[32m+        args: HashMap::from([("command".into(), "sleep 2".into())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: Some(200),
    (B[m[32m+    };
    (B[m     let out = tool.execute(input).await?;
         assert!(!out.success);
         assert!(out.result.contains("таймаут"));
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:26:
    [31m-    assert_eq!(out.metadata.get("timeout_ms").map(|s| s.as_str()), Some("200"));
    (B[m[32m+    assert_eq!(
    (B[m[32m+        out.metadata.get("timeout_ms").map(|s| s.as_str()),
    (B[m[32m+        Some("200")
    (B[m[32m+    );
    (B[m     Ok(())
     }
     
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:35:
         let mut args = HashMap::new();
         args.insert("command".into(), cmd);
         args.insert("max_output_kb".into(), "4".into()); // 4KB limit
    [31m-    let out = tool.execute(ToolInput { command: "shell_exec".into(), args, context: None, dry_run: false, timeout_ms: Some(5000) }).await?;
    (B[m[32m+    let out = tool
    (B[m[32m+        .execute(ToolInput {
    (B[m[32m+            command: "shell_exec".into(),
    (B[m[32m+            args,
    (B[m[32m+            context: None,
    (B[m[32m+            dry_run: false,
    (B[m[32m+            timeout_ms: Some(5000),
    (B[m[32m+        })
    (B[m[32m+        .await?;
    (B[m     // success true (exit code 0), but truncated
         assert!(out.success);
    [31m-    assert_eq!(out.metadata.get("stdout_truncated").map(|s| s.as_str()), Some("true"));
    (B[m[32m+    assert_eq!(
    (B[m[32m+        out.metadata.get("stdout_truncated").map(|s| s.as_str()),
    (B[m[32m+        Some("true")
    (B[m[32m+    );
    (B[m     Ok(())
     }
     
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:50:
         let mut args = HashMap::new();
         args.insert("command".into(), "pwd".into());
         args.insert("cwd".into(), cwd.clone());
    [31m-    let out = tool.execute(ToolInput { command: "shell_exec".into(), args, context: None, dry_run: false, timeout_ms: Some(5000) }).await?;
    (B[m[32m+    let out = tool
    (B[m[32m+        .execute(ToolInput {
    (B[m[32m+            command: "shell_exec".into(),
    (B[m[32m+            args,
    (B[m[32m+            context: None,
    (B[m[32m+            dry_run: false,
    (B[m[32m+            timeout_ms: Some(5000),
    (B[m[32m+        })
    (B[m[32m+        .await?;
    (B[m     assert!(out.success);
         // stdout may include trailing newline
         let printed = out.result.trim();
    Diff in /workspace/crates/tools/tests/test_shell_ops_safety.rs:57:
         assert!(printed.ends_with(&cwd));
    [31m-    assert_eq!(out.metadata.get("cwd").map(|s| s.as_str()), Some(cwd.as_str()));
    (B[m[32m+    assert_eq!(
    (B[m[32m+        out.metadata.get("cwd").map(|s| s.as_str()),
    (B[m[32m+        Some(cwd.as_str())
    (B[m[32m+    );
    (B[m     Ok(())
     }
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_timeline_events.rs:1:
     #![cfg(feature = "extended-tests")]
     
     use anyhow::Result;
    [31m-use tempfile::TempDir;
    (B[m[32m+use common::{events, topics};
    (B[m use std::collections::{HashMap, HashSet};
     use std::process::Command;
    [31m-use tools::{Tool, ToolInput};
    (B[m[31m-use tools::file_ops::{FileWriter, FileDeleter};
    (B[m[32m+use tempfile::TempDir;
    (B[m[32m+use tools::file_ops::{FileDeleter, FileWriter};
    (B[m use tools::git_ops::{GitCommit, GitDiff};
    [31m-use common::{events, topics};
    (B[m[32m+use tools::{Tool, ToolInput};
    (B[m 
     #[tokio::test]
     async fn timeline_fs_diff_sequence() -> Result<()> {
    Diff in /workspace/crates/tools/tests/test_timeline_events.rs:16:
         let repo_dir = tmp.path();
     
         // git init
    [31m-    let status = Command::new("git").arg("init").current_dir(repo_dir).status().unwrap();
    (B[m[32m+    let status = Command::new("git")
    (B[m[32m+        .arg("init")
    (B[m[32m+        .current_dir(repo_dir)
    (B[m[32m+        .status()
    (B[m[32m+        .unwrap();
    (B[m     assert!(status.success(), "git init failed");
         // setup user for commit
    [31m-    assert!(Command::new("git").args(["config","user.email","test@example.com"]).current_dir(repo_dir).status().unwrap().success());
    (B[m[31m-    assert!(Command::new("git").args(["config","user.name","Test User"]).current_dir(repo_dir).status().unwrap().success());
    (B[m[32m+    assert!(Command::new("git")
    (B[m[32m+        .args(["config", "user.email", "test@example.com"])
    (B[m[32m+        .current_dir(repo_dir)
    (B[m[32m+        .status()
    (B[m[32m+        .unwrap()
    (B[m[32m+        .success());
    (B[m[32m+    assert!(Command::new("git")
    (B[m[32m+        .args(["config", "user.name", "Test User"])
    (B[m[32m+        .current_dir(repo_dir)
    (B[m[32m+        .status()
    (B[m[32m+        .unwrap()
    (B[m[32m+        .success());
    (B[m 
         // subscribe to fs.diff before actions
         let mut rx = events::subscribe(topics::TOPIC_FS_DIFF).await;
    Diff in /workspace/crates/tools/tests/test_timeline_events.rs:57:
     
         // 3) git diff (will likely be empty, but should publish a diff event)
         let diff = GitDiff::new();
    [31m-    let diff_input = ToolInput { command: "git_diff".into(), args: HashMap::from([("cwd".into(), repo_dir.to_string_lossy().to_string())]), context: None, dry_run: false, timeout_ms: None };
    (B[m[32m+    let diff_input = ToolInput {
    (B[m[32m+        command: "git_diff".into(),
    (B[m[32m+        args: HashMap::from([("cwd".into(), repo_dir.to_string_lossy().to_string())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let _ = diff.execute(diff_input).await?;
     
         // 4) delete file
    Diff in /workspace/crates/tools/tests/test_timeline_events.rs:64:
         let deleter = FileDeleter::new();
    [31m-    let del_input = ToolInput { command: "file_delete".into(), args: HashMap::from([("path".into(), file_path.to_string_lossy().to_string())]), context: None, dry_run: false, timeout_ms: None };
    (B[m[32m+    let del_input = ToolInput {
    (B[m[32m+        command: "file_delete".into(),
    (B[m[32m+        args: HashMap::from([("path".into(), file_path.to_string_lossy().to_string())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let del_out = deleter.execute(del_input).await?;
         assert!(del_out.success);
     
    Diff in /workspace/crates/tools/tests/test_timeline_events.rs:70:
         let mut ops: HashSet<String> = HashSet::new();
         let deadline = std::time::Instant::now() + std::time::Duration::from_millis(1500);
         while std::time::Instant::now() < deadline {
    [31m-        if let Ok(Ok(evt)) = tokio::time::timeout(std::time::Duration::from_millis(200), rx.recv()).await {
    (B[m[32m+        if let Ok(Ok(evt)) =
    (B[m[32m+            tokio::time::timeout(std::time::Duration::from_millis(200), rx.recv()).await
    (B[m[32m+        {
    (B[m             if let Some(op) = evt.payload.get("op").and_then(|v| v.as_str()) {
                     ops.insert(op.to_string());
                 }
    Diff in /workspace/crates/tools/tests/test_timeline_events.rs:77:
    [31m-            if ops.contains("write") && ops.contains("commit") && ops.contains("diff") && ops.contains("delete") {
    (B[m[32m+            if ops.contains("write")
    (B[m[32m+                && ops.contains("commit")
    (B[m[32m+                && ops.contains("diff")
    (B[m[32m+                && ops.contains("delete")
    (B[m[32m+            {
    (B[m                 break;
                 }
             }
    Diff in /workspace/crates/tools/tests/test_timeline_events.rs:86:
     
         Ok(())
     }
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_web_ops.rs:87:
         let mut args = HashMap::new();
         args.insert("query".to_string(), "test".to_string());
     
    [31m-        let input = ToolInput {
    (B[m[32m+    let input = ToolInput {
    (B[m         command: "web_search".to_string(),
             args,
             context: None,
    Diff in /workspace/crates/tools/tests/test_web_ops.rs:94:
             dry_run: false,
             timeout_ms: None,
         };
    [31m- 
    (B[m[32m+
    (B[m     // This test may fail due to network issues, but shouldn't panic
         let result = web_search.execute(input).await;
         assert!(result.is_ok());
    Diff in /workspace/crates/tools/tests/test_web_ops.rs:138:
         let mut args = HashMap::new();
         args.insert("query".to_string(), "special chars: & + % #".to_string());
     
    [31m-        let input = ToolInput {
    (B[m[32m+    let input = ToolInput {
    (B[m         command: "web_search".to_string(),
             args,
             context: None,
    Diff in /workspace/crates/tools/tests/test_web_ops.rs:145:
             dry_run: false,
             timeout_ms: None,
         };
    [31m- 
    (B[m[32m+
    (B[m     // Should handle URL encoding without panicking
         let result = web_search.execute(input).await;
         assert!(result.is_ok());
    Diff in /workspace/crates/tools/tests/test_web_ops_core.rs:1:
     #![cfg(feature = "extended-tests")]
     
     use anyhow::Result;
    [31m-use tempfile::TempDir;
    (B[m[32m+use std::collections::HashMap;
    (B[m use std::fs;
    [32m+use tempfile::TempDir;
    (B[m use tools::web_ops::{WebFetch, WebSearch};
     use tools::{Tool, ToolInput};
    [31m-use std::collections::HashMap;
    (B[m 
     #[tokio::test]
     async fn web_fetch_file_scheme_reads_content() -> Result<()> {
    Diff in /workspace/crates/tools/tests/test_web_ops_core.rs:15:
         let url = format!("file://{}", file_path.display());
     
         let fetch = WebFetch::new();
    [31m-    let input = ToolInput { command: "web_fetch".into(), args: HashMap::from([("url".into(), url)]), context: None, dry_run: false, timeout_ms: Some(5_000) };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "web_fetch".into(),
    (B[m[32m+        args: HashMap::from([("url".into(), url)]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: Some(5_000),
    (B[m[32m+    };
    (B[m     let out = fetch.execute(input).await?;
         assert!(out.success);
    [31m-    assert!(out.formatted_output.as_ref().unwrap().contains("hello world"));
    (B[m[32m+    assert!(out
    (B[m[32m+        .formatted_output
    (B[m[32m+        .as_ref()
    (B[m[32m+        .unwrap()
    (B[m[32m+        .contains("hello world"));
    (B[m     assert_eq!(out.metadata.get("source").map(|s| s.as_str()), Some("file"));
         Ok(())
     }
    Diff in /workspace/crates/tools/tests/test_web_ops_core.rs:28:
         // data:text/plain;base64,aGVsbG8=
         let url = "data:text/plain;base64,aGVsbG8=".to_string();
         let fetch = WebFetch::new();
    [31m-    let input = ToolInput { command: "web_fetch".into(), args: HashMap::from([("url".into(), url)]), context: None, dry_run: false, timeout_ms: Some(5_000) };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "web_fetch".into(),
    (B[m[32m+        args: HashMap::from([("url".into(), url)]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: false,
    (B[m[32m+        timeout_ms: Some(5_000),
    (B[m[32m+    };
    (B[m     let out = fetch.execute(input).await?;
         assert!(out.success);
         assert!(out.formatted_output.as_ref().unwrap().contains("hello"));
    Diff in /workspace/crates/tools/tests/test_web_ops_core.rs:41:
         // Default provider is mock
         std::env::remove_var("MAGRAY_SEARCH_PROVIDER");
         let search = WebSearch::new();
    [31m-    let input = ToolInput { command: "web_search".into(), args: HashMap::from([("query".into(), "rust".into())]), context: None, dry_run: true, timeout_ms: None };
    (B[m[32m+    let input = ToolInput {
    (B[m[32m+        command: "web_search".into(),
    (B[m[32m+        args: HashMap::from([("query".into(), "rust".into())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: true,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let out = search.execute(input).await?;
         assert!(out.success);
    [31m-    assert_eq!(out.metadata.get("dry_run").map(|s| s.as_str()), Some("true"));
    (B[m[32m+    assert_eq!(
    (B[m[32m+        out.metadata.get("dry_run").map(|s| s.as_str()),
    (B[m[32m+        Some("true")
    (B[m[32m+    );
    (B[m     assert!(out.metadata.get("provider").is_some());
     
         // Switch provider via env (still dry-run, no network)
    Diff in /workspace/crates/tools/tests/test_web_ops_core.rs:51:
         std::env::set_var("MAGRAY_SEARCH_PROVIDER", "duckduckgo");
    [31m-    let input2 = ToolInput { command: "web_search".into(), args: HashMap::from([("query".into(), "rust".into())]), context: None, dry_run: true, timeout_ms: None };
    (B[m[32m+    let input2 = ToolInput {
    (B[m[32m+        command: "web_search".into(),
    (B[m[32m+        args: HashMap::from([("query".into(), "rust".into())]),
    (B[m[32m+        context: None,
    (B[m[32m+        dry_run: true,
    (B[m[32m+        timeout_ms: None,
    (B[m[32m+    };
    (B[m     let out2 = search.execute(input2).await?;
    [31m-    assert!(out2.metadata.get("provider").unwrap().contains("DuckDuckGo"));
    (B[m[32m+    assert!(out2
    (B[m[32m+        .metadata
    (B[m[32m+        .get("provider")
    (B[m[32m+        .unwrap()
    (B[m[32m+        .contains("DuckDuckGo"));
    (B[m     Ok(())
     }
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_web_ops_errors.rs:1:
     #![cfg(feature = "extended-tests")]
     
     use anyhow::Result;
    [32m+use std::collections::HashMap;
    (B[m use tools::web_ops::WebFetch;
     use tools::{Tool, ToolInput};
    [31m-use std::collections::HashMap;
    (B[m 
     #[tokio::test]
     async fn web_fetch_file_not_found_reports_error() -> Result<()> {
    Diff in /workspace/crates/tools/tests/test_web_ops_errors.rs:10:
         let url = "file:///definitely/not/exist".to_string();
         let fetch = WebFetch::new();
    [31m-    let out = fetch.execute(ToolInput { command: "web_fetch".into(), args: HashMap::from([("url".into(), url)]), context: None, dry_run: false, timeout_ms: Some(2000) }).await?;
    (B[m[32m+    let out = fetch
    (B[m[32m+        .execute(ToolInput {
    (B[m[32m+            command: "web_fetch".into(),
    (B[m[32m+            args: HashMap::from([("url".into(), url)]),
    (B[m[32m+            context: None,
    (B[m[32m+            dry_run: false,
    (B[m[32m+            timeout_ms: Some(2000),
    (B[m[32m+        })
    (B[m[32m+        .await?;
    (B[m     assert!(!out.success);
         assert!(out.result.contains("FILE error"));
         assert_eq!(out.metadata.get("source").map(|s| s.as_str()), Some("file"));
    Diff in /workspace/crates/tools/tests/test_web_ops_errors.rs:20:
     async fn web_fetch_malformed_data_url_reports_error() -> Result<()> {
         let url = "data:;base64,%%%".to_string();
         let fetch = WebFetch::new();
    [31m-    let out = fetch.execute(ToolInput { command: "web_fetch".into(), args: HashMap::from([("url".into(), url)]), context: None, dry_run: false, timeout_ms: Some(2000) }).await?;
    (B[m[32m+    let out = fetch
    (B[m[32m+        .execute(ToolInput {
    (B[m[32m+            command: "web_fetch".into(),
    (B[m[32m+            args: HashMap::from([("url".into(), url)]),
    (B[m[32m+            context: None,
    (B[m[32m+            dry_run: false,
    (B[m[32m+            timeout_ms: Some(2000),
    (B[m[32m+        })
    (B[m[32m+        .await?;
    (B[m     assert!(!out.success);
         assert!(out.result.contains("DATA error"));
         assert_eq!(out.metadata.get("source").map(|s| s.as_str()), Some("data"));
    Diff in /workspace/crates/tools/tests/test_web_ops_errors.rs:27:
         Ok(())
     }
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_web_ops_http.rs:1:
     #![cfg(feature = "extended-tests")]
     use anyhow::Result;
    [32m+use std::collections::HashMap;
    (B[m use tokio::io::{AsyncReadExt, AsyncWriteExt};
     use tokio::net::TcpListener;
     use tools::web_ops::WebFetch;
    Diff in /workspace/crates/tools/tests/test_web_ops_http.rs:6:
     use tools::{Tool, ToolInput};
    [31m-use std::collections::HashMap;
    (B[m 
     #[tokio::test]
     async fn web_fetch_http_truncates_and_sets_metadata() -> Result<()> {
    Diff in /workspace/crates/tools/tests/test_web_ops_http.rs:34:
                         Ok(n) => {
                             total += n;
                             if total >= 4 {
    [31m-                            if let Some(window) = buf[..total].windows(4).find(|w| *w == b"\r\n\r\n") { break; }
    (B[m[31m-                            if total >= buf.len() { break; }
    (B[m[32m+                            if let Some(window) =
    (B[m[32m+                                buf[..total].windows(4).find(|w| *w == b"\r\n\r\n")
    (B[m[32m+                            {
    (B[m[32m+                                break;
    (B[m[32m+                            }
    (B[m[32m+                            if total >= buf.len() {
    (B[m[32m+                                break;
    (B[m[32m+                            }
    (B[m                         }
                         }
                         Err(_) => break,
    Diff in /workspace/crates/tools/tests/test_web_ops_http.rs:54:
         let mut args = HashMap::new();
         args.insert("url".to_string(), url.clone());
         let out = tool
    [31m-        .execute(ToolInput { command: "web_fetch".into(), args, context: None, dry_run: false, timeout_ms: Some(5000) })
    (B[m[32m+        .execute(ToolInput {
    (B[m[32m+            command: "web_fetch".into(),
    (B[m[32m+            args,
    (B[m[32m+            context: None,
    (B[m[32m+            dry_run: false,
    (B[m[32m+            timeout_ms: Some(5000),
    (B[m[32m+        })
    (B[m         .await?;
     
         assert!(out.success, "request should succeed");
    Diff in /workspace/crates/tools/tests/test_web_ops_http.rs:61:
         assert_eq!(out.metadata.get("status").map(String::as_str), Some("200"));
    [31m-    assert!(out.metadata.get("content_type").unwrap_or(&"".to_string()).contains("text/plain"));
    (B[m[32m+    assert!(out
    (B[m[32m+        .metadata
    (B[m[32m+        .get("content_type")
    (B[m[32m+        .unwrap_or(&"".to_string())
    (B[m[32m+        .contains("text/plain"));
    (B[m     assert_eq!(out.metadata.get("source").map(String::as_str), Some("http"));
         // bytes should be capped at 1_048_576 (1MB)
    [31m-    assert_eq!(out.metadata.get("bytes").and_then(|s| s.parse::<usize>().ok()), Some(1_048_576));
    (B[m[31m-    let formatted = out.formatted_output.as_ref().expect("formatted_output exists");
    (B[m[32m+    assert_eq!(
    (B[m[32m+        out.metadata
    (B[m[32m+            .get("bytes")
    (B[m[32m+            .and_then(|s| s.parse::<usize>().ok()),
    (B[m[32m+        Some(1_048_576)
    (B[m[32m+    );
    (B[m[32m+    let formatted = out
    (B[m[32m+        .formatted_output
    (B[m[32m+        .as_ref()
    (B[m[32m+        .expect("formatted_output exists");
    (B[m     assert!(formatted.len() >= 100_000);
         assert!(formatted.ends_with("[truncated]"));
     
    Diff in /workspace/crates/tools/tests/test_web_ops_http.rs:70:
         Ok(())
     }
    [32m+
    (B[mDiff in /workspace/crates/tools/tests/test_web_ops_integration.rs:2:
     
     #[tokio::test]
     async fn web_fetch_large_data_url_truncates_metadata() -> Result<()> {
    [32m+    use std::collections::HashMap;
    (B[m     use tools::web_ops::WebFetch;
         use tools::{Tool, ToolInput};
    [31m-    use std::collections::HashMap;
    (B[m 
         // Construct a large data URL > 120k chars to trigger truncation path (though truncation path is for http, we still verify metadata structure)
         let large_text = "A".repeat(200_000);
    Diff in /workspace/crates/tools/tests/test_web_ops_integration.rs:13:
         let tool = WebFetch::new();
         let mut args = HashMap::new();
         args.insert("url".to_string(), data_url);
    [31m-    let out = tool.execute(ToolInput { command: "web_fetch".into(), args, context: None, dry_run: false, timeout_ms: Some(2000) }).await?;
    (B[m[32m+    let out = tool
    (B[m[32m+        .execute(ToolInput {
    (B[m[32m+            command: "web_fetch".into(),
    (B[m[32m+            args,
    (B[m[32m+            context: None,
    (B[m[32m+            dry_run: false,
    (B[m[32m+            timeout_ms: Some(2000),
    (B[m[32m+        })
    (B[m[32m+        .await?;
    (B[m     assert!(out.success);
         assert!(out.metadata.get("bytes").is_some());
         assert_eq!(out.metadata.get("source").map(String::as_str), Some("data"));
    Diff in /workspace/crates/tools/tests/test_web_ops_integration.rs:20:
         assert!(out.formatted_output.as_ref().unwrap().len() >= 200_000 / 2); // urlencoding shrinks check relaxed
         Ok(())
     }
    [32m+
    (B[m
    cargo clippy:
    error: unexpected argument '-D' found
    
    Usage: cargo check [OPTIONS]
    
    For more information, try '--help'.
    
    cargo check:
       Compiling libc v0.2.174
       Compiling openssl-sys v0.9.109
       Compiling num-traits v0.2.19
       Compiling openssl v0.10.73
       Compiling native-tls v0.2.14
       Compiling crc32fast v1.5.0
        Checking crossbeam-epoch v0.9.18
        Checking icu_normalizer v2.0.0
        Checking idna_adapter v1.2.1
        Checking crossbeam-deque v0.8.6
        Checking http v1.3.1
        Checking chrono v0.4.41
        Checking parking_lot_core v0.9.11
        Checking signal-hook-registry v1.4.6
        Checking parking_lot v0.12.4
        Checking mio v1.0.4
        Checking socket2 v0.6.0
        Checking getrandom v0.2.16
        Checking tokio v1.47.1
        Checking getrandom v0.3.3
        Checking ring v0.17.14
        Checking rand_core v0.6.4
        Checking rand_core v0.9.3
        Checking rand_chacha v0.9.0
        Checking rand v0.9.2
        Checking socket2 v0.5.10
        Checking idna v1.0.3
        Checking sct v0.7.1
        Checking rustls-webpki v0.101.7
        Checking rayon-core v1.12.1
        Checking rustls v0.21.12
       Compiling socks v0.3.4
        Checking rayon v1.10.0
        Checking url v2.5.4
        Checking uuid v1.17.0
        Checking rand_chacha v0.3.1
        Checking http-body v1.0.1
        Checking num_cpus v1.17.0
       Compiling filetime v0.2.25
        Checking foreign-types-shared v0.1.1
        Checking console v0.15.11
       Compiling ureq v3.0.12
        Checking dirs-sys v0.4.1
        Checking tokio-util v0.7.16
        Checking tokio-rustls v0.24.1
        Checking foreign-types v0.3.2
       Compiling tar v0.4.44
       Compiling flate2 v1.1.2
        Checking h2 v0.3.27
        Checking rand v0.8.5
       Compiling memoffset v0.7.1
        Checking byteorder v1.5.0
        Checking bitflags v1.3.2
        Checking atomic-waker v1.1.2
        Checking h2 v0.4.12
       Compiling ort-sys v2.0.0-rc.10
        Checking hostname v0.3.1
        Checking indicatif v0.17.11
        Checking hyper v0.14.32
        Checking tracing-subscriber v0.3.19
        Checking dirs v5.0.1
        Checking num-integer v0.1.46
        Checking num-complex v0.4.6
        Checking openssl-probe v0.1.6
       Compiling parking_lot_core v0.8.6
        Checking hyper v1.6.0
        Checking common v0.1.0 (/workspace/crates/common)
        Checking hyper-rustls v0.24.2
        Checking reqwest v0.11.27
    warning: variable does not need to be mutable
      --> crates/common/src/scheduler.rs:29:67
       |
    29 |     pub async fn spawn_periodic<F, Fut>(&self, job: ScheduledJob, mut f: F) where
       |                                                                   ----^
       |                                                                   |
       |                                                                   help: remove this `mut`
       |
       = note: `#[warn(unused_mut)]` on by default
    
       Compiling enum-as-inner v0.6.1
        Checking env_filter v0.1.3
        Checking sync_wrapper v1.0.2
        Checking instant v0.1.13
        Checking tower-layer v0.3.3
        Checking jiff v0.2.15
        Checking tower v0.5.2
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:277:5
        |
    277 |     async fn create_health_data(&self) -> Result<Self::HealthData, crate::MagrayCoreError>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
        = note: `#[warn(async_fn_in_trait)]` on by default
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    277 -     async fn create_health_data(&self) -> Result<Self::HealthData, crate::MagrayCoreError>;
    277 +     fn create_health_data(&self) -> impl std::future::Future<Output = Result<Self::HealthData, crate::MagrayCoreError>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:286:5
        |
    286 |     async fn perform_initialization<T>(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    286 -     async fn perform_initialization<T>(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
    286 +     fn perform_initialization<T>(&mut self, config: T) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:289:5
        |
    289 |     async fn perform_shutdown(&self) -> Result<(), crate::MagrayCoreError>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    289 -     async fn perform_shutdown(&self) -> Result<(), crate::MagrayCoreError>;
    289 +     fn perform_shutdown(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:301:5
        |
    301 |     async fn perform_clear(&mut self) -> Result<(), crate::MagrayCoreError>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    301 -     async fn perform_clear(&mut self) -> Result<(), crate::MagrayCoreError>;
    301 +     fn perform_clear(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:307:5
        |
    307 |     async fn perform_coordinator_init(&self) -> anyhow::Result<()>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    307 -     async fn perform_coordinator_init(&self) -> anyhow::Result<()>;
    307 +     fn perform_coordinator_init(&self) -> impl std::future::Future<Output = anyhow::Result<()>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:310:5
        |
    310 |     async fn check_readiness(&self) -> bool;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    310 -     async fn check_readiness(&self) -> bool;
    310 +     fn check_readiness(&self) -> impl std::future::Future<Output = bool> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:313:5
        |
    313 |     async fn perform_health_check(&self) -> anyhow::Result<()>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    313 -     async fn perform_health_check(&self) -> anyhow::Result<()>;
    313 +     fn perform_health_check(&self) -> impl std::future::Future<Output = anyhow::Result<()>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:316:5
        |
    316 |     async fn perform_coordinator_shutdown(&self) -> anyhow::Result<()>;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    316 -     async fn perform_coordinator_shutdown(&self) -> anyhow::Result<()>;
    316 +     fn perform_coordinator_shutdown(&self) -> impl std::future::Future<Output = anyhow::Result<()>> + Send;
        |
    
    warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
       --> crates/common/src/service_macros.rs:319:5
        |
    319 |     async fn collect_coordinator_metrics(&self) -> serde_json::Value;
        |     ^^^^^
        |
        = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
    help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
        |
    319 -     async fn collect_coordinator_metrics(&self) -> serde_json::Value;
    319 +     fn collect_coordinator_metrics(&self) -> impl std::future::Future<Output = serde_json::Value> + Send;
        |
    
    warning: `common` (lib) generated 10 warnings (run `cargo fix --lib -p common` to apply 1 suggestion)
        Checking tempfile v3.20.0
        Checking sysctl v0.5.5
        Checking rayon-cond v0.3.0
        Checking hyper-util v0.1.16
        Checking nix v0.26.4
        Checking tokio-native-tls v0.3.1
        Checking ndarray v0.16.1
        Checking env_logger v0.11.8
        Checking http-body-util v0.1.3
        Checking inotify-sys v0.1.5
        Checking cpu-time v1.0.0
        Checking combine v4.6.7
        Checking unicode-normalization-alignments v0.1.12
        Checking iri-string v0.7.8
        Checking zeroize v1.8.1
        Checking adler2 v2.0.1
        Checking llm v0.1.0 (/workspace/crates/llm)
        Checking tower-http v0.6.6
        Checking miniz_oxide v0.8.9
        Checking rustls-pki-types v1.12.0
        Checking tokenizers v0.20.4
        Checking mmap-rs v0.6.1
        Checking anndists v0.1.3
        Checking inotify v0.9.6
        Checking hyper-tls v0.6.0
        Checking parking_lot v0.11.2
        Checking ndarray v0.15.6
        Checking fxhash v0.2.1
        Checking tokio-stream v0.1.17
        Checking xattr v1.5.1
        Checking scheduled-thread-pool v0.2.7
        Checking dirs-sys-next v0.1.2
        Checking fs2 v0.4.3
        Checking mio v0.8.11
        Checking rusqlite v0.31.0
        Checking hnsw_rs v0.3.2
        Checking notify v6.1.1
        Checking sled v0.34.7
        Checking dirs-next v2.0.0
        Checking r2d2 v0.8.10
        Checking reqwest v0.12.22
        Checking ort v2.0.0-rc.10
        Checking sysinfo v0.31.4
        Checking tools v0.1.0 (/workspace/crates/tools)
    error[E0583]: file not found for module `execution_pipeline`
      --> crates/tools/src/lib.rs:22:1
       |
    22 | pub mod execution_pipeline;
       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
       |
       = help: to create the module `execution_pipeline`, create file "crates/tools/src/execution_pipeline.rs" or "crates/tools/src/execution_pipeline/mod.rs"
       = note: if there is a `mod execution_pipeline` elsewhere in the crate already, import it with `use crate::...` instead
    
        Checking r2d2_sqlite v0.24.0
        Checking term v0.7.0
        Checking dashmap v6.1.0
        Checking is-terminal v0.4.16
        Checking prettytable-rs v0.10.0
    warning: use of deprecated function `base64::decode`: Use Engine::decode
       --> crates/tools/src/web_ops.rs:199:40
        |
    199 |     let bytes = if is_base64 { base64::decode(data)? } else { urlencoding::decode(data)?.into_owned().into_bytes() };
        |                                        ^^^^^^
        |
        = note: `#[warn(deprecated)]` on by default
    
        Checking domain v0.1.0 (/workspace/crates/domain)
        Checking ai v0.1.0 (/workspace/crates/ai)
    warning: unused import: `GpuDevice`
     --> crates/ai/src/auto_device_selector.rs:2:40
      |
    2 | use crate::gpu_detector::{GpuDetector, GpuDevice};
      |                                        ^^^^^^^^^
      |
      = note: `#[warn(unused_imports)]` on by default
    
    warning: unused import: `GpuConfig`
     --> crates/ai/src/reranker_qwen3.rs:6:13
      |
    6 | use crate::{GpuConfig, GpuInfo};
      |             ^^^^^^^^^
    
    warning: unused variable: `total_texts`
      --> crates/ai/src/gpu_pipeline.rs:77:9
       |
    77 |         total_texts: usize,
       |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_total_texts`
       |
       = note: `#[warn(unused_variables)]` on by default
    
    warning: variable does not need to be mutable
       --> crates/tools/src/web_ops.rs:238:49
        |
    238 |         let (success, result, formatted_output, mut metadata): (bool, String, Option<String>, HashMap<String, String>);
        |                                                 ----^^^^^^^^
        |                                                 |
        |                                                 help: remove this `mut`
        |
        = note: `#[warn(unused_mut)]` on by default
    
    warning: function `mean_pool_scalar` is never used
       --> crates/ai/src/embeddings_cpu.rs:832:15
        |
    832 | pub(crate) fn mean_pool_scalar(data: &[f32], seq_len: usize, hidden_size: usize) -> Vec<f32> {
        |               ^^^^^^^^^^^^^^^^
        |
        = note: `#[warn(dead_code)]` on by default
    
    warning: function `l2_normalize_scalar` is never used
       --> crates/ai/src/embeddings_cpu.rs:850:15
        |
    850 | pub(crate) fn l2_normalize_scalar(mut v: Vec<f32>) -> Vec<f32> {
        |               ^^^^^^^^^^^^^^^^^^^
    
    warning: function `extract_embedding_from_3d_scalar` is never used
       --> crates/ai/src/embeddings_cpu.rs:862:15
        |
    862 | pub(crate) fn extract_embedding_from_3d_scalar(
        |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    warning: method `create_directml_provider` is never used
       --> crates/ai/src/gpu_config.rs:256:8
        |
     67 | impl GpuConfig {
        | -------------- method in this implementation
    ...
    256 |     fn create_directml_provider(&self) -> Result<ExecutionProviderDispatch> {
        |        ^^^^^^^^^^^^^^^^^^^^^^^^
    
    warning: method `calculate_adaptive_batch_size` is never used
       --> crates/ai/src/gpu_pipeline.rs:307:14
        |
    172 | impl GpuPipelineManager {
        | ----------------------- method in this implementation
    ...
    307 |     async fn calculate_adaptive_batch_size(&self, total_texts: usize) -> usize {
        |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    warning: field `model_path` is never read
      --> crates/ai/src/reranker_qwen3.rs:18:5
       |
    16 | pub struct OptimizedQwen3RerankerService {
       |            ----------------------------- field in this struct
    17 |     inner: RerankerInner,
    18 |     model_path: PathBuf,
       |     ^^^^^^^^^^
    
    warning: `ai` (lib) generated 9 warnings (run `cargo fix --lib -p ai` to apply 2 suggestions)
        Checking memory v0.1.0 (/workspace/crates/memory)
    error[E0432]: unresolved imports `di::UnifiedContainer`, `di::UnifiedContainerBuilder`
       --> crates/memory/src/lib.rs:90:5
        |
     90 |     UnifiedContainer as DIContainer,
        |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `UnifiedContainer` in `di`
     91 |     UnifiedContainerBuilder as DIContainerBuilder,
        |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `UnifiedContainerBuilder` in `di`
        |
    note: found an item that was configured out
       --> crates/memory/src/di/mod.rs:134:5
        |
    125 | #[cfg(not(feature = "minimal"))]
        |          --------------------- the item is gated here
    ...
    134 |     UnifiedContainer,
        |     ^^^^^^^^^^^^^^^^
    note: found an item that was configured out
       --> crates/memory/src/di/mod.rs:135:5
        |
    125 | #[cfg(not(feature = "minimal"))]
        |          --------------------- the item is gated here
    ...
    135 |     UnifiedContainerBuilder,
        |     ^^^^^^^^^^^^^^^^^^^^^^^
    
    error[E0433]: failed to resolve: could not find `unified_container_impl` in `di`
       --> crates/memory/src/di/core_traits.rs:230:25
        |
    230 |             &crate::di::unified_container_impl::UnifiedContainer,
        |                         ^^^^^^^^^^^^^^^^^^^^^^ could not find `unified_container_impl` in `di`
        |
    note: found an item that was configured out
       --> crates/memory/src/di/mod.rs:65:9
        |
     64 | #[cfg(not(feature = "minimal"))]
        |          --------------------- the item is gated here
     65 | pub mod unified_container_impl; // ЕДИНСТВЕННАЯ КОРРЕКТНАЯ РЕАЛИЗАЦИЯ DI Container
        |         ^^^^^^^^^^^^^^^^^^^^^^
    
    For more information about this error, try `rustc --explain E0583`.
    warning: `tools` (lib) generated 2 warnings
    error: could not compile `tools` (lib) due to 1 previous error; 2 warnings emitted
    warning: build failed, waiting for other jobs to finish...
    Some errors have detailed explanations: E0432, E0433.
    For more information about an error, try `rustc --explain E0432`.
    error: could not compile `memory` (lib) due to 2 previous errors
    

### Recommendations

- Починить предупреждения clippy и форматирование fmt.
- Сократить количество unwrap/expect; заменить на надёжную обработку ошибок.
- Рассмотреть контейнерный smoke-тест (make smoke-cpu) в CI.
