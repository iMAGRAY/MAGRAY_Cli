use anyhow::Result;
use clap::{Parser, Subcommand};
use common::init_structured_logging;
use common::{events, topics};
use console::{style, Term};
use indicatif::ProgressStyle;
use llm::LlmClient;
use serde_json::json;
use std::io::{self, Write};
use std::sync::Arc;
use std::time::Duration;
use tokio::time::sleep;
use tracing::{info, warn};
use ui::tui::TUIApp;

mod commands;
mod health_checks;
mod progress;
mod services;
mod tui_chat;
mod util;

#[cfg(test)]
mod status_tests;

use cli::agent_traits::AgentResponse;
use commands::{
    GpuCommand, MemoryCommand, ModelsCommand, OrchestratorCommand, SmartCommand, TasksCommand,
    ToolsCommand,
};
use orchestrator::orchestrator::AgentOrchestrator;

// –ò–∫–æ–Ω–∫–∏ –¥–ª—è CLI –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
static ROBOT_ICON: AnimatedIcon = AnimatedIcon::new(&["[AI]", "[‚ñ≤I]", "[‚óèI]", "[‚ô¶I]"]);
static USER_ICON: &str = "[‚ñ∫]";

// –ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ ASCII –∏–∫–æ–Ω–∫–∏
struct AnimatedIcon {
    frames: &'static [&'static str],
}

impl AnimatedIcon {
    const fn new(frames: &'static [&'static str]) -> Self {
        Self { frames }
    }

    fn get_frame(&self, index: usize) -> &'static str {
        self.frames[index % self.frames.len()]
    }
}

#[derive(Parser)]
#[command(name = "magray")]
#[command(about = "[AI] MAGRAY - –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π CLI –∞–≥–µ–Ω—Ç")]
#[command(version = "0.1.0")]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// [‚ñ∫] –ß–∞—Ç —Å LLM –º–æ–¥–µ–ª—å—é
    Chat {
        /// –°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (–µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ - –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º)
        message: Option<String>,
        /// –û—Ç–∫–ª—é—á–∏—Ç—å TUI –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–æ—Å—Ç–æ–π CLI —á–∞—Ç)
        #[arg(long)]
        no_tui: bool,
    },
    /// [‚óè] –ß–∏—Ç–∞–µ—Ç —Ñ–∞–π–ª —Å –∫—Ä–∞—Å–∏–≤–æ–π –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
    Read {
        /// –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É
        path: String,
    },
    /// [‚ñ∫] –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ —Ñ–∞–π–ª
    Write {
        /// –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É
        path: String,
        /// –°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
        content: String,
    },
    /// [‚óè] –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    List {
        /// –ü—É—Ç—å –∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ç–µ–∫—É—â–∞—è)
        path: Option<String>,
    },
    /// [AI] –í—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–∞–Ω–¥—É —Å –ø–æ–º–æ—â—å—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    Tool {
        /// –û–ø–∏—Å–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º —è–∑—ã–∫–µ
        action: String,
    },
    /// [‚òÖ] –£–º–Ω—ã–π –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ (–±–µ–∑ LLM –Ω–∞ –¥–∞–Ω–Ω–æ–º —ç—Ç–∞–ø–µ)
    Smart(SmartCommand),
    /// [üéÆ] –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ GPU —É—Å–∫–æ—Ä–µ–Ω–∏–µ–º
    Gpu(GpuCommand),
    /// [üß†] –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º–æ–π –ø–∞–º—è—Ç–∏
    Memory(MemoryCommand),
    /// [üì¶] –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ–ª—è–º–∏ AI
    Models(ModelsCommand),
    /// [üõ†] –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏ (–≤–∫–ª—é—á–∞—è MCP)
    Tools(ToolsCommand),
    /// [‚òë] –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏
    Tasks(TasksCommand),
    /// [ü§ñ] Multi-Agent Orchestration System
    Orchestrator(OrchestratorCommand),
    /// [üè•] –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã
    Health,
    /// [üìä] –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã
    Status,
    /// [ü§ñ] –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç—É—Å LLM –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
    LlmStatus,
    /// [üìà] –ü–æ–∫–∞–∑–∞—Ç—å performance –º–µ—Ç—Ä–∏–∫–∏ DI —Å–∏—Å—Ç–µ–º—ã
    Performance,
    /// [üîí] –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª–∏—Ç–∏–∫–∞–º–∏ (–∞—É–¥–∏—Ç/–Ω–∞—Å—Ç—Ä–æ–π–∫–∞)
    Policy {
        /// –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –ø—Ä–∞–≤–∏–ª–∞ –∏ –∏—Å—Ç–æ—á–Ω–∏–∫
        #[arg(long)]
        list: bool,
        /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ø—Ä–∞–≤–∏–ª–æ Allow –¥–ª—è shell_exec —á–µ—Ä–µ–∑ env JSON (–¥–µ–º–æ)
        #[arg(long)]
        allow_shell: bool,
    },
    /// [üñ•] –ó–∞–ø—É—Å–∫ TUI –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –¥–ª—è Plan‚ÜíPreview‚ÜíExecute workflow
    Tui,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Early .env loading for OPENAI_API_KEY and other configuration
    dotenv::dotenv().ok();

    // Start events metrics aggregator (non-blocking)
    events::start_tool_metrics_aggregator().await;
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    init_structured_logging()?;

    let cli = Cli::parse();

    // –ö—Ä–∞—Å–∏–≤–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ (–≤ —Ç–µ—Å—Ç–∞—Ö –º–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å —á–µ—Ä–µ–∑ MAGRAY_NO_ANIM)
    if std::env::var("MAGRAY_NO_ANIM").is_err() {
        show_welcome_animation().await?;
    }

    // –ï—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞, –∑–∞–ø—É—Å–∫–∞–µ–º –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —á–∞—Ç
    let cli = if cli.command.is_none() {
        println!("üöÄ –ö–æ–º–∞–Ω–¥–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ - –∑–∞–ø—É—Å–∫–∞–µ–º Claude Code-–ø–æ–¥–æ–±–Ω—ã–π TUI —á–∞—Ç...");

        // –î–ª—è TUI —Ä–µ–∂–∏–º–∞ –æ—Ç–∫–ª—é—á–∞–µ–º –ø–æ–¥—Ä–æ–±–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        std::env::set_var("RUST_LOG", "error");

        Cli {
            command: Some(Commands::Chat {
                message: None,
                no_tui: false,
            }),
        }
    } else {
        cli
    };

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –¥–µ—Ñ–æ–ª—Ç–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π –∏ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    if std::env::var("MAGRAY_SKIP_AUTO_INSTALL").is_err() {
        ensure_default_models_installed_interactive()?;
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å ONNX Runtime –∏ –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
    if std::env::var("MAGRAY_SKIP_AUTO_INSTALL").is_err() {
        ensure_ort_installed_interactive()?;
    }

    // –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –º–∞–Ω–∏—Ñ–µ—Å—Ç–æ–≤ –ø–ª–∞–≥–∏–Ω–æ–≤ –ø–æ —Ñ–ª–∞–≥—É –æ–∫—Ä—É–∂–µ–Ω–∏—è
    if std::env::var("MAGRAY_LOAD_PLUGIN_MANIFESTS")
        .ok()
        .map(|s| s == "1" || s.to_lowercase() == "true")
        .unwrap_or(false)
    {
        let home = util::magray_home();
        let mut plugins_dir = home.clone();
        plugins_dir.push("plugins");
        let mut cfg_dir = home.clone();
        cfg_dir.push("plugin-configs");
        tokio::fs::create_dir_all(&plugins_dir).await.ok();
        tokio::fs::create_dir_all(&cfg_dir).await.ok();
        let registry = tools::plugins::plugin_manager::PluginRegistry::new(plugins_dir, cfg_dir);
        let _ = registry.load_manifests_from_directory().await;
    }

    // –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ç–∞–π–º–∞—É—Ç –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 300—Å)
    let top_timeout_secs: u64 = std::env::var("MAGRAY_CMD_TIMEOUT")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(300);

    use tokio::time::{timeout, Duration};

    let exec_fut = async {
        let cmd_name = match &cli.command {
            Some(Commands::Chat { .. }) => "chat",
            Some(Commands::Read { .. }) => "read",
            Some(Commands::Write { .. }) => "write",
            Some(Commands::List { .. }) => "list",
            Some(Commands::Tool { .. }) => "tool",
            Some(Commands::Smart(_)) => "smart",
            Some(Commands::Gpu(_)) => "gpu",
            Some(Commands::Memory(_)) => "memory",
            Some(Commands::Models(_)) => "models",
            Some(Commands::Tasks(_)) => "tasks",
            Some(Commands::Orchestrator(_)) => "orchestrator",
            Some(Commands::Health) => "health",
            Some(Commands::Status) => "status",
            Some(Commands::LlmStatus) => "llm_status",
            Some(Commands::Performance) => "performance",
            Some(Commands::Policy { .. }) => "policy",
            Some(Commands::Tools(_)) => "tools",
            Some(Commands::Tui) => "tui",
            None => "help",
        };
        tokio::spawn(events::publish(
            topics::TOPIC_INTENT,
            json!({"command": cmd_name}),
        ));

        match cli.command {
            Some(Commands::Chat { message, no_tui }) => handle_chat(message, no_tui).await?,
            Some(Commands::Read { path }) => {
                let orchestrator_service = create_orchestrator_service().await?;
                let message = format!("–ø—Ä–æ—á–∏—Ç–∞–π —Ñ–∞–π–ª {path}");
                let response =
                    process_orchestration_service_message(&orchestrator_service, &message).await?;
                display_response(response).await;
                let _ = orchestrator_service.shutdown().await;
            }
            Some(Commands::Write { path, content }) => {
                let orchestrator_service = create_orchestrator_service().await?;
                let message = format!("—Å–æ–∑–¥–∞–π —Ñ–∞–π–ª {path} —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º: {content}");
                let response =
                    process_orchestration_service_message(&orchestrator_service, &message).await?;
                display_response(response).await;
                let _ = orchestrator_service.shutdown().await;
            }
            Some(Commands::List { path }) => {
                let orchestrator_service = create_orchestrator_service().await?;
                let message = format!("–ø–æ–∫–∞–∂–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏ {}", path.as_deref().unwrap_or("."));
                let response =
                    process_orchestration_service_message(&orchestrator_service, &message).await?;
                display_response(response).await;
                let _ = orchestrator_service.shutdown().await;
            }
            Some(Commands::Tool { action }) => {
                let orchestrator_service = create_orchestrator_service().await?;
                let response =
                    process_orchestration_service_message(&orchestrator_service, &action).await?;
                display_response(response).await;
                let _ = orchestrator_service.shutdown().await;
            }
            Some(Commands::Smart(cmd)) => {
                cmd.execute().await?;
            }
            Some(Commands::Gpu(gpu_command)) => {
                // –õ–æ–∫–∞–ª—å–Ω—ã–π —Ç–∞–π–º–∞—É—Ç 300—Å
                timeout(Duration::from_secs(300), gpu_command.execute())
                    .await
                    .map_err(|_| anyhow::anyhow!("GPU command timeout"))??;
            }
            Some(Commands::Memory(cmd)) => {
                timeout(Duration::from_secs(180), cmd.execute())
                    .await
                    .map_err(|_| anyhow::anyhow!("Memory command timeout"))??;
            }
            Some(Commands::Models(cmd)) => {
                timeout(Duration::from_secs(120), cmd.execute())
                    .await
                    .map_err(|_| anyhow::anyhow!("Models command timeout"))??;
            }
            Some(Commands::Tasks(cmd)) => {
                timeout(Duration::from_secs(180), cmd.execute())
                    .await
                    .map_err(|_| anyhow::anyhow!("Tasks command timeout"))??;
            }
            Some(Commands::Orchestrator(cmd)) => {
                timeout(Duration::from_secs(300), cmd.execute())
                    .await
                    .map_err(|_| anyhow::anyhow!("Orchestrator command timeout"))??;
            }
            Some(Commands::Health) => {
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è health check
                let llm_client = LlmClient::from_env().ok().map(Arc::new);
                let memory_service: Option<Arc<memory::di::UnifiedContainer>> = None;

                timeout(
                    Duration::from_secs(60),
                    health_checks::run_health_checks(llm_client, memory_service),
                )
                .await
                .map_err(|_| anyhow::anyhow!("Health checks timeout"))??;
            }
            Some(Commands::Status) => {
                timeout(Duration::from_secs(60), show_system_status())
                    .await
                    .map_err(|_| anyhow::anyhow!("Status command timeout"))??;
            }
            Some(Commands::LlmStatus) => {
                timeout(Duration::from_secs(60), show_llm_status())
                    .await
                    .map_err(|_| anyhow::anyhow!("LLM status timeout"))??;
            }
            Some(Commands::Performance) => {
                timeout(Duration::from_secs(120), show_performance_metrics())
                    .await
                    .map_err(|_| anyhow::anyhow!("Performance command timeout"))??;
            }
            Some(Commands::Policy { list, allow_shell }) => {
                use common::policy::{
                    load_effective_policy, PolicyAction, PolicyDocument, PolicyRule,
                    PolicySubjectKind,
                };
                let mut home = util::magray_home();
                home.push("policy.json");
                if list {
                    let effective =
                        load_effective_policy(if home.exists() { Some(&home) } else { None });
                    println!(
                        "=== Effective Policy ===\n{}",
                        serde_json::to_string_pretty(&effective).unwrap_or_else(|_| "{}".into())
                    );
                }
                if allow_shell {
                    // Merge small override into MAGRAY_POLICY_JSON
                    let override_doc = PolicyDocument {
                        rules: vec![PolicyRule {
                            subject_kind: PolicySubjectKind::Tool,
                            subject_name: "shell_exec".into(),
                            when_contains_args: None,
                            action: PolicyAction::Allow,
                            reason: Some("cli override".into()),
                        }],
                    };
                    let json = serde_json::to_string(&override_doc)?;
                    std::env::set_var("MAGRAY_POLICY_JSON", json);
                    println!("Applied in-memory override: Allow shell_exec (MAGRAY_POLICY_JSON)\nNote: persist by writing ~/.magray/policy.json");
                }
            }
            Some(Commands::Tools(cmd)) => {
                timeout(Duration::from_secs(300), cmd.execute())
                    .await
                    .map_err(|_| anyhow::anyhow!("Tools command timeout"))??;
            }
            Some(Commands::Tui) => {
                timeout(Duration::from_secs(3600), run_tui_mode())
                    .await
                    .map_err(|_| anyhow::anyhow!("TUI mode timeout"))??;
            }
            None => {
                // –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º
                run_interactive_mode().await?;
            }
        }
        // Publish job completion progress
        tokio::spawn(events::publish(
            topics::TOPIC_JOB_PROGRESS,
            json!({"command": cmd_name, "stage": "done"}),
        ));
        Ok::<(), anyhow::Error>(())
    };

    match timeout(Duration::from_secs(top_timeout_secs), exec_fut).await {
        Ok(res) => {
            if let Err(e) = res {
                tokio::spawn(events::publish(
                    topics::TOPIC_ERROR,
                    json!({"error": e.to_string()}),
                ));
                return Err(e);
            }
        }
        Err(_) => {
            eprintln!("[‚úó] –ö–æ–º–∞–Ω–¥–∞ –ø—Ä–µ–≤—ã—Å–∏–ª–∞ –æ–±—â–∏–π —Ç–∞–π–º–∞—É—Ç {top_timeout_secs}—Å");
            tokio::spawn(events::publish(
                topics::TOPIC_ERROR,
                json!({"error": "global_timeout", "timeout_secs": top_timeout_secs}),
            ));
            return Err(anyhow::anyhow!("Global command timeout"));
        }
    }

    Ok(())
}

async fn run_interactive_mode() -> Result<()> {
    use std::io::{self, Write};
    use tokio::time::{timeout, Duration as TokioDuration};

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
    println!();
    println!(
        "{} {}",
        style("[‚òÖ]").green().bold(),
        style("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º MAGRAY!")
            .bright()
            .bold()
    );
    println!(
        "{} {}",
        style("[‚ñ∫]").cyan(),
        style("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –∏–ª–∏ 'help' –¥–ª—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥").dim()
    );
    println!(
        "{} {}",
        style("[‚ñ∫]").cyan(),
        style("'exit' –∏–ª–∏ 'quit' –¥–ª—è –≤—ã—Ö–æ–¥–∞").dim()
    );
    println!();

    loop {
        // –ö—Ä–∞—Å–∏–≤—ã–π –ø—Ä–æ–º–ø—Ç
        print!("{} ", style("magray>").bright().green().bold());
        io::stdout().flush()?;

        // –ß–∏—Ç–∞–µ–º –≤–≤–æ–¥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç—Ä–µ–¥–µ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–≤–∏—Å–∞–Ω–∏—è
        let input_future = tokio::task::spawn_blocking(|| {
            let mut input = String::new();
            match io::stdin().read_line(&mut input) {
                Ok(_) => Ok(input),
                Err(e) => Err(e),
            }
        });

        let input = match timeout(TokioDuration::from_secs(300), input_future).await {
            Ok(Ok(Ok(input))) => input.trim().to_string(),
            Ok(Ok(Err(e))) => {
                println!("{} Input error: {}", style("[‚úó]").red().bold(), e);
                continue;
            }
            Ok(Err(_)) => {
                println!("{} Input thread panicked", style("[‚úó]").red().bold());
                continue;
            }
            Err(_) => {
                println!(
                    "{} Input timeout after 5 minutes - exiting",
                    style("[‚ö†]").yellow().bold()
                );
                break;
            }
        };

        if input.is_empty() {
            continue;
        }

        if input == "exit" || input == "quit" {
            show_goodbye_animation().await?;
            break;
        }

        if input == "clear" {
            // –û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞
            let term = console::Term::stdout();
            term.clear_screen()?;
            continue;
        }

        // –ü–∞—Ä—Å–∏–º –∫–æ–º–∞–Ω–¥—É
        if let Err(e) = process_interactive_command(&input).await {
            println!("{} Error: {}", style("[‚úó]").red().bold(), e);
        }

        println!();
    }

    Ok(())
}

async fn process_interactive_command(input: &str) -> Result<()> {
    let args: Vec<&str> = input.split_whitespace().collect();
    if args.is_empty() {
        return Ok(());
    }

    match args[0] {
        "help" => {
            show_interactive_help();
        }
        "chat" => {
            let message = if args.len() > 1 {
                Some(args[1..].join(" "))
            } else {
                None
            };
            handle_chat(message, false).await?; // false = –∏—Å–ø–æ–ª—å–∑—É–µ–º TUI –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        }
        "read" => {
            if args.len() < 2 {
                println!("{} Usage: read <path>", style("[!]").yellow().bold());
                return Ok(());
            }
            let orchestrator_service = create_orchestrator_service().await?;
            let message = format!("–ø—Ä–æ—á–∏—Ç–∞–π —Ñ–∞–π–ª {}", args[1]);
            let response =
                process_orchestration_service_message(&orchestrator_service, &message).await?;
            display_response(response).await;
            let _ = orchestrator_service.shutdown().await;
        }
        "write" => {
            if args.len() < 3 {
                println!(
                    "{} Usage: write <path> <content>",
                    style("[!]").yellow().bold()
                );
                return Ok(());
            }
            let orchestrator_service = create_orchestrator_service().await?;
            let content = args[2..].join(" ");
            let message = format!("—Å–æ–∑–¥–∞–π —Ñ–∞–π–ª {} —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º: {}", args[1], content);
            let response =
                process_orchestration_service_message(&orchestrator_service, &message).await?;
            display_response(response).await;
            let _ = orchestrator_service.shutdown().await;
        }
        "list" => {
            let path = if args.len() > 1 { args[1] } else { "." };
            let orchestrator_service = create_orchestrator_service().await?;
            let message = format!("–ø–æ–∫–∞–∂–∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ø–∞–ø–∫–∏ {path}");
            let response =
                process_orchestration_service_message(&orchestrator_service, &message).await?;
            display_response(response).await;
            let _ = orchestrator_service.shutdown().await;
        }
        "tool" => {
            if args.len() < 2 {
                println!("{} Usage: tool <action>", style("[!]").yellow().bold());
                return Ok(());
            }
            let action = args[1..].join(" ");
            let orchestrator_service = create_orchestrator_service().await?;
            let response =
                process_orchestration_service_message(&orchestrator_service, &action).await?;
            display_response(response).await;
            let _ = orchestrator_service.shutdown().await;
        }
        "status" => {
            show_system_status().await?;
        }
        "health" => {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è health check
            let llm_client = LlmClient::from_env().ok().map(Arc::new);
            let memory_service: Option<Arc<memory::di::UnifiedContainer>> = None;
            health_checks::run_health_checks(llm_client, memory_service).await?;
        }
        unknown => {
            println!(
                "{} Unknown command: '{}'. Type 'help' for available commands.",
                style("[!]").yellow().bold(),
                unknown
            );
        }
    }

    Ok(())
}

fn show_interactive_help() {
    println!(
        "{}",
        style("=== MAGRAY Interactive Commands ===").bold().cyan()
    );
    println!();
    println!(
        "{} {} - Chat with AI",
        style("chat").green().bold(),
        style("[message]").dim()
    );
    println!(
        "{} {} - Read file",
        style("read").green().bold(),
        style("<path>").dim()
    );
    println!(
        "{} {} - Write file",
        style("write").green().bold(),
        style("<path> <content>").dim()
    );
    println!(
        "{} {} - List directory",
        style("list").green().bold(),
        style("[path]").dim()
    );
    println!(
        "{} {} - Execute tool action",
        style("tool").green().bold(),
        style("<action>").dim()
    );
    println!("{} - Show system status", style("status").green().bold());
    println!("{} - Run health checks", style("health").green().bold());
    println!("{} - Clear screen", style("clear").green().bold());
    println!("{} - Show this help", style("help").green().bold());
    println!("{} - Exit interactive mode", style("exit").green().bold());
    println!();
}

async fn show_welcome_animation() -> Result<()> {
    let term = Term::stdout();

    // –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏
    let spinner = indicatif::ProgressBar::new_spinner();
    spinner.set_style(
        ProgressStyle::default_spinner()
            .tick_chars("[|][/][-][\\]")
            .template("{spinner:.cyan} {msg}")
            .unwrap_or_else(|e| {
                eprintln!("Warning: Failed to create spinner template: {e}");
                ProgressStyle::default_spinner()
            }),
    );

    spinner.set_message("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MAGRAY CLI...");

    // –ö—Ä–∞—Å–∏–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    let messages = [
        "–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–µ–π—Ä–æ–Ω–Ω—ã—Ö —Å–µ—Ç–µ–π...",
        "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∫–≤–∞–Ω—Ç–æ–≤—ã–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞–º...",
        "–ê–∫—Ç–∏–≤–∞—Ü–∏—è –∏—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç–∞...",
        "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —è–∑—ã–∫–æ–≤–æ–π –º–æ–¥–µ–ª–∏...",
        "–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!",
    ];

    for msg in messages.iter() {
        spinner.set_message(*msg);
        sleep(Duration::from_millis(400)).await;
    }

    spinner.finish_and_clear();

    // –ö—Ä–∞—Å–∏–≤—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
    term.clear_screen()?;
    println!();
    println!(
        "{}",
        style("  ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó")
            .cyan()
            .bold()
    );
    println!(
        "{}",
        style("  ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù")
            .cyan()
            .bold()
    );
    println!(
        "{}",
        style("  ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ")
            .cyan()
            .bold()
    );
    println!(
        "{}",
        style("  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë  ‚ïö‚ñà‚ñà‚ïî‚ïù  ")
            .cyan()
            .bold()
    );
    println!(
        "{}",
        style("  ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ")
            .cyan()
            .bold()
    );
    println!(
        "{}",
        style("  ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ")
            .cyan()
            .bold()
    );
    println!();
    println!(
        "       {} {}",
        style("–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π CLI –∞–≥–µ–Ω—Ç").bright().bold(),
        style("v0.1.0").dim()
    );
    println!("       {}", style("Powered by AI ‚Ä¢ Made with Rust").dim());
    println!();

    Ok(())
}

async fn handle_chat(message: Option<String>, no_tui: bool) -> Result<()> {
    use tokio::time::{timeout, Duration as TokioDuration};

    let _term = Term::stdout();

    // –í –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–º —Ä–µ–∂–∏–º–µ –Ω–µ —á–∏—Ç–∞–µ–º stdin (–±–ª–æ–∫–∏—Ä—É–µ—Ç TUI)
    let stdin_message = None;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è LLM –∫–ª–∏–µ–Ω—Ç–∞ —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
    let spinner = indicatif::ProgressBar::new_spinner();
    spinner.set_style(
        ProgressStyle::default_spinner()
            .tick_chars("[‚óè][‚óê][‚óë][‚óí][‚óì][‚óè]")
            .template("{spinner} {msg}")
            .unwrap_or_else(|e| {
                eprintln!("Warning: Failed to create LLM spinner template: {e}");
                ProgressStyle::default_spinner()
            }),
    );
    spinner.set_message("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –Ω–µ–π—Ä–æ–Ω–Ω–æ–π —Å–µ—Ç–∏...");

    let _llm_client = match LlmClient::from_env() {
        Ok(client) => {
            spinner.finish_with_message("[‚úì] –ü–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ LLM!");
            sleep(Duration::from_millis(500)).await;
            spinner.finish_and_clear();
            client
        }
        Err(e) => {
            spinner.finish_with_message("[‚úó] –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è!");
            println!();
            println!(
                "{} {}",
                style("–û—à–∏–±–∫–∞:").red().bold(),
                style(format!("{e}")).red()
            );
            println!();
            println!(
                "{} –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª .env —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏:",
                style("[i] –†–µ—à–µ–Ω–∏–µ:").yellow().bold()
            );
            println!(
                "   {} {}",
                style("$").green(),
                style("cp .env.example .env").cyan()
            );
            println!(
                "   {} {}",
                style("#").dim(),
                style("–û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ .env –∏ —É–∫–∞–∂–∏—Ç–µ –≤–∞—à API –∫–ª—é—á").dim()
            );
            return Err(e);
        }
    };

    // –ó–∞–ø—É—Å–∫–∞–µ–º TUI —Å–Ω–∞—á–∞–ª–∞, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å –≤ —Ñ–æ–Ω–µ
    if let Some(msg) = message.or(stdin_message) {
        // –î–ª—è –æ–¥–∏–Ω–æ—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –Ω—É–∂–µ–Ω —Å–µ—Ä–≤–∏—Å
        let service_future = create_orchestrator_service();
        let service = match timeout(TokioDuration::from_secs(30), service_future).await {
            Ok(Ok(service)) => service,
            Ok(Err(e)) => return Err(e),
            Err(_) => {
                return Err(anyhow::anyhow!(
                    "OrchestrationService initialization timeout after 30 seconds"
                ))
            }
        };
        process_single_message_orchestrator(&service, &msg).await?;
        let _ = service.shutdown().await;
        return Ok(());
    }

    // –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º - –∑–∞–ø—É—Å–∫–∞–µ–º TUI –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
    if no_tui {
        // CLI —Ä–µ–∂–∏–º - –Ω—É–∂–µ–Ω —Å–µ—Ä–≤–∏—Å
        let service_future = create_orchestrator_service();
        let service = match timeout(TokioDuration::from_secs(5), service_future).await {
            Ok(Ok(service)) => service,
            Ok(Err(_)) | Err(_) => {
                println!("‚ö†Ô∏è  AgentOrchestrator –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ–π LLM —Ä–µ–∂–∏–º...");
                services::OrchestrationService::with_llm_fallback().await?
            }
        };
        run_interactive_chat_orchestrator(&service).await?;
        let _ = service.shutdown().await;
    } else {
        // TUI —Ä–µ–∂–∏–º - –∑–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –±–µ–∑ –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å
        run_tui_chat_with_async_init().await?;
    }

    Ok(())
}

#[allow(dead_code)]
async fn process_single_message(orchestrator: &AgentOrchestrator, message: &str) -> Result<()> {
    use tokio::time::{timeout, Duration as TokioDuration};

    // –ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º 60 —Å–µ–∫—É–Ω–¥
    let process_future = process_orchestrator_message(orchestrator, message);
    let response = match timeout(TokioDuration::from_secs(60), process_future).await {
        Ok(Ok(response)) => response,
        Ok(Err(e)) => return Err(e),
        Err(_) => {
            println!(
                "{} Message processing timeout after 60 seconds",
                style("[‚ö†]").yellow().bold()
            );
            return Err(anyhow::anyhow!("Message processing timeout"));
        }
    };

    display_response(response).await;
    Ok(())
}

async fn process_single_message_orchestrator(
    service: &services::OrchestrationService,
    message: &str,
) -> Result<()> {
    use tokio::time::{timeout, Duration as TokioDuration};

    // –ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏—è —Å —Ç–∞–π–º–∞—É—Ç–æ–º 60 —Å–µ–∫—É–Ω–¥
    let process_future = process_orchestration_service_message(service, message);
    let response = match timeout(TokioDuration::from_secs(60), process_future).await {
        Ok(Ok(response)) => response,
        Ok(Err(e)) => return Err(e),
        Err(_) => {
            println!(
                "{} Message processing timeout after 60 seconds",
                style("[‚ö†]").yellow().bold()
            );
            return Err(anyhow::anyhow!("Message processing timeout"));
        }
    };

    display_response(response).await;
    Ok(())
}

#[allow(dead_code)]
async fn run_interactive_chat(orchestrator: &AgentOrchestrator) -> Result<()> {
    use tokio::time::{timeout, Duration as TokioDuration};

    println!(
        "{} {}",
        style("[‚òÖ]").green().bold(),
        style("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º!")
            .bright()
            .bold()
    );
    println!(
        "{} {}",
        style("[‚ñ∫]").cyan(),
        style("–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏").dim()
    );
    println!(
        "{} {} {}",
        style("   ").dim(),
        style("'exit'").yellow().bold(),
        style("–¥–ª—è –≤—ã—Ö–æ–¥–∞").dim()
    );
    println!();

    loop {
        // –ö—Ä–∞—Å–∏–≤—ã–π –ø—Ä–æ–º–ø—Ç
        print!(
            "{} {} ",
            style(USER_ICON).bright().green(),
            style("–í—ã:").bright().bold()
        );
        io::stdout().flush()?;

        // –ß–∏—Ç–∞–µ–º –≤–≤–æ–¥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç—Ä–µ–¥–µ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–≤–∏—Å–∞–Ω–∏—è
        let input_future = tokio::task::spawn_blocking(|| {
            let mut input = String::new();
            match io::stdin().read_line(&mut input) {
                Ok(_) => Ok(input),
                Err(e) => Err(e),
            }
        });

        let input = match timeout(TokioDuration::from_secs(300), input_future).await {
            Ok(Ok(Ok(input))) => input.trim().to_string(),
            Ok(Ok(Err(e))) => {
                println!("{} Input error: {}", style("[‚úó]").red().bold(), e);
                continue;
            }
            Ok(Err(_)) => {
                println!("{} Input thread panicked", style("[‚úó]").red().bold());
                continue;
            }
            Err(_) => {
                println!(
                    "{} Input timeout after 5 minutes - exiting",
                    style("[‚ö†]").yellow().bold()
                );
                break;
            }
        };

        if input.is_empty() {
            continue;
        }

        if input == "exit" || input == "quit" {
            show_goodbye_animation().await?;
            break;
        }

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å timeout –∑–∞—â–∏—Ç–æ–π
        let process_future = process_orchestrator_message(orchestrator, &input);
        let response = match timeout(TokioDuration::from_secs(60), process_future).await {
            Ok(Ok(response)) => response,
            Ok(Err(e)) => {
                println!("{} Processing error: {}", style("[‚úó]").red().bold(), e);
                continue;
            }
            Err(_) => {
                println!(
                    "{} Message processing timeout after 60 seconds",
                    style("[‚ö†]").yellow().bold()
                );
                continue;
            }
        };

        display_response(response).await;
        println!();
    }

    Ok(())
}

/// –ó–∞–ø—É—Å–∫–∞–µ—Ç TUI —á–∞—Ç –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
async fn run_tui_chat(service: &services::OrchestrationService) -> Result<()> {
    tui_chat::run_tui_chat(service).await
}

async fn run_tui_chat_with_async_init() -> Result<()> {
    tui_chat::run_tui_chat_with_async_init().await
}

async fn run_interactive_chat_orchestrator(service: &services::OrchestrationService) -> Result<()> {
    use tokio::time::{timeout, Duration as TokioDuration};

    println!(
        "{} {}",
        style("[‚òÖ]").green().bold(),
        style("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —á–∞—Ç!")
            .bright()
            .bold()
    );
    println!(
        "{} {}",
        style("[üí°]").cyan(),
        style("–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ - –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞—Ç—å –ª—é–±–æ–π –≤–æ–ø—Ä–æ—Å").dim()
    );
    println!(
        "{} {} {} {} {}",
        style("   ").dim(),
        style("'exit'").yellow().bold(),
        style("–∏–ª–∏").dim(),
        style("'quit'").yellow().bold(),
        style("–¥–ª—è –≤—ã—Ö–æ–¥–∞").dim()
    );
    println!();

    loop {
        // –ö—Ä–∞—Å–∏–≤—ã–π –ø—Ä–æ–º–ø—Ç
        print!(
            "{} {} ",
            style(USER_ICON).bright().green(),
            style("–í—ã:").bright().bold()
        );
        io::stdout().flush()?;

        // –ß–∏—Ç–∞–µ–º –≤–≤–æ–¥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º —Ç—Ä–µ–¥–µ —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–≤–∏—Å–∞–Ω–∏—è
        let input_future = tokio::task::spawn_blocking(|| {
            let mut input = String::new();
            match io::stdin().read_line(&mut input) {
                Ok(_) => Ok(input),
                Err(e) => Err(e),
            }
        });

        let input = match timeout(TokioDuration::from_secs(300), input_future).await {
            Ok(Ok(Ok(input))) => input.trim().to_string(),
            Ok(Ok(Err(e))) => {
                println!("{} Input error: {}", style("[‚úó]").red().bold(), e);
                continue;
            }
            Ok(Err(_)) => {
                println!("{} Input thread panicked", style("[‚úó]").red().bold());
                continue;
            }
            Err(_) => {
                println!(
                    "{} Input timeout after 5 minutes - exiting",
                    style("[‚ö†]").yellow().bold()
                );
                break;
            }
        };

        if input.is_empty() {
            continue;
        }

        if input == "exit" || input == "quit" {
            show_goodbye_animation().await?;
            break;
        }

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å timeout –∑–∞—â–∏—Ç–æ–π
        let process_future = process_orchestration_service_message(service, &input);
        let response = match timeout(TokioDuration::from_secs(60), process_future).await {
            Ok(Ok(response)) => response,
            Ok(Err(e)) => {
                println!("{} Processing error: {}", style("[‚úó]").red().bold(), e);
                continue;
            }
            Err(_) => {
                println!(
                    "{} Message processing timeout after 60 seconds",
                    style("[‚ö†]").yellow().bold()
                );
                continue;
            }
        };

        display_response(response).await;
        println!();
    }

    Ok(())
}

async fn display_response(response: AgentResponse) {
    match response {
        AgentResponse::Chat(text) => {
            display_chat_response(&text).await;
        }
        AgentResponse::ToolExecution(result) => {
            println!("{result}");
        }
        AgentResponse::Admin(admin_response) => {
            use cli::agent_traits::AdminResponse;
            match admin_response {
                AdminResponse::SystemStats(stats) => println!("{stats}"),
                AdminResponse::HealthStatus(status) => println!("{status}"),
                AdminResponse::PerformanceMetrics(metrics) => println!("{metrics}"),
                AdminResponse::OperationResult(result) => println!("{result}"),
            }
        }
        AgentResponse::Error(error_msg) => {
            println!("{} {}", style("[‚úó]").red().bold(), style(error_msg).red());
        }
    }
}

async fn display_chat_response(text: &str) {
    // –ê–Ω–∏–º–∞—Ü–∏—è –ø–µ—á–∞—Ç–∏ –æ—Ç–≤–µ—Ç–∞
    print!(
        "{} {} ",
        style(ROBOT_ICON.get_frame(0)).bright().blue(),
        style("AI:").bright().green().bold()
    );

    // –≠—Ñ—Ñ–µ–∫—Ç –ø–µ—á–∞—Ç–∞–Ω–∏—è
    for char in text.chars() {
        print!("{}", style(char).bright());
        if let Err(e) = io::stdout().flush() {
            eprintln!("Warning: Failed to flush stdout: {e}");
        }
        sleep(Duration::from_millis(20)).await;
    }
    println!();
}

/// –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è AgentOrchestrator
async fn create_agent_orchestrator() -> Result<AgentOrchestrator> {
    use orchestrator::events::{AgentEventPublisher, DefaultAgentEventPublisher};
    use orchestrator::orchestrator::OrchestratorConfig;
    use orchestrator::system::SystemConfig;
    use std::sync::Arc;

    let system_config = SystemConfig::default();
    let orchestrator_config = OrchestratorConfig::default();

    // –°–æ–∑–¥–∞–µ–º AgentEventPublisher –¥–ª—è orchestrator
    let agent_id = uuid::Uuid::new_v4();
    let event_publisher = Arc::new(DefaultAgentEventPublisher::new(
        agent_id,
        "CLI-Orchestrator".to_string(),
        "orchestrator".to_string(),
    )) as Arc<dyn AgentEventPublisher>;

    AgentOrchestrator::new(system_config, orchestrator_config, event_publisher)
        .await
        .map_err(|e| anyhow::anyhow!("Failed to create orchestrator: {}", e))
}

/// –°–æ–∑–¥–∞–Ω–∏–µ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ AgentOrch–µ—Å—Çrator-based —Å–µ—Ä–≤–∏—Å–∞
async fn create_orchestrator_service() -> Result<services::OrchestrationService> {
    use indicatif::{ProgressBar, ProgressStyle};

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    let spinner = ProgressBar::new_spinner();
    spinner.set_style(
        ProgressStyle::default_spinner()
            .tick_chars("‚†Å‚†Ç‚†Ñ‚°Ä‚¢Ä‚††‚†ê‚†à ")
            .template("{spinner:.cyan} {msg}")
            .unwrap_or_else(|_| ProgressStyle::default_spinner()),
    );

    spinner.set_message("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–≥–µ–Ω—Ç–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã...");
    spinner.enable_steady_tick(Duration::from_millis(100));

    // Try to create with real orchestrator first
    match services::OrchestrationService::with_orchestrator().await {
        Ok(service) => {
            spinner.finish_with_message("‚úÖ –ú—É–ª—å—Ç–∏-–∞–≥–µ–Ω—Ç–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞!");
            info!("OrchestrationService with AgentOrchestrator created successfully");
            Ok(service)
        }
        Err(e) => {
            spinner.set_message("‚ö†Ô∏è  –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ LLM —Ä–µ–∂–∏–º...");

            warn!(
                "Failed to create orchestrator service: {}, falling back to LLM-powered service",
                e
            );

            // Fall back to LLM-powered orchestration service
            match services::OrchestrationService::with_llm_fallback().await {
                Ok(service) => {
                    spinner.finish_with_message("‚úÖ LLM —Ä–µ–∂–∏–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!");
                    Ok(service)
                }
                Err(fallback_error) => {
                    spinner.finish_with_message("‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏");
                    Err(anyhow::anyhow!(
                        "Orchestrator failed: {}. Fallback failed: {}",
                        e,
                        fallback_error
                    ))
                }
            }
        }
    }
}

/// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ AgentOrchestrator workflow
async fn process_orchestrator_message(
    orchestrator: &AgentOrchestrator,
    message: &str,
) -> Result<AgentResponse> {
    use orchestrator::workflow::WorkflowRequest;

    // –°–æ–∑–¥–∞–µ–º workflow request –¥–ª—è Intent‚ÜíPlan‚ÜíExecute‚ÜíCritic workflow
    let workflow_request = WorkflowRequest {
        user_input: message.to_string(),
        context: None,
        priority: orchestrator::actors::TaskPriority::Normal,
        dry_run: false,
        timeout_ms: Some(60000),
        config_overrides: None,
    };

    // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–ª–Ω—ã–π workflow: Intent‚ÜíPlan‚ÜíExecute‚ÜíCritic
    let workflow_result = orchestrator.execute_workflow(workflow_request).await?;

    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ AgentResponse
    let content = if workflow_result.success {
        workflow_result
            .results
            .and_then(|r| r.as_str().map(String::from))
            .unwrap_or_else(|| "–ó–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ".to_string())
    } else {
        workflow_result
            .error
            .unwrap_or_else(|| "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏".to_string())
    };

    Ok(AgentResponse::Chat(content))
}

/// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ OrchestrationService (legacy fallback)
#[allow(dead_code)]
async fn process_orchestration_service_message(
    service: &services::OrchestrationService,
    message: &str,
) -> Result<AgentResponse> {
    let response = service.process_user_request(message).await?;
    Ok(AgentResponse::Chat(response))
}

async fn show_goodbye_animation() -> Result<()> {
    let spinner = indicatif::ProgressBar::new_spinner();
    spinner.set_style(
        ProgressStyle::default_spinner()
            .tick_chars("[‚óÑ][‚óÅ][‚óÄ][‚ñ†]")
            .template("{spinner} {msg}")
            .unwrap_or_else(|e| {
                eprintln!("Warning: Failed to create goodbye spinner template: {e}");
                ProgressStyle::default_spinner()
            }),
    );

    let goodbye_messages = [
        "–°–æ—Ö—Ä–∞–Ω—è—é —Å–µ—Å—Å–∏—é...",
        "–ó–∞–∫—Ä—ã–≤–∞—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...",
        "–û—á–∏—â–∞—é –ø–∞–º—è—Ç—å...",
        "–î–æ —Å–≤–∏–¥–∞–Ω–∏—è!",
    ];

    for msg in goodbye_messages.iter() {
        spinner.set_message(*msg);
        sleep(Duration::from_millis(300)).await;
    }

    spinner.finish_and_clear();

    println!();
    println!(
        "{} {}",
        style("[‚òÖ]").bright().yellow(),
        style("–°–ø–∞—Å–∏–±–æ –∑–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ MAGRAY CLI!")
            .bright()
            .bold()
    );
    println!(
        "{} {}",
        style("[‚ñ∫]").cyan(),
        style("–£–≤–∏–¥–∏–º—Å—è –≤ —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞–∑!").cyan()
    );
    println!();

    Ok(())
}

async fn show_system_status() -> Result<()> {
    use colored::Colorize;

    let spinner = progress::ProgressBuilder::fast("Checking system status...");

    // –í —Ç–µ–∫—É—â–µ–º –ø—Ä–æ—Ñ–∏–ª–µ memory —Å–µ—Ä–≤–∏—Å –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞–ø—Ä—è–º—É—é
    let memory_status: Option<(String, usize, f64)> = None;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º LLM —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
    let llm_status = match LlmClient::from_env() {
        Ok(_client) => {
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - –µ—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–ª—Å—è, —Ç–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
            "Connected"
        }
        Err(_) => "Not configured",
    };

    spinner.finish_success(Some("System status checked!"));

    // –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç—É—Å
    println!("{}", style("=== MAGRAY System Status ===").bold().cyan());
    println!();

    // LLM Status
    let llm_icon = match llm_status {
        "Connected" => "‚úì".green(),
        "Connection error" => "‚ö†".yellow(),
        _ => "‚úó".red(),
    };
    println!("{} {}: {}", llm_icon, "LLM Service".bold(), llm_status);

    // Memory Status —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–æ–π
    if let Some((health, record_count, hit_rate)) = memory_status {
        let (memory_icon, status_msg) = match health.as_str() {
            "healthy" => ("‚úì".green(), "Healthy".to_string()),
            "degraded" => ("‚ö†".yellow(), "Degraded (CPU only)".to_string()),
            "cpu-only" => ("‚ö†".yellow(), "CPU only (no GPU)".to_string()),
            "error" => ("‚úó".red(), "Service error".to_string()),
            "timeout" => ("‚åõ".yellow(), "Initialization timeout".to_string()),
            "config-error" => ("‚úó".red(), "Configuration error".to_string()),
            _ => ("?".cyan(), format!("Unknown ({health})")),
        };

        if record_count > 0 || hit_rate > 0.0 {
            println!(
                "{} {}: {} ({} records, {:.1}% cache hit)",
                memory_icon,
                "Memory Service".bold(),
                status_msg,
                record_count,
                hit_rate * 100.0
            );
        } else {
            println!(
                "{} {}: {}",
                memory_icon,
                "Memory Service".bold(),
                status_msg
            );
        }
    } else {
        println!("{} {}: Not available", "‚úó".red(), "Memory Service".bold());
    }

    // Binary info
    let binary_size = std::env::current_exe()
        .and_then(|path| path.metadata())
        .map(|meta| meta.len())
        .unwrap_or(0);

    let version = env!("CARGO_PKG_VERSION");
    println!(
        "{} {}: v{} ({:.1} MB)",
        "‚Ñπ".blue(),
        "Binary".bold(),
        version,
        binary_size as f64 / (1024.0 * 1024.0)
    );

    // Environment
    let log_level = std::env::var("RUST_LOG").unwrap_or_else(|_| "info".to_string());
    println!("{} {}: {}", "‚Ñπ".blue(), "Log Level".bold(), log_level);

    // Policy audit
    use common::policy::load_effective_policy;
    let mut home = crate::util::magray_home();
    home.push("policy.json");
    let has_file = home.exists();
    let effective = load_effective_policy(if has_file { Some(&home) } else { None });
    let rules_count = effective.rules.len();
    let src = if std::env::var("MAGRAY_POLICY_JSON")
        .ok()
        .filter(|s| !s.trim().is_empty())
        .is_some()
    {
        "env-json"
    } else if std::env::var("MAGRAY_POLICY_PATH").is_ok() || has_file {
        "file"
    } else {
        "default"
    };
    println!("üîí Policy: {src} (rules: {rules_count})");
    // Risk aggregation
    let mut low = 0usize;
    let mut med = 0usize;
    let mut high = 0usize;
    for r in &effective.rules {
        let risk = {
            // mirror logic from infer_risk_from_reason
            let reason = r.reason.as_deref();
            if let Some(rr) = reason {
                let l = rr.to_lowercase();
                if l.contains("high") || l.contains("critical") || l.contains("danger") {
                    common::policy::RiskLevel::High
                } else if l.contains("medium") || l.contains("moderate") {
                    common::policy::RiskLevel::Medium
                } else {
                    common::policy::RiskLevel::Low
                }
            } else {
                common::policy::RiskLevel::Low
            }
        };
        match risk {
            common::policy::RiskLevel::High => high += 1,
            common::policy::RiskLevel::Medium => med += 1,
            common::policy::RiskLevel::Low => low += 1,
        }
    }
    println!("  risks: low={low} medium={med} high={high}");
    // Brief audit: list up to 5 rules
    let preview_len = effective.rules.len().min(5);
    if preview_len > 0 {
        println!("  {}", "Rules preview:".dimmed());
        for rule in effective.rules.iter().take(preview_len) {
            let when = rule
                .when_contains_args
                .as_ref()
                .map(|m| {
                    if m.is_empty() {
                        String::new()
                    } else {
                        format!(" when={m:?}")
                    }
                })
                .unwrap_or_default();
            println!(
                "  ‚Ä¢ {:?} {} -> {:?}{}",
                rule.subject_kind, rule.subject_name, rule.action, when
            );
        }
        if rules_count > preview_len {
            println!("  ... and {} more", rules_count - preview_len);
        }
    }

    // Publish health summary event
    tokio::spawn(events::publish(
        topics::TOPIC_HEALTH,
        serde_json::json!({
            "llm": llm_status,
            "policy_rules": rules_count,
            "risk": {"low": low, "medium": med, "high": high}
        }),
    ));

    println!();

    Ok(())
}

async fn show_llm_status() -> Result<()> {
    use colored::Colorize;
    use tracing::info;

    let spinner = progress::ProgressBuilder::fast("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ LLM –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤...");

    info!("ü§ñ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ LLM —Å–∏—Å—Ç–µ–º—ã");

    // –ü—ã—Ç–∞–µ–º—Å—è —Å–æ–∑–¥–∞—Ç—å multi-provider –∫–ª–∏–µ–Ω—Ç
    let client_result = LlmClient::from_env_multi();

    match client_result {
        Ok(client) => {
            spinner.finish_success(Some("Multi-provider —Å–∏—Å—Ç–µ–º–∞ –¥–æ—Å—Ç—É–ø–Ω–∞!"));

            if let Some(status_report) = client.get_status_report().await {
                println!("\n{status_report}");
            } else {
                println!("\nüîß Multi-provider —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞, –Ω–æ —Å—Ç–∞—Ç—É—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω");
            }
        }
        Err(e) => {
            spinner.finish_success(Some("Fallback –∫ single-provider —Ä–µ–∂–∏–º—É"));

            match LlmClient::from_env() {
                Ok(_single_client) => {
                    println!("\nüîß Single Provider Mode");
                    println!(
                        "{} LLM –ø—Ä–æ–≤–∞–π–¥–µ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ",
                        "‚úì".green().bold()
                    );
                    println!();
                    println!("üí° –î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ multi-provider —Ä–µ–∂–∏–º–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ:");
                    println!("  ‚Ä¢ OPENAI_API_KEY=your_openai_key");
                    println!("  ‚Ä¢ ANTHROPIC_API_KEY=your_anthropic_key");
                    println!("  ‚Ä¢ GROQ_API_KEY=your_groq_key");
                    println!("  ‚Ä¢ OLLAMA_URL=http://localhost:11434");
                    println!("  ‚Ä¢ LMSTUDIO_URL=http://localhost:1234");
                }
                Err(single_err) => {
                    println!("\n{} –û—à–∏–±–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ LLM", "‚ùå".red().bold());
                    println!("Multi-provider –æ—à–∏–±–∫–∞: {e}");
                    println!("Single-provider –æ—à–∏–±–∫–∞: {single_err}");
                    println!();
                    println!("üîß –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –ø—Ä–æ–≤–∞–π–¥–µ—Ä:");
                    println!("  LLM_PROVIDER=openai");
                    println!("  OPENAI_API_KEY=your_key_here");
                }
            }
        }
    }

    println!();
    Ok(())
}

async fn show_performance_metrics() -> Result<()> {
    use colored::Colorize;
    use tracing::info;

    let spinner = progress::ProgressBuilder::fast("Collecting performance metrics...");

    info!("üìà Initializing UnifiedAgent for performance metrics");

    // –°–æ–∑–¥–∞–µ–º UnifiedAgent –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ DI —Å–∏—Å—Ç–µ–º–µ
    let _orchestrator = match create_agent_orchestrator().await {
        Ok(agent) => {
            info!("‚úÖ UnifiedAgent initialized successfully");
            agent
        }
        Err(e) => {
            spinner.finish_error(&format!("Failed to initialize agent: {e}"));
            println!("{} Error: {}", "‚úó".red(), e);
            return Ok(());
        }
    };

    spinner.finish_success(Some("Performance metrics collected!"));

    // –í—ã–≤–æ–¥–∏–º performance –æ—Ç—á–µ—Ç
    println!(
        "{}",
        style("=== MAGRAY Performance Metrics ===").bold().cyan()
    );
    println!();

    // –í –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å–±–æ—Ä–∫–µ –¥–µ—Ç–∞–ª—å–Ω—ã–µ DI-–º–µ—Ç—Ä–∏–∫–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã
    let mock_metrics = memory::DIPerformanceMetrics::default();

    if mock_metrics.resolution_time_avg_ms > 0.0 {
        println!();
        println!("{}", style("=== Detailed Analysis ===").bold().yellow());
        println!("‚ÑπÔ∏è Detailed DI metrics are not available in minimal build.");

        println!();
        println!(
            "{} Use 'magray performance' again to track improvements",
            "‚ÑπÔ∏è".blue()
        );
    } else {
        println!();
        println!("{} No performance data available yet.", "‚ÑπÔ∏è".blue());
        println!("  Try running some commands first to generate metrics.");
    }

    println!();

    Ok(())
}

fn ensure_default_models_installed_interactive() -> Result<()> {
    use colored::Colorize;
    use std::io::{stdin, stdout, Write};

    // –ï—Å–ª–∏ –≤ CI - –Ω–µ —Å–ø—Ä–∞—à–∏–≤–∞–µ–º, —Å—Ç–∞–≤–∏–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (–∏–ª–∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ FORCE_NO_ORT)
    let non_interactive = std::env::var("CI").is_ok() || std::env::var("MAGRAY_AUTO_YES").is_ok();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Ç–∞–ª–æ–≥–∏ –º–æ–¥–µ–ª–µ–π
    let models_dir = std::path::PathBuf::from("models");
    let needs_emb = !models_dir.join("qwen3emb").exists();
    let needs_rerank = !models_dir.join("qwen3_reranker").exists();

    if !(needs_emb || needs_rerank) {
        return Ok(());
    }

    if non_interactive {
        println!(
            "{} –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –º–æ–¥–µ–ª–∏ Qwen3 (non-interactive)",
            "üì•".blue()
        );
        run_model_install_scripts(needs_emb, needs_rerank)?;
        return Ok(());
    }

    println!("{} –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –º–æ–¥–µ–ª–∏ Qwen3.", "‚Ñπ".cyan());
    println!(
        "  - embedding: {}",
        if needs_emb {
            "missing".red()
        } else {
            "ok".green()
        }
    );
    println!(
        "  - reranker: {}",
        if needs_rerank {
            "missing".red()
        } else {
            "ok".green()
        }
    );
    print!("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ–π—á–∞—Å? [Y/n]: ");
    stdout().flush().ok();

    let mut answer = String::new();
    let _ = stdin().read_line(&mut answer);
    let yes =
        answer.trim().is_empty() || matches!(answer.trim().to_lowercase().as_str(), "y" | "yes");
    if yes {
        run_model_install_scripts(needs_emb, needs_rerank)?;
    }
    Ok(())
}

fn run_model_install_scripts(emb: bool, rerank: bool) -> Result<()> {
    use std::process::Command;
    if emb {
        let _ = Command::new("python3")
            .args(["scripts/install_qwen3_onnx.py", "--component", "embedding"])
            .status();
    }
    if rerank {
        let _ = Command::new("python3")
            .args(["scripts/install_qwen3_onnx.py", "--component", "reranker"])
            .status();
    }
    Ok(())
}

fn ensure_ort_installed_interactive() -> Result<()> {
    use colored::Colorize;
    use std::io::{stdin, stdout, Write};

    if std::env::var("MAGRAY_FORCE_NO_ORT")
        .ok()
        .map(|s| s == "1" || s.to_lowercase() == "true")
        .unwrap_or(false)
    {
        return Ok(());
    }

    // –ï—Å–ª–∏ –µ—Å—Ç—å ORT_DYLIB_PATH –∏–ª–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –ª–∏–±—Ä–∞ ‚Äî –≤—ã—Ö–æ–¥–∏–º
    if std::env::var("ORT_DYLIB_PATH").is_ok() {
        return Ok(());
    }
    let candidate = std::path::Path::new("scripts/onnxruntime/lib/libonnxruntime.so");
    if candidate.exists() {
        std::env::set_var("ORT_DYLIB_PATH", candidate.display().to_string());
        return Ok(());
    }

    let non_interactive = std::env::var("CI").is_ok() || std::env::var("MAGRAY_AUTO_YES").is_ok();
    if non_interactive {
        println!(
            "{} –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é ONNX Runtime (non-interactive)",
            "üì•".blue()
        );
        run_ort_install_script()?;
        return Ok(());
    }

    println!("{} ONNX Runtime –Ω–µ –Ω–∞–π–¥–µ–Ω.", "‚Ñπ".cyan());
    print!("–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ–π—á–∞—Å? [Y/n]: ");
    stdout().flush().ok();
    let mut answer = String::new();
    let _ = stdin().read_line(&mut answer);
    let yes =
        answer.trim().is_empty() || matches!(answer.trim().to_lowercase().as_str(), "y" | "yes");
    if yes {
        run_ort_install_script()?;
    }
    Ok(())
}

fn run_ort_install_script() -> Result<()> {
    use std::process::Command;
    let status = Command::new("bash")
        .args(["scripts/install_onnxruntime.sh"])
        .status()?;
    if status.success() {
        // Try to set default path
        let p = std::path::Path::new("scripts/onnxruntime/lib/libonnxruntime.so");
        if p.exists() {
            std::env::set_var("ORT_DYLIB_PATH", p.display().to_string());
        }
    }
    Ok(())
}

/// –ó–∞–ø—É—Å–∫ TUI –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –¥–ª—è Plan‚ÜíPreview‚ÜíExecute workflow
async fn run_tui_mode() -> Result<()> {
    println!("üñ•  Starting MAGRAY TUI Interface...");

    // –°–æ–∑–¥–∞–µ–º TUI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    let mut app = TUIApp::new().map_err(|e| anyhow::anyhow!("Failed to initialize TUI: {}", e))?;

    println!("üöÄ TUI initialized successfully. Press 'q' to quit, 'h' for help.");

    // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å orchestrator (–∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è MVP)
    // –í –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –±—É–¥–µ—Ç —Ä–µ–∞–ª—å–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å AgentOrchestrator

    // –ó–∞–ø—É—Å–∫–∞–µ–º TUI
    if let Err(e) = app.run() {
        eprintln!("TUI error: {e}");
        return Err(anyhow::anyhow!("TUI execution failed: {}", e));
    }

    println!("üëã TUI session ended.");
    Ok(())
}
