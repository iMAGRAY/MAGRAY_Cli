// @component: {"k":"C","id":"test_adaround","t":"Tests for AdaRound quantization","m":{"cur":35,"tgt":90,"u":"%"}}

use ai::quantization::{
    AdaRoundQuantizer, AdaRoundConfig, QuantizationConfig, QuantizationStrategy,
    CalibrationDataset, CalibrationMethod, ModelOptimizer,
};
use std::path::PathBuf;
use tempfile::TempDir;

/// Тест базовой функциональности квантизации
#[tokio::test]
async fn test_basic_quantization() -> anyhow::Result<()> {
    // Создаем временную директорию для выходных файлов
    let temp_dir = TempDir::new()?;
    let output_path = temp_dir.path().join("quantized_model.onnx");
    
    // Создаем конфигурацию
    let config = QuantizationConfig {
        strategy: QuantizationStrategy::Balanced,
        target_accuracy: 0.95,
        max_quality_loss: 0.05,
        use_adaround: false, // Начнем с простой квантизации
        use_mixed_precision: false,
        use_selective_quantization: false,
        calibration_method: CalibrationMethod::MinMax,
        calibration_samples: 10,
        bits: 8,
        symmetric: true,
        per_channel: false,
        optimize_graph: false,
        layer_fusion: false,
        parallel_processing: false,
        num_threads: 1,
    };
    
    // Создаем квантизатор
    let quantizer = AdaRoundQuantizer::new(config);
    
    // Создаем минимальный калибровочный датасет
    let mut calibration_data = CalibrationDataset::new(128);
    calibration_data.add_sample("def test(): return 42").await?;
    calibration_data.add_sample("print('Hello, World!')").await?;
    
    assert_eq!(calibration_data.len(), 2);
    
    Ok(())
}

/// Тест различных стратегий квантизации
#[test]
fn test_quantization_strategies() {
    let strategies = vec![
        QuantizationStrategy::MaximumQuality,
        QuantizationStrategy::Balanced,
        QuantizationStrategy::MaximumCompression,
        QuantizationStrategy::SpeedOptimized,
    ];
    
    for strategy in strategies {
        let config = QuantizationConfig::from_strategy(strategy);
        
        match strategy {
            QuantizationStrategy::MaximumQuality => {
                assert_eq!(config.target_accuracy, 0.99);
                assert_eq!(config.bits, 8);
                assert!(config.use_adaround);
                assert!(config.use_mixed_precision);
                assert!(config.use_selective_quantization);
            }
            QuantizationStrategy::Balanced => {
                assert_eq!(config.target_accuracy, 0.98);
                assert_eq!(config.bits, 8);
            }
            QuantizationStrategy::MaximumCompression => {
                assert_eq!(config.target_accuracy, 0.95);
                assert_eq!(config.bits, 4);
                assert!(config.symmetric);
                assert!(!config.per_channel);
            }
            QuantizationStrategy::SpeedOptimized => {
                assert_eq!(config.target_accuracy, 0.97);
                assert!(config.symmetric);
                assert!(config.layer_fusion);
                assert!(config.optimize_graph);
            }
        }
    }
}

/// Тест конфигурации AdaRound
#[test]
fn test_adaround_config() {
    let config = AdaRoundConfig::default();
    
    assert_eq!(config.iterations, 1000);
    assert_eq!(config.learning_rate, 0.01);
    assert_eq!(config.batch_size, 32);
    assert_eq!(config.reg_param, 0.01);
    assert_eq!(config.temperature, 1.0);
    assert_eq!(config.rounding_threshold, 0.5);
}

/// Тест калибровочного датасета
#[tokio::test]
async fn test_calibration_dataset() -> anyhow::Result<()> {
    let mut dataset = CalibrationDataset::new(256);
    
    // Добавляем разнообразные примеры кода
    dataset.load_diverse_code_samples(50).await?;
    
    assert_eq!(dataset.len(), 50);
    assert!(!dataset.is_empty());
    
    // Тестируем итератор по батчам
    let batch_size = 10;
    let mut batch_count = 0;
    let mut total_samples = 0;
    
    for batch in dataset.iter_batches(batch_size) {
        batch_count += 1;
        total_samples += batch.len();
        assert!(batch.len() <= batch_size);
    }
    
    assert_eq!(batch_count, 5);
    assert_eq!(total_samples, 50);
    
    Ok(())
}

/// Тест оптимизатора модели
#[test] 
fn test_model_optimizer() {
    let optimizer = ModelOptimizer::new();
    
    // Проверяем настройки по умолчанию
    let optimizations = vec![
        "Graph optimization",
        "Layer fusion", 
        "Remove unused nodes",
        "Constant folding",
    ];
    
    // В реальном тесте мы бы проверили применение оптимизаций
    // Пока просто проверяем, что оптимизатор создается
    assert_eq!(optimizations.len(), 4);
}

/// Тест методов калибровки
#[test]
fn test_calibration_methods() {
    let methods = vec![
        CalibrationMethod::MinMax,
        CalibrationMethod::Percentile { percentile: 99.9 },
        CalibrationMethod::Entropy,
        CalibrationMethod::MSE,
    ];
    
    for method in methods {
        match method {
            CalibrationMethod::MinMax => {
                // MinMax использует полный диапазон значений
            }
            CalibrationMethod::Percentile { percentile } => {
                assert!(percentile > 0.0 && percentile <= 100.0);
            }
            CalibrationMethod::Entropy => {
                // Энтропийный метод минимизирует потерю информации
            }
            CalibrationMethod::MSE => {
                // MSE минимизирует среднеквадратическую ошибку
            }
        }
    }
}

/// Интеграционный тест (требует реальную модель)
#[tokio::test]
#[ignore] // Игнорируем, так как требует реальные файлы моделей
async fn test_full_quantization_pipeline() -> anyhow::Result<()> {
    let input_model = PathBuf::from("crates/memory/models/bge-code-v1/model.onnx");
    let temp_dir = TempDir::new()?;
    let output_model = temp_dir.path().join("quantized_model.onnx");
    
    // Создаем конфигурацию с AdaRound
    let config = QuantizationConfig::from_strategy(QuantizationStrategy::MaximumQuality);
    
    // Настройка AdaRound
    let adaround_config = AdaRoundConfig {
        iterations: 100, // Меньше итераций для теста
        ..Default::default()
    };
    
    // Создаем квантизатор
    let mut quantizer = AdaRoundQuantizer::new(config)
        .with_adaround_config(adaround_config);
    
    // Загружаем модель
    quantizer.load_model(&input_model)?;
    
    // Подготавливаем калибровочные данные
    let mut calibration_data = CalibrationDataset::new(512);
    calibration_data.load_diverse_code_samples(100).await?;
    
    // Запускаем квантизацию
    let result = quantizer.quantize(&calibration_data, &output_model).await?;
    
    // Проверяем результаты
    assert!(result.compression_ratio > 1.0);
    assert!(result.accuracy_preserved > 0.9);
    assert!(result.inference_speedup > 1.0);
    assert!(result.quantization_time_sec > 0.0);
    assert!(output_model.exists());
    
    Ok(())
}