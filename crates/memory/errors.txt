warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:26:5
   |
26 |     async fn shutdown(&self) -> Result<(), crate::MagrayCoreError> {
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
   = note: `#[warn(async_fn_in_trait)]` on by default
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
26 ~     fn shutdown(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
27 |         Ok(())
28 ~     } }
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:37:5
   |
37 |     async fn update_config(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
37 -     async fn update_config(&mut self, config: T) -> Result<(), crate::MagrayCoreError>;
37 +     fn update_config(&mut self, config: T) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:65:5
   |
65 |     async fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> Result<R, E>
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
65 -     async fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> Result<R, E>
65 +     fn execute_with_circuit_breaker<F, R, E>(&self, operation: F) -> impl std::future::Future<Output = Result<R, E>> + Send
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
  --> crates\common\src\service_traits.rs:84:5
   |
84 |     async fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> Result<R, E>
   |     ^^^^^
   |
   = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
   |
84 -     async fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> Result<R, E>
84 +     fn execute_with_retry<F, Fut, R, E>(&self, operation: F) -> impl std::future::Future<Output = Result<R, E>> + Send
   |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:118:5
    |
118 |     async fn initialize(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
118 -     async fn initialize(&mut self) -> Result<(), crate::MagrayCoreError>;
118 +     fn initialize(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:121:5
    |
121 |     async fn start(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
121 -     async fn start(&mut self) -> Result<(), crate::MagrayCoreError>;
121 +     fn start(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:124:5
    |
124 |     async fn pause(&mut self) -> Result<(), crate::MagrayCoreError> {
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
124 ~     fn pause(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
125 |         Ok(())
126 ~     } }
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:129:5
    |
129 |     async fn resume(&mut self) -> Result<(), crate::MagrayCoreError> {
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
129 ~     fn resume(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send {async {
130 |         Ok(())
131 ~     } }
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:134:5
    |
134 |     async fn stop(&mut self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
134 -     async fn stop(&mut self) -> Result<(), crate::MagrayCoreError>;
134 +     fn stop(&mut self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:362:5
    |
362 |     async fn register_service(
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
362 ~     fn register_service(
363 |         &mut self,
364 |         service: Arc<Self::Service>,
365 ~     ) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:368:5
    |
368 |     async fn unregister_service(
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
368 ~     fn unregister_service(
369 |         &mut self,
370 |         service_name: &str,
371 ~     ) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:403:5
    |
403 |     async fn get_connection(&self) -> Result<Self::Connection, Self::Error>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
403 -     async fn get_connection(&self) -> Result<Self::Connection, Self::Error>;
403 +     fn get_connection(&self) -> impl std::future::Future<Output = Result<Self::Connection, Self::Error>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:406:5
    |
406 |     async fn return_connection(&self, connection: Self::Connection) -> Result<(), Self::Error>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
406 -     async fn return_connection(&self, connection: Self::Connection) -> Result<(), Self::Error>;
406 +     fn return_connection(&self, connection: Self::Connection) -> impl std::future::Future<Output = Result<(), Self::Error>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:423:5
    |
423 |     async fn get(&self, key: &K) -> Option<V>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
423 -     async fn get(&self, key: &K) -> Option<V>;
423 +     fn get(&self, key: &K) -> impl std::future::Future<Output = Option<V>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:426:5
    |
426 |     async fn set(&self, key: K, value: V) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
426 -     async fn set(&self, key: K, value: V) -> Result<(), crate::MagrayCoreError>;
426 +     fn set(&self, key: K, value: V) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:429:5
    |
429 |     async fn remove(&self, key: &K) -> Result<bool, crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
429 -     async fn remove(&self, key: &K) -> Result<bool, crate::MagrayCoreError>;
429 +     fn remove(&self, key: &K) -> impl std::future::Future<Output = Result<bool, crate::MagrayCoreError>> + Send;
    |

warning: use of `async fn` in public traits is discouraged as auto trait bounds cannot be specified
   --> crates\common\src\service_traits.rs:432:5
    |
432 |     async fn clear(&self) -> Result<(), crate::MagrayCoreError>;
    |     ^^^^^
    |
    = note: you can suppress this lint if you plan to use the trait only in your own code, or do not care about auto traits like `Send` on the `Future`
help: you can alternatively desugar to a normal `fn` that returns `impl Future` and add any desired bounds such as `Send`, but these cannot be relaxed without a breaking API change
    |
432 -     async fn clear(&self) -> Result<(), crate::MagrayCoreError>;
432 +     fn clear(&self) -> impl std::future::Future<Output = Result<(), crate::MagrayCoreError>> + Send;
    |

warning: `common` (lib) generated 17 warnings
    Checking ai v0.1.0 (C:\Users\1\Documents\GitHub\MAGRAY_Cli\crates\ai)
warning: unused import: `GpuDevice`
 --> crates\ai\src\auto_device_selector.rs:6:30
  |
6 | use dummy_gpu::{GpuDetector, GpuDevice};
  |                              ^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: `ai` (lib) generated 1 warning (run `cargo fix --lib -p ai` to apply 1 suggestion)
    Checking memory v0.1.0 (C:\Users\1\Documents\GitHub\MAGRAY_Cli\crates\memory)
error[E0252]: the name `LifecycleManager` is defined multiple times
  --> crates\memory\src\orchestration\mod.rs:71:9
   |
50 |     CoordinatorRegistry as LifecycleCoordinatorRegistry, LifecycleManager,
   |                                                          ---------------- previous import of the trait `LifecycleManager` here
...
71 | pub use lifecycle_manager::LifecycleManager;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `LifecycleManager` reimported here
   |
   = note: `LifecycleManager` must be defined only once in the type namespace of this module
help: you can use `as` to change the binding name of the import
   |
71 | pub use lifecycle_manager::LifecycleManager as OtherLifecycleManager;
   |                                             ++++++++++++++++++++++++

warning: unused import: `serde::Serialize`
 --> crates\memory\src\ml_promotion\algorithms.rs:4:5
  |
4 | use serde::Serialize;
  |     ^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `TrainingExample`
  --> crates\memory\src\ml_promotion\coordinator.rs:13:80
   |
13 |     DataProcessor, PromotionAlgorithm, PromotionMetrics, PromotionRulesEngine, TrainingExample,
   |                                                                                ^^^^^^^^^^^^^^^

warning: unused imports: `MLPromotionConfig` and `SemanticContext`
  --> crates\memory\src\ml_promotion\data_processor.rs:11:35
   |
11 | use super::types::{AccessPattern, MLPromotionConfig, PromotionFeatures, SemanticContext};
   |                                   ^^^^^^^^^^^^^^^^^                     ^^^^^^^^^^^^^^^

warning: unused import: `DateTime`
 --> crates\memory\src\ml_promotion\legacy_facade.rs:5:14
  |
5 | use chrono::{DateTime, Utc};
  |              ^^^^^^^^

warning: unused import: `warn`
 --> crates\memory\src\ml_promotion\legacy_facade.rs:7:28
  |
7 | use tracing::{debug, info, warn};
  |                            ^^^^

warning: unused import: `anyhow`
 --> crates\memory\src\notifications.rs:1:14
  |
1 | use anyhow::{anyhow, Result};
  |              ^^^^^^

warning: unused import: `warn`
  --> crates\memory\src\simd_feature_detection.rs:13:28
   |
13 | use tracing::{debug, info, warn};
   |                            ^^^^

warning: unused imports: `debug`, `error`, and `warn`
  --> crates\memory\src\di\unified_container_impl.rs:30:11
   |
30 | use log::{debug, error, warn};
   |           ^^^^^  ^^^^^  ^^^^

warning: unused import: `Duration`
 --> crates\memory\src\di\lifetime_manager.rs:7:12
  |
7 |     time::{Duration, Instant},
  |            ^^^^^^^^

warning: unused imports: `MetricsReporter` and `TypeMetrics`
  --> crates\memory\src\di\lifetime_manager.rs:11:48
   |
11 | use super::traits::{Lifetime, LifetimeManager, MetricsReporter, TypeMetrics};
   |                                                ^^^^^^^^^^^^^^^  ^^^^^^^^^^^

warning: unused imports: `DIRegistrar`, `Lifetime`, and `UnifiedDIContainerBuilder`
  --> crates\memory\src\di\migration_facade.rs:19:13
   |
19 | use super::{DIRegistrar, DIResolver, Lifetime, UnifiedDIContainer, UnifiedDIContainerBuilder};
   |             ^^^^^^^^^^^              ^^^^^^^^                      ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::storage::VectorStore`
    --> crates\memory\src\di\unified_container.rs:1075:13
     |
1075 |         use crate::storage::VectorStore;
     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `PromotionConfig` and `Record`
    --> crates\memory\src\di\unified_container.rs:1076:28
     |
1076 |         use crate::types::{PromotionConfig, Record};
     |                            ^^^^^^^^^^^^^^^  ^^^^^^

warning: unexpected `cfg` condition value: `hot-reload`
   --> crates\memory\src\di\config_loader.rs:525:7
    |
525 | #[cfg(feature = "hot-reload")]
    |       ^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `backup-restore`, `colored`, `cpu`, `cuda`, `default`, `embeddings`, `flate2`, `gpu`, `gpu-acceleration`, `hnsw-index`, `hnsw_rs`, `minimal`, `notifications`, `num_cpus`, `persistence`, `rayon`, `reqwest`, `sled`, `tar`, and `vector-search`
    = help: consider adding `hot-reload` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unexpected `cfg` condition value: `hot-reload`
   --> crates\memory\src\di\config_loader.rs:532:7
    |
532 | #[cfg(feature = "hot-reload")]
    |       ^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: expected values for `feature` are: `backup-restore`, `colored`, `cpu`, `cuda`, `default`, `embeddings`, `flate2`, `gpu`, `gpu-acceleration`, `hnsw-index`, `hnsw_rs`, `minimal`, `notifications`, `num_cpus`, `persistence`, `rayon`, `reqwest`, `sled`, `tar`, and `vector-search`
    = help: consider adding `hot-reload` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration

warning: unused imports: `CoreSystemConfig`, `DatabaseConfig`, `MemorySystemConfig`, `OrchestrationConfig`, `PerformanceConfig`, and `SecurityConfig`
  --> crates\memory\src\di\config_presets.rs:11:5
   |
11 |     CoreSystemConfig, DatabaseConfig, Environment, FeatureFlags, MemorySystemConfig,
   |     ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^                             ^^^^^^^^^^^^^^^^^^
12 |     OrchestrationConfig, PerformanceConfig, PerformanceThresholds, ProfilingConfig,
   |     ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^
13 |     RateLimitConfig, SecurityConfig, UnifiedDIConfiguration,
   |                      ^^^^^^^^^^^^^^

warning: unused import: `AtomicU64`
  --> crates\memory\src\orchestration\metrics_collector.rs:11:30
   |
11 |         atomic::{AtomicBool, AtomicU64, Ordering},
   |                              ^^^^^^^^^

warning: unused import: `LifecycleManager`
  --> crates\memory\src\orchestration\mod.rs:50:58
   |
50 |     CoordinatorRegistry as LifecycleCoordinatorRegistry, LifecycleManager,
   |                                                          ^^^^^^^^^^^^^^^^

warning: unused import: `traits::DIResolver`
  --> crates\memory\src\services\cache_service.rs:16:10
   |
16 |     di::{traits::DIResolver, unified_container::UnifiedDIContainer},
   |          ^^^^^^^^^^^^^^^^^^

warning: variable does not need to be mutable
   --> crates\memory\src\ml_promotion\coordinator.rs:113:24
    |
113 |     pub async fn build(mut self) -> Result<PromotionCoordinator> {
    |                        ----^^^^
    |                        |
    |                        help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `health_manager`
   --> crates\memory\src\service_di\coordinator_factory.rs:235:21
    |
235 |         if let Some(health_manager) = &self.health_manager {
    |                     ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_health_manager`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `stats`
   --> crates\memory\src\service_di\coordinator_factory.rs:260:17
    |
260 |             let stats = search_coord.metrics().await;
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_stats`

error[E0560]: struct `PipelineConfig` has no field named `max_concurrent_batches`
   --> crates\memory\src\gpu_accelerated.rs:265:13
    |
265 |             max_concurrent_batches: Self::get_optimal_gpu_streams()?,
    |             ^^^^^^^^^^^^^^^^^^^^^^ `PipelineConfig` does not have this field
    |
    = note: available fields are: `max_batch_size`

error[E0560]: struct `PipelineConfig` has no field named `optimal_batch_size`
   --> crates\memory\src\gpu_accelerated.rs:266:13
    |
266 |             optimal_batch_size: Self::get_safe_batch_size(config.max_batch_size)?,
    |             ^^^^^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
266 -             optimal_batch_size: Self::get_safe_batch_size(config.max_batch_size)?,
266 +             max_batch_size: Self::get_safe_batch_size(config.max_batch_size)?,
    |

error[E0560]: struct `PipelineConfig` has no field named `min_batch_size`
   --> crates\memory\src\gpu_accelerated.rs:267:13
    |
267 |             min_batch_size: 32,
    |             ^^^^^^^^^^^^^^ unknown field
    |
help: a field with a similar name exists
    |
267 -             min_batch_size: 32,
267 +             max_batch_size: 32,
    |

error[E0560]: struct `PipelineConfig` has no field named `prefetch_enabled`
   --> crates\memory\src\gpu_accelerated.rs:268:13
    |
268 |             prefetch_enabled: Self::can_use_prefetch(),
    |             ^^^^^^^^^^^^^^^^ `PipelineConfig` does not have this field
    |
    = note: available fields are: `max_batch_size`

error[E0560]: struct `PipelineConfig` has no field named `memory_pooling_enabled`
   --> crates\memory\src\gpu_accelerated.rs:269:13
    |
269 |             memory_pooling_enabled: Self::can_use_pinned_memory(),
    |             ^^^^^^^^^^^^^^^^^^^^^^ `PipelineConfig` does not have this field
    |
    = note: available fields are: `max_batch_size`

error[E0560]: struct `PipelineConfig` has no field named `adaptive_batching`
   --> crates\memory\src\gpu_accelerated.rs:270:13
    |
270 |             adaptive_batching: true,
    |             ^^^^^^^^^^^^^^^^^ `PipelineConfig` does not have this field
    |
    = note: available fields are: `max_batch_size`

error[E0599]: no function or associated item named `new` found for struct `GpuPipelineManager` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:281:33
    |
98  | pub struct GpuPipelineManager;
    | ----------------------------- function or associated item `new` not found for this struct
...
281 |             GpuPipelineManager::new(embedding_config.clone(), pipeline_config),
    |                                 ^^^ function or associated item not found in `GpuPipelineManager`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `new`, perhaps you need to implement one of them:
            candidate #1: `Bit`
            candidate #2: `Digest`
            candidate #3: `KeyInit`
            candidate #4: `KeyIvInit`
            candidate #5: `UniformSampler`
            candidate #6: `VariableOutput`
            candidate #7: `VariableOutputCore`
            candidate #8: `itertools::adaptors::coalesce::CountItem`
            candidate #9: `ndarray::data_traits::DataOwned`
            candidate #10: `ndarray::data_traits::DataOwned`
            candidate #11: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #12: `parking_lot_core::thread_parker::ThreadParkerT`
            candidate #13: `rand::distr::uniform::UniformSampler`

error[E0599]: no method named `embed_batch` found for struct `Arc<GpuFallbackManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:509:14
    |
507 |           match self
    |  _______________-
508 | |             .embedding_service
509 | |             .embed_batch(vec![text.to_string()])
    | |             -^^^^^^^^^^^ method not found in `Arc<GpuFallbackManager>`
    | |_____________|
    |
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `embed_batch`, perhaps you need to implement one of them:
            candidate #1: `EmbeddingProvider`
            candidate #2: `ai::EmbeddingServiceTrait`

error[E0599]: no method named `create_emergency_cpu_service` found for reference `&GpuBatchProcessor` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:529:20
    |
529 |         match self.create_emergency_cpu_service().await {
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&GpuBatchProcessor`

error[E0599]: no method named `embed_batch` found for struct `Arc<GpuFallbackManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:564:14
    |
562 |           match self
    |  _______________-
563 | |             .embedding_service
564 | |             .embed_batch(vec![text.to_string()])
    | |             -^^^^^^^^^^^ method not found in `Arc<GpuFallbackManager>`
    | |_____________|
    |
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `embed_batch`, perhaps you need to implement one of them:
            candidate #1: `EmbeddingProvider`
            candidate #2: `ai::EmbeddingServiceTrait`

error[E0599]: no method named `process_texts_optimized` found for reference `&Arc<GpuPipelineManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:618:22
    |
617 |                   match pipeline
    |  _______________________-
618 | |                     .process_texts_optimized(uncached_texts.clone())
    | |                     -^^^^^^^^^^^^^^^^^^^^^^^ method not found in `&Arc<GpuPipelineManager>`
    | |_____________________|
    |

error[E0599]: no method named `embed_batch` found for struct `Arc<GpuFallbackManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:625:30
    |
624 | /                         self.embedding_service
625 | |                             .embed_batch(uncached_texts.clone())
    | |                             -^^^^^^^^^^^ method not found in `Arc<GpuFallbackManager>`
    | |_____________________________|
    |
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `embed_batch`, perhaps you need to implement one of them:
            candidate #1: `EmbeddingProvider`
            candidate #2: `ai::EmbeddingServiceTrait`

error[E0599]: no method named `embed_batch` found for struct `Arc<GpuFallbackManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:643:22
    |
642 | /                 self.embedding_service
643 | |                     .embed_batch(uncached_texts.clone())
    | |                     -^^^^^^^^^^^ method not found in `Arc<GpuFallbackManager>`
    | |_____________________|
    |
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `embed_batch`, perhaps you need to implement one of them:
            candidate #1: `EmbeddingProvider`
            candidate #2: `ai::EmbeddingServiceTrait`

error[E0599]: no method named `get_stats` found for reference `&Arc<GpuPipelineManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:749:27
    |
749 |             Some(pipeline.get_stats().await)
    |                           ^^^^^^^^^ method not found in `&Arc<GpuPipelineManager>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `get_stats`, perhaps you need to implement one of them:
            candidate #1: `MetricsReporter`
            candidate #2: `PromotionMetrics`
            candidate #3: `StatisticsProvider`

error[E0599]: no method named `reset_circuit_breaker` found for struct `Arc<GpuFallbackManager>` in the current scope
   --> crates\memory\src\gpu_accelerated.rs:861:36
    |
861 |             self.embedding_service.reset_circuit_breaker();
    |                                    ^^^^^^^^^^^^^^^^^^^^^ method not found in `Arc<GpuFallbackManager>`
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `ResilienceServiceTrait` defines an item `reset_circuit_breaker`, perhaps you need to implement it
   --> crates\memory\src\services\traits.rs:94:1
    |
94  | pub trait ResilienceServiceTrait: Send + Sync {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `path`
   --> crates\memory\src\di\migration_facade.rs:227:39
    |
227 |     pub async fn create_backup(&self, path: &str) -> Result<BackupMetadata> {
    |                                       ^^^^ help: if this is intentional, prefix it with an underscore: `_path`

warning: unused variable: `container`
   --> crates\memory\src\di\migration_facade.rs:363:9
    |
363 |         container: &UnifiedDIContainer,
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_container`

warning: unused variable: `db_path`
    --> crates\memory\src\di\unified_container.rs:1085:21
     |
1085 |                 let db_path: PathBuf = db_path.clone();
     |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_db_path`

warning: unused variable: `db_path`
    --> crates\memory\src\di\unified_container.rs:1111:13
     |
1111 |         let db_path = config.db_path.clone();
     |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_db_path`

warning: unused variable: `config`
    --> crates\memory\src\di\unified_container.rs:1121:9
     |
1121 |         config: &MemoryServiceConfig,
     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_config`

warning: value assigned to `circuit_breaker_triggered` is never read
   --> crates\memory\src\orchestration\operation_executor.rs:167:13
    |
167 |             circuit_breaker_triggered = true;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` on by default

warning: unused variable: `metrics`
   --> crates\memory\src\orchestration\operation_executor.rs:223:21
    |
223 |                 let metrics = OperationMetrics {
    |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_metrics`

warning: unused variable: `query`
   --> crates\memory\src\orchestration\orchestration_facade.rs:118:9
    |
118 |         query: &str,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_query`

warning: unused variable: `layer`
   --> crates\memory\src\orchestration\orchestration_facade.rs:119:9
    |
119 |         layer: Layer,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_layer`

warning: unused variable: `options`
   --> crates\memory\src\orchestration\orchestration_facade.rs:120:9
    |
120 |         options: SearchOptions,
    |         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `text`
   --> crates\memory\src\orchestration\orchestration_facade.rs:128:39
    |
128 |     pub async fn get_embedding(&self, text: &str) -> Result<Vec<f32>> {
    |                                       ^^^^ help: if this is intentional, prefix it with an underscore: `_text`

warning: unused variable: `path`
   --> crates\memory\src\orchestration\orchestration_facade.rs:142:39
    |
142 |     pub async fn create_backup(&self, path: &str) -> Result<BackupMetadata> {
    |                                       ^^^^ help: if this is intentional, prefix it with an underscore: `_path`

warning: unused variable: `container`
   --> crates\memory\src\services\factory_traits.rs:520:9
    |
520 |         container: &UnifiedDIContainer,
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_container`

warning: unused variable: `dependency`
   --> crates\memory\src\di\dependency_validator.rs:126:18
    |
126 |             for &dependency in deps {
    |                  ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_dependency`

warning: unused variable: `base`
   --> crates\memory\src\di\config_loader.rs:456:9
    |
456 |         base: UnifiedDIConfiguration,
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_base`

warning: unused variable: `other`
   --> crates\memory\src\di\container_configuration.rs:337:33
    |
337 |     pub fn merge_with(mut self, other: DIContainerConfiguration) -> Self {
    |                                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_other`

warning: variable does not need to be mutable
   --> crates\memory\src\di\container_configuration.rs:337:23
    |
337 |     pub fn merge_with(mut self, other: DIContainerConfiguration) -> Self {
    |                       ----^^^^
    |                       |
    |                       help: remove this `mut`

warning: unused variable: `cache_stats`
   --> crates\memory\src\di\optimized_unified_container.rs:162:13
    |
162 |         let cache_stats = self.cache.stats();
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cache_stats`

Some errors have detailed explanations: E0252, E0560, E0599.
For more information about an error, try `rustc --explain E0252`.
warning: `memory` (lib) generated 40 warnings
error: could not compile `memory` (lib) due to 16 previous errors; 40 warnings emitted
