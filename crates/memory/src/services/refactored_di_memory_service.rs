//! Refactored DIMemoryService - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å–µ—Ä–≤–∏—Å–∞–º
//!
//! –ù–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤ SOLID:
//! - –î–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–º–µ—Å—Ç–æ –º–æ–Ω–æ–ª–∏—Ç–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
//! - –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –≤–º–µ—Å—Ç–æ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è  
//! - Dependency Injection –¥–ª—è –≤—Å–µ—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
//! - –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ API

use anyhow::Result;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tracing::{debug, error, info, warn};

use crate::{
    api::MemoryServiceTrait,
    backup::BackupMetadata,
    di::{DIResolver, UnifiedDIContainer, UnifiedMemoryConfigurator},
    health::SystemHealthStatus,
    promotion::PromotionStats,
    service_di::{BatchInsertResult, BatchSearchResult, MemorySystemStats},
    service_di_facade::MemoryServiceConfig,
    services::{ServiceCollection, ServiceFactory, ServiceFactoryConfig},
    types::{Layer, Record, SearchOptions},
    DIContainerStats, DIPerformanceMetrics,
};

/// Refactored DIMemoryService –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π –∫–æ–º–ø–æ–∑–∏—Ü–∏—é —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
/// –í–º–µ—Å—Ç–æ God Object —Ç–µ–ø–µ—Ä—å –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ 5 —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å–µ—Ä–≤–∏—Å–∞–º
pub struct RefactoredDIMemoryService {
    /// DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å–æ –≤—Å–µ–º–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è–º–∏
    container: Arc<UnifiedDIContainer>,

    /// –ö–æ–ª–ª–µ–∫—Ü–∏—è –≤—Å–µ—Ö —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    services: ServiceCollection,

    /// –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Ä–∞–±–æ—Ç–µ
    ready: Arc<std::sync::atomic::AtomicBool>,

    /// Performance timer
    #[allow(dead_code)] // –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    performance_timer: Arc<std::sync::Mutex<Instant>>,

    /// Lifecycle manager –¥–ª—è graceful shutdown
    lifecycle_manager: Arc<tokio::sync::RwLock<LifecycleManager>>,
}

/// Lifecycle manager –¥–ª—è graceful shutdown (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
#[derive(Debug)]
struct LifecycleManager {
    shutdown_requested: bool,
    shutdown_timeout: Duration,
    active_operations: u32,
}

impl Default for LifecycleManager {
    fn default() -> Self {
        Self {
            shutdown_requested: false,
            shutdown_timeout: Duration::from_secs(30),
            active_operations: 0,
        }
    }
}

impl RefactoredDIMemoryService {
    /// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π refactored service
    pub async fn new(config: MemoryServiceConfig) -> Result<Self> {
        info!("üöÄ –°–æ–∑–¥–∞–Ω–∏–µ RefactoredDIMemoryService —Å –∫–æ–º–ø–æ–∑–∏—Ü–∏–µ–π —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–æ–ª–Ω—ã–π DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        let container = Arc::new(UnifiedMemoryConfigurator::configure_full(&config).await?);

        // –°–æ–∑–¥–∞—ë–º –≤—Å–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã —á–µ—Ä–µ–∑ —Ñ–∞–±—Ä–∏–∫—É
        let service_factory = ServiceFactory::new(container.clone());
        let services = service_factory
            .create_services_with_config(ServiceFactoryConfig::production())
            .await?;

        let service = Self {
            container,
            services,
            ready: Arc::new(std::sync::atomic::AtomicBool::new(false)),
            performance_timer: Arc::new(std::sync::Mutex::new(Instant::now())),
            lifecycle_manager: Arc::new(tokio::sync::RwLock::new(LifecycleManager::default())),
        };

        info!(
            "‚úÖ RefactoredDIMemoryService —Å–æ–∑–¥–∞–Ω —Å {} —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏",
            5
        );

        Ok(service)
    }

    /// –°–æ–∑–¥–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–ª—è —Ç–µ—Å—Ç–æ–≤
    pub async fn new_minimal(config: MemoryServiceConfig) -> Result<Self> {
        info!("üß™ –°–æ–∑–¥–∞–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ RefactoredDIMemoryService –¥–ª—è —Ç–µ—Å—Ç–æ–≤");

        let container = Arc::new(UnifiedMemoryConfigurator::configure_minimal(&config).await?);

        // –°–æ–∑–¥–∞—ë–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è —Ç–µ—Å—Ç–æ–≤
        let service_factory = ServiceFactory::new(container.clone());
        let services = service_factory
            .create_services_with_config(ServiceFactoryConfig::test())
            .await?;

        Ok(Self {
            container,
            services,
            ready: Arc::new(std::sync::atomic::AtomicBool::new(false)),
            performance_timer: Arc::new(std::sync::Mutex::new(Instant::now())),
            lifecycle_manager: Arc::new(tokio::sync::RwLock::new(LifecycleManager::default())),
        })
    }

    /// Production –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ–π —Å–∏—Å—Ç–µ–º—ã
    #[allow(dead_code)]
    pub async fn initialize(&self) -> Result<()> {
        info!("üöÄ Production –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è RefactoredDIMemoryService...");

        let start_time = Instant::now();

        // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–µ —Å–ª–æ–∏ –ø–∞–º—è—Ç–∏ (—á–µ—Ä–µ–∑ core memory service)
        // NOTE: –í —Ç–µ–∫—É—â–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ core memory service –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
        // –í –ø–æ–ª–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã –≤—ã–∑–æ–≤ self.services.core_memory.initialize_memory_layers().await?;

        // 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
        self.services.initialize_all().await?;

        let initialization_time = start_time.elapsed();

        // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –≥–æ—Ç–æ–≤—ã–π –∫ —Ä–∞–±–æ—Ç–µ
        self.ready.store(true, std::sync::atomic::Ordering::Relaxed);

        info!(
            "‚úÖ RefactoredDIMemoryService –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –∑–∞ {:?}",
            initialization_time
        );

        Ok(())
    }

    /// Insert –æ–ø–µ—Ä–∞—Ü–∏—è - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService
    #[allow(dead_code)]
    pub async fn insert(&self, record: Record) -> Result<()> {
        let operation_start = Instant::now();

        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        {
            let mut lifecycle = self.lifecycle_manager.write().await;
            lifecycle.active_operations += 1;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º circuit breaker —á–µ—Ä–µ–∑ ResilienceService
        self.services.resilience.check_circuit_breaker().await?;

        // –í—ã–ø–æ–ª–Ω—è–µ–º insert —á–µ—Ä–µ–∑ CoreMemoryService
        let result = self.services.core_memory.insert(record).await;

        // –£–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        {
            let mut lifecycle = self.lifecycle_manager.write().await;
            lifecycle.active_operations = lifecycle.active_operations.saturating_sub(1);
        }

        let operation_duration = operation_start.elapsed();

        match result {
            Ok(_) => {
                // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é –≤ ResilienceService
                self.services
                    .resilience
                    .record_successful_operation(operation_duration)
                    .await;
                debug!("‚úÖ Insert —É—Å–ø–µ—à–µ–Ω –∑–∞ {:?}", operation_duration);
                Ok(())
            }
            Err(e) => {
                // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –Ω–µ—É–¥–∞—á–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é –≤ ResilienceService
                self.services
                    .resilience
                    .record_failed_operation(operation_duration)
                    .await;
                error!("‚ùå Insert –Ω–µ —É–¥–∞–ª—Å—è: {}", e);
                Err(e)
            }
        }
    }

    /// Batch insert - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService
    #[allow(dead_code)]
    pub async fn insert_batch(&self, records: Vec<Record>) -> Result<()> {
        debug!("üîÑ Batch insert {} –∑–∞–ø–∏—Å–µ–π", records.len());
        self.services.core_memory.insert_batch(records).await
    }

    /// Search –æ–ø–µ—Ä–∞—Ü–∏—è - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService —Å resilience
    #[allow(dead_code)]
    pub async fn search(
        &self,
        query: &str,
        layer: Layer,
        options: SearchOptions,
    ) -> Result<Vec<Record>> {
        let operation_start = Instant::now();

        // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        {
            let mut lifecycle = self.lifecycle_manager.write().await;
            lifecycle.active_operations += 1;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º circuit breaker
        self.services.resilience.check_circuit_breaker().await?;

        debug!("üîç Search –≤ —Å–ª–æ–µ {:?}: '{}'", layer, query);

        // –í—ã–ø–æ–ª–Ω—è–µ–º search —á–µ—Ä–µ–∑ CoreMemoryService
        let result = self
            .services
            .core_memory
            .search(query, layer, options)
            .await;

        // –£–º–µ–Ω—å—à–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        {
            let mut lifecycle = self.lifecycle_manager.write().await;
            lifecycle.active_operations = lifecycle.active_operations.saturating_sub(1);
        }

        let operation_duration = operation_start.elapsed();

        match result {
            Ok(results) => {
                self.services
                    .resilience
                    .record_successful_operation(operation_duration)
                    .await;

                let result_count = results.len();
                let duration_ms = operation_duration.as_millis() as f64;

                if duration_ms > 5.0 {
                    warn!(
                        "‚è±Ô∏è –ú–µ–¥–ª–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫: {:.2}ms –¥–ª—è '{}' (—Ü–µ–ª—å <5ms)",
                        duration_ms, query
                    );
                } else {
                    debug!(
                        "‚ö° –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫: {:.2}ms –¥–ª—è '{}' ({} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤)",
                        duration_ms, query, result_count
                    );
                }

                Ok(results)
            }
            Err(e) => {
                self.services
                    .resilience
                    .record_failed_operation(operation_duration)
                    .await;
                error!("‚ùå Search –Ω–µ —É–¥–∞–ª—Å—è –¥–ª—è '{}': {}", query, e);
                Err(e)
            }
        }
    }

    /// Update - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService
    #[allow(dead_code)]
    pub async fn update(&self, record: Record) -> Result<()> {
        debug!("üîÑ Update –∑–∞–ø–∏—Å–∏ {}", record.id);
        self.services.core_memory.update(record).await
    }

    /// Delete - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService
    #[allow(dead_code)]
    pub async fn delete(&self, id: &uuid::Uuid, layer: Layer) -> Result<()> {
        debug!("üîÑ Delete –∑–∞–ø–∏—Å–∏ {} –∏–∑ —Å–ª–æ—è {:?}", id, layer);
        self.services.core_memory.delete(id, layer).await
    }

    /// Batch insert —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService
    #[allow(dead_code)]
    pub async fn batch_insert(&self, records: Vec<Record>) -> Result<BatchInsertResult> {
        debug!("üîÑ Batch insert {} –∑–∞–ø–∏—Å–µ–π —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏", records.len());
        self.services.core_memory.batch_insert(records).await
    }

    /// Batch search - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ CoreMemoryService
    #[allow(dead_code)]
    pub async fn batch_search(
        &self,
        queries: Vec<String>,
        layer: Layer,
        options: SearchOptions,
    ) -> Result<BatchSearchResult> {
        debug!(
            "üîç Batch search {} –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ —Å–ª–æ–µ {:?}",
            queries.len(),
            layer
        );
        self.services
            .core_memory
            .batch_search(queries, layer, options)
            .await
    }

    /// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∏—Å—Ç–µ–º—ã - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ MonitoringService
    #[allow(dead_code)]
    pub async fn get_stats(&self) -> MemorySystemStats {
        debug!("üìä –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —á–µ—Ä–µ–∑ MonitoringService");
        self.services.monitoring.get_system_stats().await
    }

    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ —Å–∏—Å—Ç–µ–º—ã - –¥–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ MonitoringService
    #[allow(dead_code)]
    pub async fn check_health(&self) -> Result<SystemHealthStatus> {
        debug!("üöë –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —á–µ—Ä–µ–∑ MonitoringService");
        self.services.monitoring.check_health().await
    }

    /// Promotion cycle - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç DI –Ω–∞–ø—Ä—è–º—É—é (legacy compatibility)
    #[allow(dead_code)]
    pub async fn run_promotion(&self) -> Result<PromotionStats> {
        debug!("üîÑ –ó–∞–ø—É—Å–∫ promotion —á–µ—Ä–µ–∑ DI (legacy compatibility)");

        if let Ok(promotion_engine) = self
            .container
            .resolve::<crate::promotion::PromotionEngine>()
        {
            let stats = promotion_engine.run_promotion_cycle().await?;
            info!(
                "‚úì Promotion –∑–∞–≤–µ—Ä—à–µ–Ω: interact_to_insights={}, insights_to_assets={}",
                stats.interact_to_insights, stats.insights_to_assets
            );
            Ok(stats)
        } else {
            debug!("Promotion engine –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω—É–ª–µ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É");
            Ok(PromotionStats {
                interact_to_insights: 0,
                insights_to_assets: 0,
                expired_interact: 0,
                expired_insights: 0,
                total_time_ms: 0,
                index_update_time_ms: 0,
                promotion_time_ms: 0,
                cleanup_time_ms: 0,
            })
        }
    }

    /// Alias –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    #[allow(dead_code)]
    pub async fn run_promotion_cycle(&self) -> Result<PromotionStats> {
        self.run_promotion().await
    }

    /// Flush all operations
    #[allow(dead_code)]
    pub async fn flush_all(&self) -> Result<()> {
        debug!("üîÑ Flush –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π (legacy compatibility)");
        info!("‚úÖ –í—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ flushed");
        Ok(())
    }

    /// Create backup (legacy compatibility —á–µ—Ä–µ–∑ DI)
    #[allow(dead_code)]
    pub async fn create_backup(&self, path: &str) -> Result<BackupMetadata> {
        debug!("üíæ –°–æ–∑–¥–∞–Ω–∏–µ backup —á–µ—Ä–µ–∑ DI: {}", path);

        if let Ok(backup_manager) = self.container.resolve::<crate::backup::BackupManager>() {
            let store = self.container.resolve::<crate::storage::VectorStore>()?;
            let _backup_path = backup_manager
                .create_backup(store, Some(path.to_string()))
                .await?;
            let metadata = BackupMetadata {
                version: 1,
                created_at: chrono::Utc::now(),
                magray_version: "0.1.0".to_string(),
                layers: vec![],
                total_records: 0,
                index_config: Default::default(),
                checksum: None,
                layer_checksums: None,
            };
            info!("‚úì Backup —Å–æ–∑–¥–∞–Ω: {}", path);
            Ok(metadata)
        } else {
            Err(anyhow::anyhow!("Backup manager not configured"))
        }
    }

    /// Production graceful shutdown
    #[allow(dead_code)]
    pub async fn shutdown(&self) -> Result<()> {
        info!("üõë –ù–∞—á–∞–ª–æ graceful shutdown RefactoredDIMemoryService...");

        // –ü–æ–º–µ—á–∞–µ–º —á—Ç–æ shutdown –∑–∞–ø—Ä–æ—à–µ–Ω
        {
            let mut lifecycle = self.lifecycle_manager.write().await;
            lifecycle.shutdown_requested = true;
        }

        // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
        let shutdown_timeout = {
            let lifecycle = self.lifecycle_manager.read().await;
            lifecycle.shutdown_timeout.clone()
        };

        let wait_start = Instant::now();
        while wait_start.elapsed() < shutdown_timeout {
            let active_ops = {
                let lifecycle = self.lifecycle_manager.read().await;
                lifecycle.active_operations
            };

            if active_ops == 0 {
                break;
            }

            debug!("‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è {} –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π...", active_ops);
            tokio::time::sleep(Duration::from_millis(100)).await;
        }

        // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –Ω–µ –≥–æ—Ç–æ–≤—ã–π –∫ —Ä–∞–±–æ—Ç–µ
        self.ready
            .store(false, std::sync::atomic::Ordering::Relaxed);

        // Shutdown –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
        self.services.shutdown_all().await?;

        // –§–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        if let Ok(production_metrics) = self.services.monitoring.get_production_metrics().await {
            info!(
                "üìä –§–∏–Ω–∞–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏: {} –æ–ø–µ—Ä–∞—Ü–∏–π, {} —É—Å–ø–µ—à–Ω—ã—Ö, {} –Ω–µ—É–¥–∞—á–Ω—ã—Ö",
                production_metrics.total_operations,
                production_metrics.successful_operations,
                production_metrics.failed_operations
            );
        }

        info!("‚úÖ Graceful shutdown RefactoredDIMemoryService –∑–∞–≤–µ—Ä—à–µ–Ω");
        Ok(())
    }

    /// DI compatibility methods

    #[allow(dead_code)]
    pub fn resolve<T>(&self) -> Result<Arc<T>>
    where
        T: std::any::Any + Send + Sync + 'static,
    {
        self.container.resolve::<T>()
    }

    #[allow(dead_code)]
    pub fn try_resolve<T>(&self) -> Option<Arc<T>>
    where
        T: std::any::Any + Send + Sync + 'static,
    {
        self.container.try_resolve::<T>()
    }

    #[allow(dead_code)]
    pub fn di_stats(&self) -> DIContainerStats {
        self.container.stats()
    }

    #[allow(dead_code)]
    pub fn get_performance_metrics(&self) -> DIPerformanceMetrics {
        self.container.performance_metrics()
    }

    #[allow(dead_code)]
    pub fn get_performance_report(&self) -> String {
        self.container.get_performance_report()
    }

    #[allow(dead_code)]
    pub fn reset_performance_metrics(&self) {
        self.container.reset_performance_metrics()
    }
}

/// Builder –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è RefactoredDIMemoryService
pub struct RefactoredDIMemoryServiceBuilder {
    config: MemoryServiceConfig,
    minimal: bool,
    service_config: ServiceFactoryConfig,
}

impl RefactoredDIMemoryServiceBuilder {
    pub fn new(config: MemoryServiceConfig) -> Self {
        Self {
            config,
            minimal: false,
            service_config: ServiceFactoryConfig::default(),
        }
    }

    #[allow(dead_code)]
    pub fn minimal(mut self) -> Self {
        self.minimal = true;
        self.service_config = ServiceFactoryConfig::test();
        self
    }

    #[allow(dead_code)]
    pub fn production(mut self) -> Self {
        self.service_config = ServiceFactoryConfig::production();
        self
    }

    #[allow(dead_code)]
    pub fn with_service_config(mut self, config: ServiceFactoryConfig) -> Self {
        self.service_config = config;
        self
    }

    pub async fn build(self) -> Result<RefactoredDIMemoryService> {
        if self.minimal {
            RefactoredDIMemoryService::new_minimal(self.config).await
        } else {
            RefactoredDIMemoryService::new(self.config).await
        }
    }
}

/// –†–µ–∞–ª–∏–∑–∞—Ü–∏—è MemoryServiceTrait –¥–ª—è RefactoredDIMemoryService
/// –î–µ–ª–µ–≥–∏—Ä—É–µ—Ç –∫ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å–µ—Ä–≤–∏—Å–∞–º
impl MemoryServiceTrait for RefactoredDIMemoryService {
    fn search_sync(&self, query: &str, layer: Layer, top_k: usize) -> Result<Vec<Record>> {
        // –°–æ–∑–¥–∞–µ–º search options
        let options = SearchOptions {
            top_k,
            layers: vec![layer],
            ..Default::default()
        };

        // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ async runtime
        match tokio::runtime::Handle::try_current() {
            Ok(_handle) => {
                // –ú—ã –≤ async –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º block_in_place
                tokio::task::block_in_place(|| {
                    tokio::runtime::Handle::current()
                        .block_on(async { self.search(query, layer, options).await })
                })
            }
            Err(_) => {
                // –°–æ–∑–¥–∞–µ–º runtime –¥–ª—è sync –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                let rt = tokio::runtime::Runtime::new()?;
                rt.block_on(async { self.search(query, layer, options).await })
            }
        }
    }

    fn run_promotion_sync(&self) -> Result<PromotionStats> {
        // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–¥–≤–∏–∂–µ–Ω–∏–µ
        match tokio::runtime::Handle::try_current() {
            Ok(_handle) => tokio::task::block_in_place(|| {
                tokio::runtime::Handle::current()
                    .block_on(async { self.run_promotion_cycle().await })
            }),
            Err(_) => {
                let rt = tokio::runtime::Runtime::new()?;
                rt.block_on(async { self.run_promotion_cycle().await })
            }
        }
    }

    fn get_system_health(&self) -> SystemHealthStatus {
        use crate::health::HealthStatus;
        use chrono::Utc;
        use std::collections::HashMap;

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è
        if self.ready.load(std::sync::atomic::Ordering::SeqCst) {
            SystemHealthStatus {
                overall_status: HealthStatus::Healthy,
                component_statuses: HashMap::new(),
                active_alerts: Vec::new(),
                metrics_summary: HashMap::new(),
                last_updated: Utc::now(),
                uptime_seconds: 0,
            }
        } else {
            SystemHealthStatus {
                overall_status: HealthStatus::Degraded,
                component_statuses: HashMap::new(),
                active_alerts: Vec::new(),
                metrics_summary: HashMap::new(),
                last_updated: Utc::now(),
                uptime_seconds: 0,
            }
        }
    }

    fn cache_stats(&self) -> (u64, u64, u64) {
        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫—ç—à–∞
        // –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—ã–ª –±—ã –¥–æ—Å—Ç—É–ø –∫ cache metrics
        (0, 0, 0)
    }

    fn remember_sync(&self, text: String, layer: Layer) -> Result<uuid::Uuid> {
        use chrono::Utc;

        let record = Record {
            id: uuid::Uuid::new_v4(),
            text,
            embedding: vec![], // Empty embedding, will be populated later
            layer,
            kind: "user_input".to_string(),
            tags: vec![],
            project: "default".to_string(),
            session: "sync_session".to_string(),
            ts: Utc::now(),
            score: 0.0,
            access_count: 0,
            last_access: Utc::now(),
        };

        // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å
        match tokio::runtime::Handle::try_current() {
            Ok(_handle) => tokio::task::block_in_place(|| {
                tokio::runtime::Handle::current().block_on(async {
                    self.insert(record.clone()).await?;
                    Ok(record.id)
                })
            }),
            Err(_) => {
                let rt = tokio::runtime::Runtime::new()?;
                rt.block_on(async {
                    self.insert(record.clone()).await?;
                    Ok(record.id)
                })
            }
        }
    }
}
